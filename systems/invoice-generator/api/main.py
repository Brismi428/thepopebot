"""
Invoice Generator WAT System — API Bridge

Auto-generated FastAPI application that wraps each Python tool as an HTTP endpoint.
Serves the Next.js static export at / and the API at /api/*.

Generated by WAT Factory generate_api_bridge.py
"""

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
import json
import logging
import os
import sys
import time
import traceback
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Add the system root to Python path so tools can be imported
SYSTEM_ROOT = Path(__file__).parent.parent
if str(SYSTEM_ROOT) not in sys.path:
    sys.path.insert(0, str(SYSTEM_ROOT))

# Import Pydantic models
from models.generate_invoice_pdf import GenerateInvoicePdfRequest
from models.load_config import LoadConfigRequest
from models.manage_counter import ManageCounterRequest
from models.parse_invoice_input import ParseInvoiceInputRequest
from models.save_invoice import SaveInvoiceRequest


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifecycle manager."""
    logger.info("Invoice Generator WAT System API bridge starting up")
    yield
    logger.info("Invoice Generator WAT System API bridge shutting down")


app = FastAPI(
    title="Invoice Generator WAT System API",
    description="API bridge for Invoice Generator WAT System",
    version="1.0.0",
    lifespan=lifespan,
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "http://localhost:3000,http://localhost:8000").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Catch unhandled exceptions and return structured error."""
    logger.error("Unhandled error: %s\n%s", exc, traceback.format_exc())
    return JSONResponse(
        status_code=500,
        content={
            "status": "error",
            "message": str(exc),
            "detail": "An unexpected error occurred.",
        },
    )


@app.get("/api/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": time.time(),
        "system": "Invoice Generator WAT System",
    }


@app.post("/api/generate-invoice-pdf")
async def run_generate_invoice_pdf(request: GenerateInvoicePdfRequest):
    """Run the generate_invoice_pdf tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["generate_invoice_pdf.py", "--output", output_path]
        if request.invoice_data is not None:
            argv.extend(["--invoice-data", str(request.invoice_data)])
        if request.invoice_number is not None:
            argv.extend(["--invoice-number", str(request.invoice_number)])
        if request.config is not None:
            argv.extend(["--config", str(request.config)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.generate_invoice_pdf import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"generate_invoice_pdf failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv

        # Check for generated file
        output_files = list(Path(tmp_dir).glob("*.pdf"))
        if output_files:
            return FileResponse(
                path=str(output_files[0]),
                media_type="application/pdf",
                filename=output_files[0].name,
            )

        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "generate_invoice_pdf completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("generate_invoice_pdf error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/load-config")
async def run_load_config(request: LoadConfigRequest):
    """Run the load_config tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["load_config.py", "--output", output_path]
        if request.config_path is not None:
            argv.extend(["config_path", str(request.config_path)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.load_config import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"load_config failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv


        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "load_config completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("load_config error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/manage-counter")
async def run_manage_counter(request: ManageCounterRequest):
    """Run the manage_counter tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["manage_counter.py", "--output", output_path]
        if request.counter_path is not None:
            argv.extend(["counter_path", str(request.counter_path)])
        if request.action is not None:
            argv.extend(["action", str(request.action)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.manage_counter import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"manage_counter failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv


        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "manage_counter completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("manage_counter error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/parse-invoice-input")
async def run_parse_invoice_input(request: ParseInvoiceInputRequest):
    """Run the parse_invoice_input tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["parse_invoice_input.py", "--output", output_path]
        if request.input_path is not None:
            argv.extend(["input_path", str(request.input_path)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.parse_invoice_input import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"parse_invoice_input failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv


        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "parse_invoice_input completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("parse_invoice_input error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/save-invoice")
async def run_save_invoice(request: SaveInvoiceRequest):
    """Run the save_invoice tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["save_invoice.py", "--output", output_path]
        if request.pdf_path is not None:
            argv.extend(["--pdf-path", str(request.pdf_path)])
        if request.client_name is not None:
            argv.extend(["--client-name", str(request.client_name)])
        if request.invoice_date is not None:
            argv.extend(["--invoice-date", str(request.invoice_date)])
        if request.invoice_number is not None:
            argv.extend(["--invoice-number", str(request.invoice_number)])
        if request.total is not None:
            argv.extend(["--total", str(request.total)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.save_invoice import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"save_invoice failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv

        # Check for generated file
        output_files = list(Path(tmp_dir).glob("*.pdf"))
        if output_files:
            return FileResponse(
                path=str(output_files[0]),
                media_type="application/pdf",
                filename=output_files[0].name,
            )

        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "save_invoice completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("save_invoice error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/run-pipeline")
async def run_pipeline(request: dict = {}):
    """Run the full tool pipeline in workflow order."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    steps_completed = []
    pipeline_input = None

    # If request includes input data, write it to a temp file
    if request:
        pipeline_input = os.path.join(tmp_dir, "pipeline_input.json")
        with open(pipeline_input, "w") as f:
            json.dump(request, f)

    try:

        # Step 1: parse_invoice_input
        logger.info("Pipeline step 1: parse_invoice_input")
        try:
            from tools.parse_invoice_input import main as parse_invoice_input_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "parse_invoice_input_output.json")
            sys.argv = ["parse_invoice_input.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = parse_invoice_input_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 1,
                "tool": "parse_invoice_input",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 1,
                    "tool": "parse_invoice_input",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 1 (parse_invoice_input): exit code {e.code}",
                )
            steps_completed.append({
                "step": 1,
                "tool": "parse_invoice_input",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 1,
                "tool": "parse_invoice_input",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 1 (parse_invoice_input): {e}",
            )

        # Step 2: load_config
        logger.info("Pipeline step 2: load_config")
        try:
            from tools.load_config import main as load_config_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "load_config_output.json")
            sys.argv = ["load_config.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = load_config_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 2,
                "tool": "load_config",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 2,
                    "tool": "load_config",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 2 (load_config): exit code {e.code}",
                )
            steps_completed.append({
                "step": 2,
                "tool": "load_config",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 2,
                "tool": "load_config",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 2 (load_config): {e}",
            )

        # Step 3: manage_counter
        logger.info("Pipeline step 3: manage_counter")
        try:
            from tools.manage_counter import main as manage_counter_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "manage_counter_output.json")
            sys.argv = ["manage_counter.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = manage_counter_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 3,
                "tool": "manage_counter",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 3,
                    "tool": "manage_counter",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 3 (manage_counter): exit code {e.code}",
                )
            steps_completed.append({
                "step": 3,
                "tool": "manage_counter",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 3,
                "tool": "manage_counter",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 3 (manage_counter): {e}",
            )

        # Step 4: generate_invoice_pdf
        logger.info("Pipeline step 4: generate_invoice_pdf")
        try:
            from tools.generate_invoice_pdf import main as generate_invoice_pdf_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "generate_invoice_pdf_output.json")
            sys.argv = ["generate_invoice_pdf.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = generate_invoice_pdf_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 4,
                "tool": "generate_invoice_pdf",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 4,
                    "tool": "generate_invoice_pdf",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 4 (generate_invoice_pdf): exit code {e.code}",
                )
            steps_completed.append({
                "step": 4,
                "tool": "generate_invoice_pdf",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 4,
                "tool": "generate_invoice_pdf",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 4 (generate_invoice_pdf): {e}",
            )

        # Step 5: save_invoice
        logger.info("Pipeline step 5: save_invoice")
        try:
            from tools.save_invoice import main as save_invoice_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "save_invoice_output.json")
            sys.argv = ["save_invoice.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = save_invoice_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 5,
                "tool": "save_invoice",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 5,
                    "tool": "save_invoice",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 5 (save_invoice): exit code {e.code}",
                )
            steps_completed.append({
                "step": 5,
                "tool": "save_invoice",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 5,
                "tool": "save_invoice",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 5 (save_invoice): {e}",
            )

        return JSONResponse(content={
            "status": "success",
            "steps": steps_completed,
            "message": "Pipeline completed successfully",
        })
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Pipeline error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


# Static file serving — Next.js export (must be last)
STATIC_DIR = Path(__file__).parent.parent / "frontend" / "out"
if STATIC_DIR.is_dir():
    app.mount("/", StaticFiles(directory=str(STATIC_DIR), html=True), name="static")
