"""
Website Uptime Checker — Operating Instructions — API Bridge

Auto-generated FastAPI application that wraps each Python tool as an HTTP endpoint.
Serves the Next.js static export at / and the API at /api/*.

Generated by WAT Factory generate_api_bridge.py
"""

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
import json
import logging
import os
import sys
import time
import traceback
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Add the system root to Python path so tools can be imported
SYSTEM_ROOT = Path(__file__).parent.parent
if str(SYSTEM_ROOT) not in sys.path:
    sys.path.insert(0, str(SYSTEM_ROOT))

# Import Pydantic models
from models.log_results import LogResultsRequest
from models.monitor import MonitorRequest
from models.telegram_alert import TelegramAlertRequest


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifecycle manager."""
    logger.info("Website Uptime Checker — Operating Instructions API bridge starting up")
    yield
    logger.info("Website Uptime Checker — Operating Instructions API bridge shutting down")


app = FastAPI(
    title="Website Uptime Checker — Operating Instructions API",
    description="API bridge for Website Uptime Checker — Operating Instructions",
    version="1.0.0",
    lifespan=lifespan,
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "http://localhost:3000,http://localhost:8000").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Catch unhandled exceptions and return structured error."""
    logger.error("Unhandled error: %s\n%s", exc, traceback.format_exc())
    return JSONResponse(
        status_code=500,
        content={
            "status": "error",
            "message": str(exc),
            "detail": "An unexpected error occurred.",
        },
    )


@app.get("/api/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "timestamp": time.time(),
        "system": "Website Uptime Checker — Operating Instructions",
    }


@app.post("/api/log-results")
async def run_log_results(request: LogResultsRequest):
    """Run the log_results tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["log_results.py", "--output", output_path]
        if request.results is not None:
            argv.extend(["--results", str(request.results)])
        if request.log_file is not None:
            argv.extend(["--log-file", str(request.log_file)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.log_results import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"log_results failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv

        # Check for generated file
        output_files = list(Path(tmp_dir).glob("*.csv"))
        if output_files:
            return FileResponse(
                path=str(output_files[0]),
                media_type="text/csv",
                filename=output_files[0].name,
            )

        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "log_results completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("log_results error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/monitor")
async def run_monitor(request: MonitorRequest):
    """Run the monitor tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["monitor.py", "--output", output_path]
        if request.urls is not None:
            argv.extend(["--urls", str(request.urls)])
        if request.timeout is not None:
            argv.extend(["--timeout", str(request.timeout)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.monitor import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"monitor failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv


        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "monitor completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("monitor error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/telegram-alert")
async def run_telegram_alert(request: TelegramAlertRequest):
    """Run the telegram_alert tool."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    output_path = os.path.join(tmp_dir, "output.json")

    try:
        argv = ["telegram_alert.py", "--output", output_path]
        if request.results is not None:
            argv.extend(["--results", str(request.results)])

        original_argv = sys.argv
        sys.argv = argv
        try:
            from tools.telegram_alert import main as tool_main
            result = tool_main()
        except SystemExit as e:
            if e.code and e.code != 0:
                raise HTTPException(status_code=400, detail=f"telegram_alert failed with exit code {e.code}")
            result = None
        finally:
            sys.argv = original_argv


        # Return JSON result
        if result is not None:
            return JSONResponse(content=result)

        # Try reading output file
        if os.path.isfile(output_path):
            with open(output_path, "r") as f:
                return JSONResponse(content=json.load(f))

        return JSONResponse(content={"status": "success", "message": "telegram_alert completed"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error("telegram_alert error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/run-pipeline")
async def run_pipeline(request: dict = {}):
    """Run the full tool pipeline in workflow order."""
    import tempfile
    tmp_dir = tempfile.mkdtemp()
    steps_completed = []
    pipeline_input = None

    # If request includes input data, write it to a temp file
    if request:
        pipeline_input = os.path.join(tmp_dir, "pipeline_input.json")
        with open(pipeline_input, "w") as f:
            json.dump(request, f)

    try:

        # Step 1: monitor
        logger.info("Pipeline step 1: monitor")
        try:
            from tools.monitor import main as monitor_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "monitor_output.json")
            sys.argv = ["monitor.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = monitor_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 1,
                "tool": "monitor",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 1,
                    "tool": "monitor",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 1 (monitor): exit code {e.code}",
                )
            steps_completed.append({
                "step": 1,
                "tool": "monitor",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 1,
                "tool": "monitor",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 1 (monitor): {e}",
            )

        # Step 2: log_results
        logger.info("Pipeline step 2: log_results")
        try:
            from tools.log_results import main as log_results_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "log_results_output.json")
            sys.argv = ["log_results.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = log_results_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 2,
                "tool": "log_results",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 2,
                    "tool": "log_results",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 2 (log_results): exit code {e.code}",
                )
            steps_completed.append({
                "step": 2,
                "tool": "log_results",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 2,
                "tool": "log_results",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 2 (log_results): {e}",
            )

        # Step 3: telegram_alert
        logger.info("Pipeline step 3: telegram_alert")
        try:
            from tools.telegram_alert import main as telegram_alert_main
            original_argv = sys.argv
            step_output = os.path.join(tmp_dir, "telegram_alert_output.json")
            sys.argv = ["telegram_alert.py", "--output", step_output]
            # Pass pipeline_input as the input if the tool accepts it
            if pipeline_input and os.path.isfile(pipeline_input):
                sys.argv.extend(["--input", pipeline_input] if "--input" not in " ".join(sys.argv) else [])
            result = telegram_alert_main()
            sys.argv = original_argv
            pipeline_input = step_output
            steps_completed.append({
                "step": 3,
                "tool": "telegram_alert",
                "status": "success",
                "result": result,
            })
        except SystemExit as e:
            sys.argv = original_argv
            if e.code and e.code != 0:
                steps_completed.append({
                    "step": 3,
                    "tool": "telegram_alert",
                    "status": "failed",
                    "error": f"Exit code {e.code}",
                })
                raise HTTPException(
                    status_code=400,
                    detail=f"Pipeline failed at step 3 (telegram_alert): exit code {e.code}",
                )
            steps_completed.append({
                "step": 3,
                "tool": "telegram_alert",
                "status": "success",
            })
        except HTTPException:
            raise
        except Exception as e:
            steps_completed.append({
                "step": 3,
                "tool": "telegram_alert",
                "status": "failed",
                "error": str(e),
            })
            raise HTTPException(
                status_code=500,
                detail=f"Pipeline failed at step 3 (telegram_alert): {e}",
            )

        return JSONResponse(content={
            "status": "success",
            "steps": steps_completed,
            "message": "Pipeline completed successfully",
        })
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Pipeline error: %s", e)
        raise HTTPException(status_code=500, detail=str(e))


# Static file serving — Next.js export (must be last)
STATIC_DIR = Path(__file__).parent.parent / "frontend" / "out"
if STATIC_DIR.is_dir():
    app.mount("/", StaticFiles(directory=str(STATIC_DIR), html=True), name="static")
