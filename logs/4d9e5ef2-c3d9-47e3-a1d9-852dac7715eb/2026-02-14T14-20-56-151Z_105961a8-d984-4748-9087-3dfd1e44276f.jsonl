{"type":"session","version":3,"id":"105961a8-d984-4748-9087-3dfd1e44276f","timestamp":"2026-02-14T14:20:56.151Z","cwd":"/job"}
{"type":"model_change","id":"f3fd0a0f","parentId":null,"timestamp":"2026-02-14T14:20:56.153Z","provider":"anthropic","modelId":"claude-sonnet-4-5-20250929"}
{"type":"thinking_level_change","id":"9e9d7e4f","parentId":"f3fd0a0f","timestamp":"2026-02-14T14:20:56.153Z","thinkingLevel":"medium"}
{"type":"message","id":"b9bb810c","parentId":"9e9d7e4f","timestamp":"2026-02-14T14:20:56.165Z","message":{"role":"user","content":[{"type":"text","text":"\n\n# Your Job\n\nRead the WAT factory instructions in CLAUDE.md and factory/workflow.md.\n\nGenerate a PRP (Product Requirements Prompt) for a system called \"site-intelligence-pack\".\n\nProblem description:\nComprehensive website analysis system with three specialist components for analyzing websites and producing evidence-backed business intelligence reports.\n\nSystem Requirements:\n- Input format: Single domain per run and batch supported. Batch list comes from a CSV in the repo at inputs/targets.csv.\n- Triggering: On-demand (workflow_dispatch) + optional nightly scheduled batch run.\n- Output destination: Commit outputs to the repo (JSON + README). No external storage by default.\n- Scale expectations: 200 pages max per site by default. Follow robots.txt; add basic politeness: rate cap ~1–2 req/sec and stop early on repeated errors.\n- Integration needs: Use Firecrawl for crawl/extract; GitHub for committing outputs and opening an Issue on major failures. No other integrations needed initially.\n\nThree Specialist Components:\n1. relevance-ranker-specialist: ranks pages using heuristics (path keywords like pricing/faq/terms) + lightweight semantic scoring on titles/headings/first N chars.\n2. deep-extract-specialist: deep-scrapes top K pages; extracts structured fields (offer, pricing, guarantees, process steps, FAQs, contact methods, policies, testimonials) with quoted evidence.\n3. synthesis-validator-specialist: builds final JSON pack, ensures every \"important claim\" has evidence entries (url + excerpt), and runs schema validation.\n\nCore Requirements / Constraints:\n- MUST respect robots.txt: Fetch https://{domain}/robots.txt first. If disallowed crawling is detected for relevant paths, do not crawl them; include this in run_report with the robots.txt excerpt.\n- No authentication bypass: If pages require login/paywall, mark as inaccessible; do not attempt to bypass; include the URL + reason.\n- Evidence rules: Every key claim in synthesized_findings must map to evidence_index entries with url + excerpt + extracted_at + page_title\n- De-duplication: Canonicalize URLs (strip utm params, normalize trailing slashes, lowercasing host, etc.). Cluster near-identical pages and keep the best representative. Avoid repeating header/footer boilerplate as \"content\".\n- Page inventory focus: Crawl broadly, but explicitly attempt discovery of: home, about, offers, pricing, faq, contact, policies, privacy, terms, blog.\n- Ranking priority: Top relevance categories: offers/pricing/how-it-works/policies/testimonials → then about/faq/contact → then blog/other.\n- Failure modes: If Firecrawl crawl fails or is blocked: fall back to direct HTTP inventory attempt; if still blocked, produce partial pack with clear \"inaccessible\" section. If fewer than N (default 5) pages are extracted successfully, open a GitHub Issue summarizing failure and still commit partial outputs.\n\nJSON Schema (Site Intelligence Pack):\n- site: { target_url, domain, crawled_at_iso, robots: {fetched_url, allowed_summary, disallowed_summary, raw_excerpt?} }\n- inventory: [{ url, canonical_url, title?, discovered_from?, http_status?, content_hash?, dedup_cluster_id, notes? }]\n- ranked_pages: [{ url, canonical_url, rank, reasons: [string], category: string }]\n- deep_extract_notes with pages containing extracted_entities, offers, pricing, how_it_works, faq, testimonials, policies, constraints\n- synthesized_findings with positioning, offers_and_pricing, customer_journey, trust_signals, compliance_and_policies, unknowns_and_gaps\n- evidence_index mapping evidence_id to { url, excerpt, page_title?, extracted_at_iso }\n- run_metadata with crawl statistics and errors\n\nRepo Behavior:\nWrite outputs under output_dir including inventory.json, ranked_pages.json, deep_extract.json, site_intelligence_pack.json, README.md (run_report). Commit changes on completion.\n\nFollow the PRP generation process:\n1. Read library/patterns.md and library/tool_catalog.md for reusable patterns\n2. Read config/mcp_registry.md for available MCPs\n3. Read PRPs/templates/prp_base.md for the PRP template\n4. Generate the PRP and save it to PRPs/site-intelligence-pack.md\n5. Log the confidence score and any ambiguity flags\n\nIMPORTANT: End your final commit message with exactly this line:\nCONFIDENCE_SCORE: X/10\nwhere X is the PRP's confidence score. This is used for automated pipeline decisions."}],"timestamp":1771078856159}}
{"type":"message","id":"26aeece2","parentId":"b9bb810c","timestamp":"2026-02-14T14:21:03.239Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Let me break down this job:\n\n1. I need to read the WAT factory instructions\n2. Generate a PRP for \"site-intelligence-pack\" - a comprehensive website analysis system\n3. Follow the PRP generation process which includes:\n   - Reading library/patterns.md\n   - Reading library/tool_catalog.md\n   - Reading config/mcp_registry.md\n   - Reading PRPs/templates/prp_base.md\n   - Generating the PRP\n   - Saving it to PRPs/site-intelligence-pack.md\n   - Including confidence score in commit message\n\nThe system has three specialist components:\n1. relevance-ranker-specialist\n2. deep-extract-specialist  \n3. synthesis-validator-specialist\n\nKey requirements:\n- Respect robots.txt\n- Evidence-backed findings\n- De-duplication\n- Batch and single-domain support\n- GitHub Actions triggering\n- Firecrawl integration\n- Output to repo as JSON + README\n\nLet me start by reading the necessary files.","thinkingSignature":"EooICkYICxgCKkAWPERx072EFheIK5t87fjgfCZ+6ffCIpPESNdIwe1hJZAuR8TURZGzEn2IqMWHcjeHY7vYt1g2+eCFghn2Hg4hEgzzWrvw/aYR9I1v0d8aDFkG2ad8KGxgeokp3yIwHh/+fhor+IPvKr6opdVpiGXEsp/GO56OQT9ykNE/u329ef7EHLCtPWiPNkHyIRjCKvEGAvUJWtfK+cRVtAvJJz4yPke68Blq9toJXXtDxEFKKb1inTbi3reVr8b9JmTwU9t8U09HJ27YwUnhv9YYMboynDvLB2pogiipVNznZ5ym0ixFMY7toDBPxXd99C6NtDG2vXLFEy/dZrxAedJiaNgwOQAtnA6QpEtvFrV6fRsuA6hLQJ8CIVaBMje9whuus0vbwFbzgtxbFZGfs3ke9qCRFZVgEWswhRcoF3gATDSq/tk936L/u3ruiVYuc7dtXRU9hF8lmQL/n45V0BFVxok/Cg3vpRON6fMuzrRTCUhrk8iBjcYoWbZmJM8GxYSk60Eo1owG+isBLtps3UOwBuFGtNvfGNk7EYhbrRSohafE2mkZJa7unxQoy7gHx81Ec1RbLn5aYvRE++kuK06isjVGQ9VaPViAkR04BqIIQzZ1ILy6Urlq+CsxoPErOLa2ZTpPzDvOZcSdjgfrueQDIq764R0W0EQqwJDcY8LwAXLWutAov/YOpWFDqA+0e6bm65X3eO1qEcLIkRAEqHAMB3JeaSHeHEn2+ZOp5i1w+LdBZoZxGGjs0TBGbe/FsJHXwOolkBU64igju6c88TdY5cMl5gO4iA5b2GDu215IrWdUHosNOgJbytJD95G7B0Gi0jmHPP2w+RMAlDH/pEnBF3Eee0vukVDg8HPKYNMjJHqfxqDGzabwvN7DNcearmzXLj316JADkwyb0ZHqmqsZGLl66dGrthXs0eJi1Fhbo2Qty4+FslcBxzfem5F28sZTzNq43C697PMS5fA4CcEyEjsp6KyxfAp3ovi/N3X9PxCZyBjycV5GnR0GL3H8tWGWB7uW4dy9mg5MzC+d7+0dmGPVBtdwzCLknUcU5D9BudhXHpl89EN7aWSHYpCevNnH1+Y5p+5Ub6tClPo8X6AKR1afkMdce2kARmsTyqemyxHIiL9r7KZqHCAjpw6LWZe08kDwpPYeQf7cbv34L0raKyLmlWgy7tOShiFocasa0qgYu3w7+uyJRY+Ny2d0ztOoXycBc7uOqeVyojA8rGONgE4HG2QUsDihrCCmgusOgPZMtZ2tapRsQ3s2BZByO6Y7AXvQjIRqGFRadLEFZqIcIoBHbVqEtofM3I1wW8Un3dwT6j7ByvudvhNBR4A+PdeSskzRsuMRhrCXphE+ZoLbpBfmoC4YAQ=="},{"type":"text","text":"I'll generate a comprehensive PRP for the site-intelligence-pack system. Let me start by reading the necessary reference materials."},{"type":"toolCall","id":"toolu_01De1wZXm8U5tpwEhHAP6jAQ","name":"read","arguments":{"path":"library/patterns.md"}},{"type":"toolCall","id":"toolu_01RjJcW2Beaq7zEEHtt54BRG","name":"read","arguments":{"path":"library/tool_catalog.md"}},{"type":"toolCall","id":"toolu_01VWNzuw5jazknJD7QubsoFd","name":"read","arguments":{"path":"config/mcp_registry.md"}},{"type":"toolCall","id":"toolu_01Gp5MdGF277oPD4o6LzD7Kf","name":"read","arguments":{"path":"PRPs/templates/prp_base.md"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":10,"output":448,"cacheRead":0,"cacheWrite":9713,"totalTokens":10171,"cost":{"input":0.00003,"output":0.00672,"cacheRead":0,"cacheWrite":0.03642375,"total":0.04317375}},"stopReason":"toolUse","timestamp":1771078856162}}
{"type":"message","id":"b1323b5e","parentId":"26aeece2","timestamp":"2026-02-14T14:21:03.247Z","message":{"role":"toolResult","toolCallId":"toolu_01De1wZXm8U5tpwEhHAP6jAQ","toolName":"read","content":[{"type":"text","text":"# WAT Systems Factory -- Workflow Pattern Catalog\n\n> Proven, reusable workflow patterns for building GitHub-native autonomous systems with Claude Code and MCP tools.\n\nEach pattern below is a composable building block. Patterns can be combined: a **Monitor > Detect > Alert** system might trigger an **Issue > Execute > PR** workflow, which internally uses **Fan-Out > Process > Merge** for the heavy lifting.\n\n---\n\n## 1. Scrape > Process > Output\n\n**Summary:** A web scraping pipeline that fetches raw content from one or more URLs via a web-access MCP, processes and structures the data with Python (or Claude itself), and writes clean output to a target destination.\n\n### When to Use\n\n- You need structured data extracted from websites that lack APIs.\n- You want to convert messy HTML into clean JSON, CSV, or Markdown on a recurring schedule.\n- You are building a dataset from publicly available web content.\n\n### Steps\n\n1. **Define targets** -- Specify URLs, selectors, or search queries in a config file or workflow input.\n2. **Fetch raw content** -- Use a web MCP (Fetch, Puppeteer, or Playwright) to retrieve page content. Handle pagination if needed.\n3. **Parse and extract** -- Strip irrelevant markup. Pull target fields using CSS selectors, XPath, or Claude-driven semantic extraction.\n4. **Transform** -- Normalize data types, deduplicate, validate schema. Python scripts or inline Claude processing.\n5. **Output** -- Write results to a file in the repo (`data/`, `output/`), post to an API, or commit as a structured artifact.\n\n### Key Tools / MCPs\n\n- **Fetch MCP** -- lightweight HTTP retrieval, returns Markdown-converted content.\n- **Puppeteer / Playwright MCP** -- for JavaScript-rendered pages requiring a headless browser.\n- **Python** -- pandas, BeautifulSoup, or custom scripts for heavy transformation.\n- **filesystem MCP** -- write results to disk.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 6 * * *'   # daily at 06:00 UTC\n  workflow_dispatch:        # manual trigger\n```\n\n### Example Use Cases\n\n- Scrape competitor pricing pages nightly; output a CSV diff showing changes.\n- Collect job postings from three sites; normalize into a single JSON feed committed to the repo.\n- Pull public government data tables and convert to machine-readable Parquet files.\n\n### Failure Handling\n\n- **Retry with backoff** on transient HTTP errors (429, 503).\n- **Schema validation** after extraction -- if required fields are missing, flag the record rather than silently dropping it.\n- **Stale-data guard** -- if fetch returns identical content to last run, skip processing and log \"no change.\"\n- **Alert on structural change** -- if selectors return zero matches (site redesign), open a GitHub Issue for human review.\n\n---\n\n## 2. Research > Analyze > Report\n\n**Summary:** A multi-source research workflow that gathers information from diverse sources (web, APIs, local files), synthesizes findings with Claude, and produces a formatted report committed to the repository.\n\n### When to Use\n\n- You need to compile information from multiple sources into a single coherent document.\n- Periodic market research, competitive analysis, or literature reviews.\n- Any task where a human would spend hours reading and summarizing.\n\n### Steps\n\n1. **Define research brief** -- Specify the topic, questions to answer, source priorities, and output format.\n2. **Gather sources** -- Query web search, fetch specific URLs, read local reference files, call APIs.\n3. **Extract key findings** -- For each source, pull relevant facts, quotes, data points. Tag each with provenance.\n4. **Analyze and synthesize** -- Claude cross-references findings, identifies patterns, contradictions, and gaps.\n5. **Generate report** -- Produce a structured Markdown document with sections, citations, and an executive summary.\n6. **Commit and notify** -- Commit the report to the repo. Optionally open a PR or send a notification.\n\n### Key Tools / MCPs\n\n- **Web Search MCP / Fetch MCP** -- gather online sources.\n- **filesystem MCP** -- read local reference documents.\n- **GitHub MCP** -- commit output, open issues or PRs.\n- **Claude (extended thinking)** -- deep analysis and synthesis.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 9 * * 1'   # weekly on Monday at 09:00 UTC\n  workflow_dispatch:\n    inputs:\n      topic:\n        description: 'Research topic'\n        required: true\n```\n\n### Example Use Cases\n\n- Weekly competitive landscape report that tracks new features announced by three competitors.\n- Monthly technology radar summarizing emerging tools relevant to the team's stack.\n- Ad-hoc deep-dive report triggered manually via `workflow_dispatch` with a topic input.\n\n### Failure Handling\n\n- **Source fallback** -- if a primary source is unreachable, log it and proceed with remaining sources. Note gaps in the report.\n- **Confidence scoring** -- Claude flags low-confidence claims; the report includes a \"Caveats\" section.\n- **Minimum-source threshold** -- if fewer than N sources are successfully retrieved, abort and open an issue rather than publishing a thin report.\n\n---\n\n## 3. Monitor > Detect > Alert\n\n**Summary:** A continuous monitoring system that periodically checks a target (website, API, dataset, repo) for changes, applies detection logic, and fires alerts or triggers downstream workflows when significant changes are found.\n\n### When to Use\n\n- You want to be notified when something changes: a webpage, an API response, a competitor's pricing, a regulatory filing.\n- You need a lightweight, Git-native alternative to commercial monitoring SaaS.\n- Ideal for cron-triggered GitHub Actions that run on a schedule.\n\n### Steps\n\n1. **Fetch current state** -- Retrieve the current snapshot of the monitored target.\n2. **Load previous state** -- Read the last-known state from a file committed in the repo (e.g., `state/last_snapshot.json`).\n3. **Diff** -- Compare current vs. previous. Use structural diff for JSON, text diff for prose, hash comparison for binary.\n4. **Evaluate significance** -- Apply rules or Claude-based judgment to determine if the change is meaningful (filter noise).\n5. **Alert** -- If significant: open a GitHub Issue, send a Slack message, trigger a downstream workflow via `repository_dispatch`, or all three.\n6. **Persist new state** -- Commit the current snapshot as the new baseline.\n\n### Key Tools / MCPs\n\n- **Fetch MCP / Puppeteer MCP** -- retrieve current state from web targets.\n- **filesystem MCP** -- read/write state files.\n- **GitHub MCP** -- open issues, trigger dispatches.\n- **Slack MCP** -- send alert messages.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '*/30 * * * *'  # every 30 minutes\n```\n\n### Example Use Cases\n\n- Monitor a government regulatory page for new filings; alert the legal team via Slack when a new document appears.\n- Watch a competitor's changelog page; open a GitHub Issue summarizing each detected update.\n- Track an API's response schema for breaking changes; alert the engineering team.\n\n### Failure Handling\n\n- **Transient failure tolerance** -- if the fetch fails, do NOT overwrite previous state. Log the failure. After N consecutive failures, escalate to an alert.\n- **False-positive suppression** -- use Claude to evaluate whether a detected \"change\" is meaningful (e.g., ignore timestamp-only diffs).\n- **State corruption recovery** -- if state file is missing or unparseable, re-initialize from scratch and log a warning instead of crashing.\n\n---\n\n## 4. Intake > Enrich > Deliver\n\n**Summary:** A data enrichment pipeline that receives raw input (from a form, webhook, file drop, or API), augments it with additional data from external sources, and delivers the enriched result to its destination.\n\n### When to Use\n\n- Incoming data is incomplete and needs augmentation before it is useful.\n- You are building a lead enrichment, content tagging, or metadata enhancement system.\n- Raw data arrives in one format and must be transformed and enriched before storage or delivery.\n\n### Steps\n\n1. **Intake** -- Receive raw data. Sources: webhook payload, new file in repo, manual trigger with JSON input, or a watched directory.\n2. **Validate** -- Check that required fields exist and data types are correct. Reject malformed input early.\n3. **Enrich** -- For each record, call enrichment sources: web search for context, APIs for supplementary data, Claude for classification or summarization.\n4. **Merge** -- Combine original data with enrichment results into a unified schema.\n5. **Deliver** -- Write enriched data to its destination: commit to repo, POST to API, append to a dataset file, or open a PR.\n\n### Key Tools / MCPs\n\n- **Web Search MCP** -- find supplementary information.\n- **Fetch MCP** -- call enrichment APIs.\n- **Claude** -- classify, tag, summarize, or score records.\n- **filesystem MCP** -- read input, write output.\n- **GitHub MCP** -- commit results or open PRs.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  push:\n    paths:\n      - 'inbox/**'          # new file dropped in inbox\n  workflow_dispatch:\n    inputs:\n      payload:\n        description: 'JSON data to enrich'\n        required: true\n```\n\n### Example Use Cases\n\n- A sales team drops a CSV of company names into `inbox/`; the pipeline enriches each with industry, size, website, and LinkedIn URL, then writes to `data/enriched_leads.csv`.\n- Incoming support tickets are enriched with customer history and sentiment score before routing.\n- Raw RSS feed items are enriched with summaries, topic tags, and relevance scores.\n\n### Failure Handling\n\n- **Per-record error isolation** -- if enrichment fails for one record, mark it as `enrichment_failed` and continue processing the rest. Do not let one bad record kill the batch.\n- **Rate-limit awareness** -- track API call counts; pause and retry when rate-limited rather than failing fast.\n- **Partial delivery** -- deliver successfully enriched records on schedule; queue failed records for retry in the next run.\n\n---\n\n## 5. Generate > Review > Publish\n\n**Summary:** A content generation pipeline with built-in quality gates. Claude generates draft content, a review step validates quality and compliance, and approved content is published to its destination.\n\n### When to Use\n\n- Automated content creation (blog posts, documentation, social media, release notes) where quality must be verified before publishing.\n- Any workflow where you want a \"human-in-the-loop\" approval step or an automated quality check before output goes live.\n\n### Steps\n\n1. **Brief** -- Define the content requirements: topic, audience, tone, length, format, and any reference material.\n2. **Generate** -- Claude produces a first draft using the brief and any provided reference material.\n3. **Automated review** -- Run quality checks: spelling/grammar, factual consistency against source material, tone analysis, compliance rules (e.g., no prohibited claims).\n4. **Gate decision** -- If automated review passes, proceed. If it fails, loop back to step 2 with feedback (max N retries). Optionally, require human approval via a PR review.\n5. **Publish** -- Commit final content to the repo, deploy to a CMS via API, or post to a platform.\n\n### Key Tools / MCPs\n\n- **Claude** -- generation and review (use separate system prompts for generator vs. reviewer to create genuine separation).\n- **filesystem MCP** -- read briefs, write drafts and final output.\n- **GitHub MCP** -- open a draft PR for human review; merge on approval.\n- **Fetch MCP** -- publish to external CMS or platform APIs.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [labeled]        # label \"content-request\" triggers generation\n  pull_request_review:\n    types: [submitted]      # human approval triggers publish\n  workflow_dispatch:\n```\n\n### Example Use Cases\n\n- Weekly changelog: gather merged PRs, generate a formatted changelog, open a PR for team review, publish on approval.\n- Blog post pipeline: issue labeled \"draft-request\" triggers generation; editor reviews the PR; merge triggers deployment.\n- Social media batch: generate a week's worth of posts, run brand-voice review, output approved posts to a scheduling queue.\n\n### Failure Handling\n\n- **Retry budget** -- if automated review rejects the draft, regenerate with targeted feedback up to 3 times. After that, escalate to a human by opening an issue.\n- **Rollback on publish failure** -- if the publish step fails (API error), keep the approved content in the repo and log the failure for manual retry.\n- **Diff guard** -- before publishing, diff against previously published content to prevent accidental overwrite of manual edits.\n\n---\n\n## 6. Listen > Decide > Act\n\n**Summary:** An event-driven agent that listens for incoming events (webhooks, GitHub events, messages), applies decision logic to determine the appropriate response, and takes autonomous action.\n\n### When to Use\n\n- You need a system that reacts to external events in near-real-time.\n- Webhook-triggered GitHub Actions are the execution engine.\n- The appropriate response depends on the content of the event (routing, triage, conditional logic).\n\n### Steps\n\n1. **Receive event** -- GitHub Actions triggers on the event (webhook, issue creation, PR comment, `repository_dispatch`).\n2. **Parse and classify** -- Extract relevant data from the event payload. Use Claude to classify intent or severity if the input is unstructured (e.g., natural language).\n3. **Decide** -- Apply decision logic: rule-based routing, Claude-driven triage, or a lookup table. Determine which action(s) to take.\n4. **Act** -- Execute the chosen action: respond to the issue, trigger another workflow, call an API, update a file, or escalate to a human.\n5. **Log** -- Record the event, decision, and action taken for auditability.\n\n### Key Tools / MCPs\n\n- **GitHub MCP** -- read event payloads, respond to issues/PRs, trigger dispatches.\n- **Claude** -- classify, triage, and decide.\n- **Slack MCP** -- notify humans when escalation is needed.\n- **Fetch MCP** -- call external APIs as part of the action.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [opened, labeled]\n  issue_comment:\n    types: [created]\n  repository_dispatch:\n    types: [incoming_webhook]\n```\n\n### Example Use Cases\n\n- Triage bot: new issues are classified by Claude (bug, feature, question) and auto-labeled, assigned, and replied to with relevant templates.\n- Deployment gatekeeper: a PR comment like \"/deploy staging\" triggers a deployment workflow after validating the commenter's permissions.\n- Customer feedback router: webhook delivers feedback; Claude scores sentiment and routes critical items to Slack.\n\n### Failure Handling\n\n- **Idempotency** -- design actions to be safe to retry. Use event IDs to detect and skip duplicate deliveries.\n- **Decision logging** -- log the full decision chain (event > classification > decision > action) so failures can be diagnosed.\n- **Safe defaults** -- if classification confidence is low, default to escalation (notify a human) rather than taking an autonomous action that might be wrong.\n\n---\n\n## 7. Collect > Transform > Store\n\n**Summary:** A classic ETL (Extract, Transform, Load) pipeline where Git serves as the data store. Data is collected from external sources, transformed into a canonical format, and committed to the repository as versioned, queryable files.\n\n### When to Use\n\n- You want a version-controlled data lake without standing up a database.\n- Small-to-medium datasets (tens of MB) that benefit from Git's diff, history, and branching.\n- Data pipelines where auditability and reproducibility matter more than query speed.\n\n### Steps\n\n1. **Collect** -- Pull data from source(s): APIs, web scrapes, file uploads, other repos.\n2. **Validate** -- Check data integrity: schema validation, null checks, type enforcement.\n3. **Transform** -- Normalize, clean, reshape. Convert to the canonical schema. Deduplicate against existing data in the store.\n4. **Diff** -- Compare transformed data against the current version in the repo. Compute what is new, changed, or deleted.\n5. **Store** -- Commit the updated dataset files to the repo. Use meaningful commit messages describing what changed (e.g., \"Add 14 new records from source X\").\n\n### Key Tools / MCPs\n\n- **Fetch MCP** -- pull data from APIs and web sources.\n- **Python** -- pandas or custom scripts for transformation.\n- **filesystem MCP** -- read/write data files.\n- **GitHub MCP / Git CLI** -- commit, push, branch as needed.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 */6 * * *'  # every 6 hours\n  workflow_dispatch:\n```\n\n### Example Use Cases\n\n- Collect cryptocurrency prices from three APIs every 6 hours; store as daily CSV files in `data/prices/`.\n- Pull open government datasets weekly; transform into a normalized schema; maintain a living dataset in the repo.\n- Aggregate internal metrics from multiple microservice health endpoints; store as JSON for a dashboard.\n\n### Failure Handling\n\n- **Atomic commits** -- only commit if the entire pipeline succeeds. Never commit partial or corrupted data.\n- **Schema drift detection** -- if source data no longer matches the expected schema, abort and alert rather than storing malformed data.\n- **Rollback via Git** -- if bad data is committed, revert the commit. The previous state is always recoverable.\n- **Dedup safety** -- idempotent writes ensure that re-running the pipeline does not create duplicate records.\n\n---\n\n## 8. Fan-Out > Process > Merge\n\n**Summary:** The Agent Teams pattern. A coordinator agent splits a large task into independent sub-tasks, dispatches them to parallel sub-agents (or sequential iterations), collects all results, and merges them into a unified output.\n\n### When to Use\n\n- A task is naturally decomposable into independent units of work (e.g., process each file, research each topic, analyze each competitor).\n- You want to reduce wall-clock time by parallelizing work.\n- The final deliverable requires combining results from multiple sub-tasks.\n\n### Steps\n\n1. **Plan** -- The coordinator analyzes the task and determines how to decompose it. Produces a work manifest: a list of sub-tasks with their inputs.\n2. **Fan-Out** -- Dispatch each sub-task. Options: parallel GitHub Actions jobs via a matrix strategy, sequential Claude tool calls, or `repository_dispatch` events to separate workflows.\n3. **Process** -- Each sub-agent executes its sub-task independently. Results are written to a known location (e.g., `temp/results/task_01.json`).\n4. **Collect** -- The coordinator waits for all sub-tasks to complete and gathers their outputs.\n5. **Merge** -- Combine results: concatenate, deduplicate, reconcile conflicts, and produce the final unified output.\n6. **Deliver** -- Commit the merged output or pass it to the next stage in a larger pipeline.\n\n### Key Tools / MCPs\n\n- **Claude** -- coordinator logic, sub-task execution, merge logic.\n- **GitHub Actions matrix** -- parallel job execution.\n- **filesystem MCP** -- read/write intermediate and final results.\n- **GitHub MCP** -- coordinate via issues, artifacts, or dispatch events.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      task_manifest:\n        description: 'JSON array of sub-tasks'\n        required: true\n  repository_dispatch:\n    types: [fan_out_request]\n```\n\n### Example Use Cases\n\n- Analyze 20 competitor websites: fan out one sub-agent per competitor, each produces a profile, merge into a single competitive analysis report.\n- Process a batch of 50 documents: each sub-agent summarizes one document, merge into a master summary with cross-references.\n- Multi-language translation: fan out one sub-agent per target language, merge all translations into a localized content bundle.\n\n### Failure Handling\n\n- **Partial success tolerance** -- if some sub-tasks fail, merge the successful results and report failures. Do not discard all work because of one failure.\n- **Retry failed sub-tasks** -- the coordinator can re-dispatch failed sub-tasks up to N times before giving up.\n- **Timeout enforcement** -- set a maximum wall-clock time for the fan-out phase. Collect whatever is done when the timer expires.\n- **Conflict resolution** -- if sub-task results conflict, the merge step uses Claude to reconcile or flags the conflict for human review.\n\n---\n\n## 9. Issue > Execute > PR\n\n**Summary:** The GitHub Agent HQ pattern. An agent receives a task specification via a GitHub Issue, autonomously executes the required workflow, and delivers the results as a draft Pull Request for human review.\n\n### When to Use\n\n- You want a human-in-the-loop task queue where work is requested via Issues and delivered via PRs.\n- The agent should be fully autonomous in execution but the output requires human approval before merging.\n- Building an internal tool where non-technical stakeholders can request work by opening an Issue.\n\n### Steps\n\n1. **Receive** -- A new Issue is opened (or an existing Issue is labeled with a trigger label like `agent-task`). GitHub Actions fires.\n2. **Parse task** -- Claude reads the Issue body and extracts the task specification: what to do, inputs, constraints, expected output.\n3. **Create branch** -- Create a feature branch named after the Issue (e.g., `agent/issue-42`).\n4. **Execute** -- Run the appropriate workflow or pattern to complete the task. This might invoke any other pattern in this catalog.\n5. **Commit results** -- Commit all output files to the feature branch with clear commit messages.\n6. **Open draft PR** -- Open a draft PR linked to the original Issue. The PR body includes a summary of what was done, key decisions made, and anything that needs human attention.\n7. **Comment on Issue** -- Post a comment on the Issue linking to the PR and summarizing the outcome.\n\n### Key Tools / MCPs\n\n- **GitHub MCP** -- read issues, create branches, commit, open PRs, post comments.\n- **Claude** -- parse task, execute logic, generate summaries.\n- **Any other MCP** -- depending on the task being executed.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [opened, labeled]\n  issue_comment:\n    types: [created]       # support \"/execute\" command in comments\n```\n\n### Example Use Cases\n\n- A product manager opens an Issue: \"Research top 5 CRM tools and compare features.\" The agent researches, builds a comparison table, and opens a PR with the report.\n- An engineer opens an Issue: \"Add unit tests for the auth module.\" The agent generates tests and delivers them as a PR.\n- A stakeholder opens an Issue: \"Update the pricing page data for Q1.\" The agent pulls new data, updates the files, and opens a PR for review.\n\n### Failure Handling\n\n- **Status updates** -- the agent comments on the Issue at each major step (\"Starting research...\", \"Generating report...\", \"Opening PR...\") so progress is visible.\n- **Graceful failure** -- if the agent cannot complete the task, it comments on the Issue with a clear explanation of what went wrong and what it tried, then labels the Issue `agent-failed` for human triage.\n- **Scope guard** -- if Claude determines the task is ambiguous or out of scope, it asks a clarifying question in the Issue comments rather than guessing.\n- **Draft-only PRs** -- all PRs are opened as drafts. The agent never merges its own work.\n\n---\n\n## 10. n8n Import > Translate > Deploy\n\n**Summary:** A conversion pattern that ingests an n8n workflow JSON export, translates it into a WAT-native system (Claude Code + MCP + GitHub Actions), and deploys it as a fully functional GitHub-native workflow.\n\n### When to Use\n\n- You are migrating from n8n (or a similar visual workflow tool) to a GitHub-native architecture.\n- You want to leverage existing workflow logic without manually rewriting it.\n- You are evaluating whether an n8n workflow can run as a WAT system to reduce infrastructure dependencies.\n\n### Steps\n\n1. **Import** -- Read the n8n workflow JSON file. This contains nodes, connections, credentials references, and configuration.\n2. **Parse and map** -- Walk the node graph. For each n8n node type, identify the equivalent WAT component:\n   - HTTP Request node -> Fetch MCP call\n   - Code (JavaScript/Python) node -> inline script or Python file\n   - IF/Switch node -> Claude decision logic or conditional in workflow\n   - Webhook trigger -> `repository_dispatch` or `workflow_dispatch`\n   - Cron trigger -> `schedule` trigger in GitHub Actions\n   - Set/Merge nodes -> data transformation in Claude or Python\n3. **Translate** -- Generate the WAT system files:\n   - `.github/workflows/*.yml` -- GitHub Actions workflow definition.\n   - `prompts/` -- Claude system prompts for nodes that require AI logic.\n   - `scripts/` -- Python or shell scripts for code nodes.\n   - `config/` -- Configuration extracted from the n8n workflow.\n4. **Validate** -- Dry-run the generated workflow. Check that all node types were mapped, no credentials are hardcoded, and the control flow is correct.\n5. **Deploy** -- Commit the generated files to the repo. Open a PR with a detailed summary of the translation, noting any nodes that required manual review or could not be auto-translated.\n\n### Key Tools / MCPs\n\n- **filesystem MCP** -- read n8n JSON, write generated files.\n- **Claude** -- interpret node logic, generate prompts, translate code, produce workflow YAML.\n- **GitHub MCP** -- commit files, open PR.\n- **Python** -- parse n8n JSON, generate boilerplate.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  push:\n    paths:\n      - 'imports/n8n/*.json'   # drop an n8n export to trigger conversion\n  workflow_dispatch:\n    inputs:\n      n8n_file:\n        description: 'Path to n8n JSON file in the repo'\n        required: true\n```\n\n### Example Use Cases\n\n- Migrate a 15-node n8n lead-scoring workflow to a Git-versioned, GitHub Actions-powered system.\n- Convert an n8n social media posting pipeline into a WAT **Generate > Review > Publish** system.\n- Translate an n8n monitoring workflow into a WAT **Monitor > Detect > Alert** pattern, eliminating the need for a running n8n instance.\n\n### Failure Handling\n\n- **Unsupported node catalog** -- maintain a list of n8n node types that cannot be auto-translated. When encountered, flag them in the PR description with a `TODO` and a suggested manual implementation.\n- **Credential safety** -- never translate credentials. Replace all credential references with GitHub Secrets placeholders (`${{ secrets.SERVICE_API_KEY }}`) and document which secrets need to be configured.\n- **Fidelity check** -- generate a side-by-side comparison of the n8n flow and the translated WAT flow so a human reviewer can verify correctness.\n- **Incremental migration** -- support translating a subset of the n8n workflow, allowing teams to migrate node-by-node rather than all-at-once.\n\n---\n\n## Pattern Composition Quick Reference\n\nPatterns are building blocks. Here are common compositions:\n\n| Composition | How It Works |\n|---|---|\n| **Monitor > Detect > Alert** + **Issue > Execute > PR** | Monitor detects a change, opens an Issue, which triggers the agent to act and deliver a PR. |\n| **Issue > Execute > PR** using **Fan-Out > Process > Merge** | A complex Issue task is decomposed and parallelized internally before the PR is opened. |\n| **Scrape > Process > Output** feeding **Collect > Transform > Store** | Scraping output is piped into the ETL pattern for versioned storage. |\n| **Listen > Decide > Act** routing to any pattern | An event-driven dispatcher that selects and triggers the appropriate pattern based on the event. |\n| **n8n Import > Translate > Deploy** producing any pattern | The translator identifies which WAT pattern best fits the n8n workflow and generates accordingly. |\n\n---\n\n## Choosing a Pattern\n\n| Question | Recommended Pattern |\n|---|---|\n| Do I need to pull data from websites? | **Scrape > Process > Output** |\n| Do I need to synthesize information from many sources? | **Research > Analyze > Report** |\n| Do I need to watch for changes over time? | **Monitor > Detect > Alert** |\n| Do I need to augment incoming data? | **Intake > Enrich > Deliver** |\n| Do I need AI-generated content with quality control? | **Generate > Review > Publish** |\n| Do I need to react to external events? | **Listen > Decide > Act** |\n| Do I need versioned data storage without a database? | **Collect > Transform > Store** |\n| Do I need to parallelize a large task? | **Fan-Out > Process > Merge** |\n| Do I need a task queue with human approval? | **Issue > Execute > PR** |\n| Do I need to migrate an n8n workflow? | **n8n Import > Translate > Deploy** |\n| Do I need B2B lead generation from web data? | **Intake > Enrich > Deliver** (lead-gen variant) |\n\n---\n\n## Proven Compositions (from builds)\n\n### Lead Generation Pipeline (lead-gen-machine)\n- **Pattern**: Intake > Enrich > Deliver + Scrape > Process > Output\n- **Flow**: Parse profile > Search web > Scrape sites > Extract contacts (Claude) > Score leads > Output CSV\n- **Key insight**: The Intake > Enrich > Deliver pattern works well when the \"enrichment\" involves multi-step web scraping + AI extraction. Each company is an independent unit of work, making this a strong candidate for Fan-Out > Process > Merge parallelization.\n- **Scoring pattern**: Decompose match criteria into independent dimensions (industry, size, location, keywords) with weighted point values. This makes the scoring transparent and tunable.\n- **Fallback chains**: Firecrawl > HTTP+BeautifulSoup for scraping, Claude > regex for extraction. Always have a degraded-but-functional fallback.\n\n### Marketing Pipeline (marketing-pipeline)\n- **Pattern**: Intake > Enrich > Deliver + Generate > Review > Publish\n- **Flow**: Ingest CSV > Enrich via Apollo/Hunter/Brave/Claude > Deep-score (5 dimensions) > Segment (Hot/Warm/Cold) > Generate outreach (Hot) > Generate nurture (Warm) > Output CSVs + emails\n- **Key insight**: Multi-API enrichment with graceful degradation. Apollo (primary) > Hunter (email verification) > Brave (research) > Claude (pain analysis). Each API layer adds value but the system works with only Anthropic API.\n- **Scoring pattern**: 5-dimension scoring (size fit, tech stack compatibility, budget signals, accessibility, pain signals) with transparent point breakdown. More dimensions = more nuanced than lead-gen-machine's 4-dimension approach.\n- **Content generation pattern**: Outreach and nurture are independent post-segmentation, making them natural Agent Teams candidates. Outreach is per-lead personalized; nurture is aggregate-informed.\n- **API fallback chain**: Apollo > Hunter > Brave > Claude > HTTP scraping. Four-level fallback with clear degradation at each level.\n- **CSV-in/CSV-out**: Accepts CSV input (compatible with lead-gen-machine output), produces segmented CSVs + markdown email sequences. Easy to chain systems.\n\n### Website Uptime Monitor (website-uptime-monitor)\n- **Pattern**: Monitor > Log (simplified from Monitor > Detect > Alert)\n- **Flow**: Check URL via HTTP GET > Measure response time > Determine up/down status > Append to CSV > Commit to Git\n- **Key insight**: Simplest possible monitoring system - no detection logic, no alerting, just raw data collection. Every check produces a log entry regardless of status. Git history IS the audit trail.\n- **No MCPs needed**: Direct Python `requests` library is simpler and more reliable than Fetch MCP for a single GET request. CSV append uses stdlib. Zero external dependencies beyond GitHub Actions.\n- **Exit code signaling**: Tool exits 0 if up, 1 if down - GitHub Actions UI shows workflow as \"failed\" when site is down, providing at-a-glance status without additional alerting logic.\n- **Concurrency handling**: GitHub Actions `concurrency` setting prevents simultaneous runs. Git push includes retry with rebase to handle rare concurrent commits.\n- **CSV as database**: Append-only CSV committed to Git provides versioned, auditable, queryable dataset. No external database needed. Git handles MB-scale data easily.\n- **Cron variance accepted**: GitHub Actions cron has ±5 minute variance - documented as expected behavior rather than a bug to fix.\n- **Three execution paths**: (1) Scheduled cron (primary), (2) Manual dispatch (testing), (3) Local CLI (development). Agent HQ (4) optional for issue-driven tasks.\n- **Cost awareness**: ~1,440 GitHub Actions minutes/month for 5-minute checks. Fits within free tier (2,000/month private, unlimited public).\n- **Extensibility points**: Add alerting by extending monitor.yml (Slack webhook, GitHub Issue). Add multiple URLs via matrix strategy or separate workflows. Add authentication via tool arguments + GitHub Secrets.\n\n### CSV-to-JSON Converter (csv-to-json-converter)\n- **Pattern**: Collect > Transform > Store\n- **Flow**: Collect CSV files > Analyze structure > Parse CSV > Infer types > Validate data > Convert to JSON/JSONL > Generate reports > Commit\n- **Key insight**: Multi-phase transformation with specialist subagents. Each phase (analyze, infer, validate, write) has a dedicated subagent with focused responsibilities. Main agent orchestrates the pipeline.\n- **Subagent architecture**: Four specialist subagents (csv-analyzer, type-inference-specialist, data-validator, json-writer) with minimal tool access. Subagents are the DEFAULT delegation mechanism, not Agent Teams.\n- **Type inference pattern**: Statistical analysis with confidence scoring (80% threshold). Detects int, float, boolean, datetime, string. Falls back to string for ambiguous columns. Handles 10+ null value representations.\n- **Encoding detection**: chardet for automatic encoding detection with UTF-8 fallback. Strips BOM (byte order mark) automatically. Supports UTF-8, Latin-1, Windows-1252, etc.\n- **Ragged row handling**: Pad short rows with null, truncate long rows with warning. Log all issues in validation report but continue processing (graceful degradation).\n- **Validation without failure**: Validator NEVER raises exceptions. Always returns a report. Strict mode controls whether issues halt the pipeline, but validation itself is fail-safe.\n- **JSONL streaming**: For large files (1M+ rows), JSONL format writes one record at a time. No array wrapper. Memory-efficient for multi-GB datasets.\n- **Batch processing modes**: Sequential (1-2 files) or parallel (3+ files with Agent Teams). Parallel is 5x faster wall time but same token cost. Always has sequential fallback.\n- **Three execution paths**: (1) CLI for local development, (2) GitHub Actions for production, (3) Agent HQ for issue-driven tasks. All three produce identical output.\n- **Metadata reporting**: run_summary.json (machine-readable) + validation_report.md (human-readable). Includes per-file stats, type inference results, validation issues, recommendations.\n- **No secrets required**: Uses only stdlib (csv, json, pathlib) + chardet + python-dateutil. No external APIs. Pure data transformation pipeline.\n- **Git commit discipline**: Stage ONLY output files (never `git add -A`). Commit message includes file count, row count, timestamp. Output directory is parameterized.\n\n### RSS Digest Monitor (rss-digest-monitor)\n- **Pattern**: Monitor > Collect > Transform > Deliver (with state persistence)\n- **Flow**: Load state > Fetch RSS feeds > Filter new posts > Generate HTML digest > Send email > Update state > Commit\n- **Key insight**: State persistence in Git prevents post duplication across runs. Composite GUID keys (feed_url::guid) prevent false deduplication. State is ONLY updated after successful email delivery, ensuring retry on failure.\n- **Subagent architecture**: Three specialist subagents (rss-fetcher-specialist, digest-generator-specialist, state-manager-specialist). Subagents are the DEFAULT delegation mechanism. Sequential execution is correct due to clear data dependencies.\n- **Per-feed error isolation**: One failed feed does NOT kill the entire run. Each feed is fetched independently with try/except. Failed feeds are logged and skipped. Graceful degradation ensures partial success.\n- **Composite GUID pattern**: Use `feed_url::entry_guid` as deduplication key instead of guid alone. Prevents false positives when different feeds use the same GUID format.\n- **State file size management**: Enforce maximum 10,000 GUIDs by keeping most recent entries. Prevents unbounded state growth. Log warning if limit is hit.\n- **Email with fallback**: MIME multipart with HTML primary and plain-text fallback. Ensures compatibility with all email clients. HTML is styled with inline CSS for maximum rendering support.\n- **Conditional email send**: Skip email generation if no new posts found. Silent run with state update only. Saves API calls and prevents empty emails.\n- **SMTP retry logic**: Retry once with 30s delay on transient failures (auth, network, timeout). Do NOT update state if email send fails -- posts retry on next run.\n- **First-run initialization**: Missing or corrupted state file initializes empty state. All posts are processed on first run. Log warning but continue (better to duplicate once than crash).\n- **Date parsing with fallback**: Use python-dateutil for robust parsing of varied date formats. If unparseable, use current timestamp. Include post anyway (better to duplicate than miss).\n- **Three execution paths**: (1) Scheduled cron at 8 AM UTC (primary), (2) Manual dispatch with force_send (testing), (3) Local CLI (development). All produce identical output.\n- **Run summary logging**: Each run produces `logs/YYYY-MM-DD_run.json` with feeds_checked, feeds_failed, new_posts, email_sent, failed_feeds array. Machine-readable audit trail.\n- **Git commit discipline**: Stage ONLY state/rss_state.json and logs/*.json. NEVER `git add -A`. Commit message includes date and post count for easy history review.\n- **No MCP dependencies**: Uses standard Python libraries (feedparser, smtplib, json, pathlib). Works out-of-the-box with only Python and requirements.txt. No external MCPs required.\n- **Cost awareness**: ~3-5 minutes per day = ~90-150 GitHub Actions minutes/month. Well within free tier (2,000/month private, unlimited public). Minimal token cost for state management only.\n\n## 11. Content Transformation with Tone Matching\n\n**Summary:** An AI-powered content repurposing pipeline that extracts content from a source URL, analyzes its tone and style, and generates platform-optimized variants (social media, email, etc.) that match the source tone automatically.\n\n### When to Use\n\n- You need to publish the same content across multiple platforms with different format requirements\n- Content must maintain consistent voice/tone across all platforms\n- Manual reformatting for each platform is time-consuming and error-prone\n- You want AI to handle platform-specific best practices (character limits, hashtags, formatting)\n\n### Steps\n\n1. **Fetch source content** -- Scrape the source URL (blog post, article) and extract clean text/markdown. Use Firecrawl with HTTP fallback for reliability.\n2. **Analyze tone** -- Use LLM (Claude) with structured output to analyze writing style across multiple dimensions: formality, technical level, humor, primary emotion. Return confidence score.\n3. **Generate platform variants (parallel)** -- For each target platform (Twitter, LinkedIn, email, Instagram):\n   - Send source content + tone analysis to LLM\n   - Request platform-optimized output matching source tone\n   - Enforce platform-specific constraints (char limits, hashtag counts, formatting rules)\n   - Validate character counts before accepting output\n4. **Merge and output** -- Combine all variants into single JSON file with metadata, tone analysis, and all platform content\n\n### Key Tools / MCPs\n\n- **Firecrawl MCP** -- reliable web scraping with JS rendering support\n- **Anthropic MCP** -- Claude for tone analysis and content generation\n- **HTTP + BeautifulSoup** -- fallback scraping if Firecrawl unavailable\n- **Python stdlib** -- JSON manipulation, filename slugification, output assembly\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      blog_url:\n        description: 'Blog post URL to repurpose'\n        required: true\n  # Can also be triggered on new blog post detection via RSS or webhook\n```\n\n### Example Use Cases\n\n- Marketing team publishes a blog post, wants Twitter thread, LinkedIn post, email newsletter section, and Instagram caption\n- Content creator wants to maximize reach by publishing same content on all major platforms\n- Agency needs to repurpose client blog posts for multi-channel campaigns\n- Developer advocates want to turn technical blog posts into social-friendly content\n\n### Subagent Architecture\n\n- **content-scraper-specialist** -- Handles web scraping with fallback strategies\n- **tone-analyzer-specialist** -- Analyzes source content tone/style\n- **content-generator-specialist** -- Coordinates multi-platform generation (can use Agent Teams for parallelization)\n- **output-assembler-specialist** -- Merges all content into final JSON\n\n### Agent Teams Parallelization\n\nPlatform generation is ideal for Agent Teams:\n- 4 independent platform generation tasks (Twitter, LinkedIn, email, Instagram)\n- Each takes 10-15 seconds sequentially = 40-55s total\n- Parallel execution with 4 teammates = 12-18s\n- **2x speedup** with identical results and same token cost\n\n### Platform-Specific Constraints\n\n| Platform | Char Limit | Hashtags | Format Notes |\n|----------|------------|----------|--------------|\n| Twitter | 280 per tweet | 2-3 per thread | Numbered thread (1/N format), hook in first tweet, CTA in last |\n| LinkedIn | 3000 max, 1300 target | 3-5 | Professional tone, hook before \"see more\" fold, line breaks |\n| Email | 500-800 words | N/A | Subject line (40-60 chars), scannable format, HTML + plain text |\n| Instagram | 2200 max | 10-15 | Casual tone, emojis (3-5), line breaks, hook before \"more\" button |\n\n### Tone Matching Pattern\n\n1. LLM analyzes source content with structured JSON schema\n2. Returns tone profile: {formality, technical_level, humor_level, primary_emotion, confidence}\n3. Platform generators receive tone profile in their prompts\n4. Each generator adjusts output style to match source tone (formal → formal, casual → casual)\n5. Result: All platforms sound like they were written by the same person\n\n### Failure Handling\n\n- **Scraping failure** -- Halt workflow immediately (no content = can't proceed). Log clear error about paywall/404/timeout.\n- **Tone analysis failure** -- Return default neutral profile, continue with warning. Quality slightly reduced but system remains functional.\n- **Single platform failure** -- Continue with other platforms. Include error structure for failed platform in output. Partial success is acceptable.\n- **Character limit exceeded** -- Tools automatically truncate with \"...\" and log warning. Better than crashing.\n\n### Performance & Cost\n\n**Execution time**:\n- Sequential: ~52-74 seconds\n- With Agent Teams: ~25-37 seconds (2x faster)\n\n**API cost per run** (Claude Sonnet 4):\n- Scraping: $0.01-0.02 (Firecrawl)\n- LLM calls: ~$0.09 (tone + 4 platforms)\n- **Total: ~$0.10-0.11 per blog post**\n\n### Success Criteria\n\n✅ Source content extracted (≥ 100 chars)\n✅ Tone analysis returns confidence ≥ 0.5\n✅ At least 2/4 platforms generate successfully\n✅ All character counts within platform limits\n✅ Output JSON file written to repo\n\n### Key Learnings\n\n- **Tone matching is powerful** -- AI can accurately replicate writing style when given structured tone analysis\n- **Parallel generation scales well** -- 4 independent LLM calls are perfect for Agent Teams\n- **Character validation is critical** -- Must validate before returning, not after\n- **Partial success is acceptable** -- 3/4 platforms working is better than all-or-nothing\n- **Firecrawl + fallback pattern works** -- Primary API with HTTP backup maximizes reliability\n- **Subagent specialization reduces complexity** -- Each subagent has clear, scoped responsibility\n\n### Related Patterns\n\nCombines elements of:\n- **Scrape > Process > Output** (content extraction)\n- **Fan-Out > Process > Merge** (parallel platform generation via Agent Teams)\n- **Generate > Review > Publish** (content creation with validation)\n\n## 12. Sequential State Management Pipeline\n\n**Summary:** A data transformation pipeline that maintains persistent state across runs using atomic file operations. Each execution reads current state, transforms data, generates output, updates state, and commits results -- all while preventing race conditions.\n\n### When to Use\n\n- You need sequential numbering or versioning that persists across workflow runs\n- Output depends on previous runs (counters, IDs, sequence numbers)\n- Concurrent execution must not create duplicates\n- State must survive container/server restarts\n- Git-native state storage is preferred over external databases\n\n### Steps\n\n1. **Read State** -- Load previous state from committed file\n2. **Lock State** -- Acquire file lock to prevent concurrent modifications\n3. **Transform Data** -- Process input using current state\n4. **Update State** -- Increment counter, add ID, update version\n5. **Generate Output** -- Produce artifacts using updated state\n6. **Commit State** -- Write state file and outputs to repo\n7. **Release Lock** -- Allow next execution to proceed\n\n### Key Tools / MCPs\n\n- **filelock** (Python) -- Atomic file locking with timeout\n- **Git** -- State file versioning and recovery\n- **filesystem MCP** -- Read/write state files\n- **JSON** (stdlib) -- State serialization\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      data:\n        description: 'Input data to process'\n        required: true\n  push:\n    paths:\n      - 'input/**'\n```\n\n### Example Use Cases\n\n- Invoice generator with sequential invoice numbers (INV-1001, INV-1002...)\n- Document versioning system (v1.0, v1.1, v2.0...)\n- Sequential ID assignment for records\n- Incrementing batch job numbers\n- Auto-incrementing PR numbers in custom systems\n\n### State File Format\n\n```json\n{\n  \"last_value\": 1042,\n  \"prefix\": \"INV-\",\n  \"padding\": 4,\n  \"metadata\": {\n    \"last_updated\": \"2026-02-11T14:30:00Z\",\n    \"total_count\": 1042\n  }\n}\n```\n\n### Atomic Operations Pattern\n\n```python\nfrom filelock import FileLock, Timeout\n\nlock_path = f\"{state_file}.lock\"\ntry:\n    with FileLock(lock_path, timeout=5):\n        # Read current state\n        state = json.loads(Path(state_file).read_text())\n        \n        # Modify state\n        state[\"last_value\"] += 1\n        \n        # Write updated state\n        Path(state_file).write_text(json.dumps(state, indent=2))\n        \n        # Return new value\n        return state[\"last_value\"]\nexcept Timeout:\n    # Fallback: use timestamp or other unique value\n    return generate_fallback_value()\n```\n\n### Failure Handling\n\n**Lock timeout (5 seconds)**\n- **Cause**: Concurrent execution or filesystem issue\n- **Action**: Use fallback mechanism (timestamp, UUID, or queue for retry)\n- **Log**: Warning with details for investigation\n- **Continue**: Workflow proceeds with fallback value\n\n**State file missing**\n- **Cause**: First run or file deleted\n- **Action**: Initialize to default starting value\n- **Log**: Info message about initialization\n- **Continue**: Normal operation from initial state\n\n**State file corrupted**\n- **Cause**: Incomplete write, manual edit, merge conflict\n- **Action**: Restore from Git history or reinitialize\n- **Log**: Error with corrupted content\n- **Halt**: Require manual intervention (prevents data loss)\n\n**Concurrent modifications**\n- **Prevented by**: File locking ensures only one process modifies at a time\n- **If lock fails**: Fallback prevents workflow failure\n- **Trade-off**: Fallback may break sequential ordering but ensures system continues\n\n### Git-Native State Management\n\nState files are committed to the repository:\n\n**Benefits:**\n- Version history (full audit trail)\n- Rollback capability (`git checkout HEAD~5 state.json`)\n- Merge conflict detection\n- No external database needed\n- Free hosting on GitHub\n\n**Considerations:**\n- Not suitable for high-frequency updates (>100/min)\n- Commit overhead (~1-2 seconds per update)\n- Repo size impact (minimal for small JSON files)\n\n### Fallback Strategies\n\nWhen atomic state update fails, use one of these fallbacks:\n\n| Strategy | When to Use | Trade-off |\n|----------|-------------|-----------|\n| **Timestamp** | Unique value needed, order not critical | Breaks sequential numbering |\n| **UUID** | Unique value needed, no pattern required | No human-readable sequence |\n| **Queue for retry** | Sequential order is critical | Delays processing |\n| **Range allocation** | High concurrency expected | More complex state management |\n\n### Integration Points\n\n**GitHub Actions:**\n```yaml\nsteps:\n  - name: Get next value\n    id: state\n    run: |\n      python tools/manage_state.py state.json get_next > output.json\n      VALUE=$(jq -r '.value' output.json)\n      echo \"VALUE=$VALUE\" >> $GITHUB_OUTPUT\n  \n  - name: Use value\n    run: |\n      process_data.py --id ${{ steps.state.outputs.VALUE }}\n  \n  - name: Commit state\n    run: |\n      git add state.json output/*\n      git commit -m \"Process ID ${{ steps.state.outputs.VALUE }}\"\n      git push\n```\n\n### Success Criteria\n\n- State file exists and is valid JSON\n- Lock acquired within timeout (5 seconds)\n- State incremented correctly\n- Output files reference correct state value\n- State file committed (or queued for commit)\n- Audit trail complete (log entry written)\n\n### Performance Characteristics\n\n- **Lock acquisition**: < 100ms (no contention) to 5s (with contention)\n- **State read/write**: < 50ms (small JSON files)\n- **Git commit**: 1-2 seconds\n- **Total overhead**: 2-7 seconds per execution\n\n**Bottleneck:** Git commit (unavoidable for state persistence)\n\n### Key Learnings (from invoice-generator build)\n\n- **Lock timeout must have fallback** -- Never let locking failure halt the workflow\n- **Initialize on missing file** -- Don't fail on first run\n- **Timestamp fallback works** -- Breaks sequence but ensures uniqueness\n- **Audit log is separate** -- State update and audit logging are independent\n- **State-before-output** -- Update state BEFORE generating output (prevents duplicate detection)\n- **Decimal for currency** -- Use Decimal type when state affects financial calculations\n\n### Anti-Patterns to Avoid\n\n- **No locking** -- Race conditions create duplicates\n- **Hardcoded initial value** -- Make it configurable\n- **Fail without fallback** -- Lock timeout should not crash the system\n- **Update state after output** -- Output first, then state (wrong order leads to duplicates on failure)\n- **Manual state edits** -- Always use the tool (manual edits bypass validation)\n- **Ignore lock timeouts** -- Log and investigate when locks time out frequently\n\n### Related Patterns\n\nCombines elements of:\n- **Collect > Transform > Store** (base pipeline)\n- **Monitor > Detect > Alert** (state changes can trigger alerts)\n- **Generate > Review > Publish** (state affects generated content)\n\nOften used with:\n- **Intake > Enrich > Deliver** (state provides IDs or version numbers)\n- **Fan-Out > Process > Merge** (each parallel task gets unique ID from state)\n\n## 13. Multi-Source Weekly Monitor with Snapshot Comparison\n\n\n[Showing lines 1-963 of 1693 (50.0KB limit). Use offset=964 to continue.]"}],"details":{"truncation":{"content":"# WAT Systems Factory -- Workflow Pattern Catalog\n\n> Proven, reusable workflow patterns for building GitHub-native autonomous systems with Claude Code and MCP tools.\n\nEach pattern below is a composable building block. Patterns can be combined: a **Monitor > Detect > Alert** system might trigger an **Issue > Execute > PR** workflow, which internally uses **Fan-Out > Process > Merge** for the heavy lifting.\n\n---\n\n## 1. Scrape > Process > Output\n\n**Summary:** A web scraping pipeline that fetches raw content from one or more URLs via a web-access MCP, processes and structures the data with Python (or Claude itself), and writes clean output to a target destination.\n\n### When to Use\n\n- You need structured data extracted from websites that lack APIs.\n- You want to convert messy HTML into clean JSON, CSV, or Markdown on a recurring schedule.\n- You are building a dataset from publicly available web content.\n\n### Steps\n\n1. **Define targets** -- Specify URLs, selectors, or search queries in a config file or workflow input.\n2. **Fetch raw content** -- Use a web MCP (Fetch, Puppeteer, or Playwright) to retrieve page content. Handle pagination if needed.\n3. **Parse and extract** -- Strip irrelevant markup. Pull target fields using CSS selectors, XPath, or Claude-driven semantic extraction.\n4. **Transform** -- Normalize data types, deduplicate, validate schema. Python scripts or inline Claude processing.\n5. **Output** -- Write results to a file in the repo (`data/`, `output/`), post to an API, or commit as a structured artifact.\n\n### Key Tools / MCPs\n\n- **Fetch MCP** -- lightweight HTTP retrieval, returns Markdown-converted content.\n- **Puppeteer / Playwright MCP** -- for JavaScript-rendered pages requiring a headless browser.\n- **Python** -- pandas, BeautifulSoup, or custom scripts for heavy transformation.\n- **filesystem MCP** -- write results to disk.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 6 * * *'   # daily at 06:00 UTC\n  workflow_dispatch:        # manual trigger\n```\n\n### Example Use Cases\n\n- Scrape competitor pricing pages nightly; output a CSV diff showing changes.\n- Collect job postings from three sites; normalize into a single JSON feed committed to the repo.\n- Pull public government data tables and convert to machine-readable Parquet files.\n\n### Failure Handling\n\n- **Retry with backoff** on transient HTTP errors (429, 503).\n- **Schema validation** after extraction -- if required fields are missing, flag the record rather than silently dropping it.\n- **Stale-data guard** -- if fetch returns identical content to last run, skip processing and log \"no change.\"\n- **Alert on structural change** -- if selectors return zero matches (site redesign), open a GitHub Issue for human review.\n\n---\n\n## 2. Research > Analyze > Report\n\n**Summary:** A multi-source research workflow that gathers information from diverse sources (web, APIs, local files), synthesizes findings with Claude, and produces a formatted report committed to the repository.\n\n### When to Use\n\n- You need to compile information from multiple sources into a single coherent document.\n- Periodic market research, competitive analysis, or literature reviews.\n- Any task where a human would spend hours reading and summarizing.\n\n### Steps\n\n1. **Define research brief** -- Specify the topic, questions to answer, source priorities, and output format.\n2. **Gather sources** -- Query web search, fetch specific URLs, read local reference files, call APIs.\n3. **Extract key findings** -- For each source, pull relevant facts, quotes, data points. Tag each with provenance.\n4. **Analyze and synthesize** -- Claude cross-references findings, identifies patterns, contradictions, and gaps.\n5. **Generate report** -- Produce a structured Markdown document with sections, citations, and an executive summary.\n6. **Commit and notify** -- Commit the report to the repo. Optionally open a PR or send a notification.\n\n### Key Tools / MCPs\n\n- **Web Search MCP / Fetch MCP** -- gather online sources.\n- **filesystem MCP** -- read local reference documents.\n- **GitHub MCP** -- commit output, open issues or PRs.\n- **Claude (extended thinking)** -- deep analysis and synthesis.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 9 * * 1'   # weekly on Monday at 09:00 UTC\n  workflow_dispatch:\n    inputs:\n      topic:\n        description: 'Research topic'\n        required: true\n```\n\n### Example Use Cases\n\n- Weekly competitive landscape report that tracks new features announced by three competitors.\n- Monthly technology radar summarizing emerging tools relevant to the team's stack.\n- Ad-hoc deep-dive report triggered manually via `workflow_dispatch` with a topic input.\n\n### Failure Handling\n\n- **Source fallback** -- if a primary source is unreachable, log it and proceed with remaining sources. Note gaps in the report.\n- **Confidence scoring** -- Claude flags low-confidence claims; the report includes a \"Caveats\" section.\n- **Minimum-source threshold** -- if fewer than N sources are successfully retrieved, abort and open an issue rather than publishing a thin report.\n\n---\n\n## 3. Monitor > Detect > Alert\n\n**Summary:** A continuous monitoring system that periodically checks a target (website, API, dataset, repo) for changes, applies detection logic, and fires alerts or triggers downstream workflows when significant changes are found.\n\n### When to Use\n\n- You want to be notified when something changes: a webpage, an API response, a competitor's pricing, a regulatory filing.\n- You need a lightweight, Git-native alternative to commercial monitoring SaaS.\n- Ideal for cron-triggered GitHub Actions that run on a schedule.\n\n### Steps\n\n1. **Fetch current state** -- Retrieve the current snapshot of the monitored target.\n2. **Load previous state** -- Read the last-known state from a file committed in the repo (e.g., `state/last_snapshot.json`).\n3. **Diff** -- Compare current vs. previous. Use structural diff for JSON, text diff for prose, hash comparison for binary.\n4. **Evaluate significance** -- Apply rules or Claude-based judgment to determine if the change is meaningful (filter noise).\n5. **Alert** -- If significant: open a GitHub Issue, send a Slack message, trigger a downstream workflow via `repository_dispatch`, or all three.\n6. **Persist new state** -- Commit the current snapshot as the new baseline.\n\n### Key Tools / MCPs\n\n- **Fetch MCP / Puppeteer MCP** -- retrieve current state from web targets.\n- **filesystem MCP** -- read/write state files.\n- **GitHub MCP** -- open issues, trigger dispatches.\n- **Slack MCP** -- send alert messages.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '*/30 * * * *'  # every 30 minutes\n```\n\n### Example Use Cases\n\n- Monitor a government regulatory page for new filings; alert the legal team via Slack when a new document appears.\n- Watch a competitor's changelog page; open a GitHub Issue summarizing each detected update.\n- Track an API's response schema for breaking changes; alert the engineering team.\n\n### Failure Handling\n\n- **Transient failure tolerance** -- if the fetch fails, do NOT overwrite previous state. Log the failure. After N consecutive failures, escalate to an alert.\n- **False-positive suppression** -- use Claude to evaluate whether a detected \"change\" is meaningful (e.g., ignore timestamp-only diffs).\n- **State corruption recovery** -- if state file is missing or unparseable, re-initialize from scratch and log a warning instead of crashing.\n\n---\n\n## 4. Intake > Enrich > Deliver\n\n**Summary:** A data enrichment pipeline that receives raw input (from a form, webhook, file drop, or API), augments it with additional data from external sources, and delivers the enriched result to its destination.\n\n### When to Use\n\n- Incoming data is incomplete and needs augmentation before it is useful.\n- You are building a lead enrichment, content tagging, or metadata enhancement system.\n- Raw data arrives in one format and must be transformed and enriched before storage or delivery.\n\n### Steps\n\n1. **Intake** -- Receive raw data. Sources: webhook payload, new file in repo, manual trigger with JSON input, or a watched directory.\n2. **Validate** -- Check that required fields exist and data types are correct. Reject malformed input early.\n3. **Enrich** -- For each record, call enrichment sources: web search for context, APIs for supplementary data, Claude for classification or summarization.\n4. **Merge** -- Combine original data with enrichment results into a unified schema.\n5. **Deliver** -- Write enriched data to its destination: commit to repo, POST to API, append to a dataset file, or open a PR.\n\n### Key Tools / MCPs\n\n- **Web Search MCP** -- find supplementary information.\n- **Fetch MCP** -- call enrichment APIs.\n- **Claude** -- classify, tag, summarize, or score records.\n- **filesystem MCP** -- read input, write output.\n- **GitHub MCP** -- commit results or open PRs.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  push:\n    paths:\n      - 'inbox/**'          # new file dropped in inbox\n  workflow_dispatch:\n    inputs:\n      payload:\n        description: 'JSON data to enrich'\n        required: true\n```\n\n### Example Use Cases\n\n- A sales team drops a CSV of company names into `inbox/`; the pipeline enriches each with industry, size, website, and LinkedIn URL, then writes to `data/enriched_leads.csv`.\n- Incoming support tickets are enriched with customer history and sentiment score before routing.\n- Raw RSS feed items are enriched with summaries, topic tags, and relevance scores.\n\n### Failure Handling\n\n- **Per-record error isolation** -- if enrichment fails for one record, mark it as `enrichment_failed` and continue processing the rest. Do not let one bad record kill the batch.\n- **Rate-limit awareness** -- track API call counts; pause and retry when rate-limited rather than failing fast.\n- **Partial delivery** -- deliver successfully enriched records on schedule; queue failed records for retry in the next run.\n\n---\n\n## 5. Generate > Review > Publish\n\n**Summary:** A content generation pipeline with built-in quality gates. Claude generates draft content, a review step validates quality and compliance, and approved content is published to its destination.\n\n### When to Use\n\n- Automated content creation (blog posts, documentation, social media, release notes) where quality must be verified before publishing.\n- Any workflow where you want a \"human-in-the-loop\" approval step or an automated quality check before output goes live.\n\n### Steps\n\n1. **Brief** -- Define the content requirements: topic, audience, tone, length, format, and any reference material.\n2. **Generate** -- Claude produces a first draft using the brief and any provided reference material.\n3. **Automated review** -- Run quality checks: spelling/grammar, factual consistency against source material, tone analysis, compliance rules (e.g., no prohibited claims).\n4. **Gate decision** -- If automated review passes, proceed. If it fails, loop back to step 2 with feedback (max N retries). Optionally, require human approval via a PR review.\n5. **Publish** -- Commit final content to the repo, deploy to a CMS via API, or post to a platform.\n\n### Key Tools / MCPs\n\n- **Claude** -- generation and review (use separate system prompts for generator vs. reviewer to create genuine separation).\n- **filesystem MCP** -- read briefs, write drafts and final output.\n- **GitHub MCP** -- open a draft PR for human review; merge on approval.\n- **Fetch MCP** -- publish to external CMS or platform APIs.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [labeled]        # label \"content-request\" triggers generation\n  pull_request_review:\n    types: [submitted]      # human approval triggers publish\n  workflow_dispatch:\n```\n\n### Example Use Cases\n\n- Weekly changelog: gather merged PRs, generate a formatted changelog, open a PR for team review, publish on approval.\n- Blog post pipeline: issue labeled \"draft-request\" triggers generation; editor reviews the PR; merge triggers deployment.\n- Social media batch: generate a week's worth of posts, run brand-voice review, output approved posts to a scheduling queue.\n\n### Failure Handling\n\n- **Retry budget** -- if automated review rejects the draft, regenerate with targeted feedback up to 3 times. After that, escalate to a human by opening an issue.\n- **Rollback on publish failure** -- if the publish step fails (API error), keep the approved content in the repo and log the failure for manual retry.\n- **Diff guard** -- before publishing, diff against previously published content to prevent accidental overwrite of manual edits.\n\n---\n\n## 6. Listen > Decide > Act\n\n**Summary:** An event-driven agent that listens for incoming events (webhooks, GitHub events, messages), applies decision logic to determine the appropriate response, and takes autonomous action.\n\n### When to Use\n\n- You need a system that reacts to external events in near-real-time.\n- Webhook-triggered GitHub Actions are the execution engine.\n- The appropriate response depends on the content of the event (routing, triage, conditional logic).\n\n### Steps\n\n1. **Receive event** -- GitHub Actions triggers on the event (webhook, issue creation, PR comment, `repository_dispatch`).\n2. **Parse and classify** -- Extract relevant data from the event payload. Use Claude to classify intent or severity if the input is unstructured (e.g., natural language).\n3. **Decide** -- Apply decision logic: rule-based routing, Claude-driven triage, or a lookup table. Determine which action(s) to take.\n4. **Act** -- Execute the chosen action: respond to the issue, trigger another workflow, call an API, update a file, or escalate to a human.\n5. **Log** -- Record the event, decision, and action taken for auditability.\n\n### Key Tools / MCPs\n\n- **GitHub MCP** -- read event payloads, respond to issues/PRs, trigger dispatches.\n- **Claude** -- classify, triage, and decide.\n- **Slack MCP** -- notify humans when escalation is needed.\n- **Fetch MCP** -- call external APIs as part of the action.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [opened, labeled]\n  issue_comment:\n    types: [created]\n  repository_dispatch:\n    types: [incoming_webhook]\n```\n\n### Example Use Cases\n\n- Triage bot: new issues are classified by Claude (bug, feature, question) and auto-labeled, assigned, and replied to with relevant templates.\n- Deployment gatekeeper: a PR comment like \"/deploy staging\" triggers a deployment workflow after validating the commenter's permissions.\n- Customer feedback router: webhook delivers feedback; Claude scores sentiment and routes critical items to Slack.\n\n### Failure Handling\n\n- **Idempotency** -- design actions to be safe to retry. Use event IDs to detect and skip duplicate deliveries.\n- **Decision logging** -- log the full decision chain (event > classification > decision > action) so failures can be diagnosed.\n- **Safe defaults** -- if classification confidence is low, default to escalation (notify a human) rather than taking an autonomous action that might be wrong.\n\n---\n\n## 7. Collect > Transform > Store\n\n**Summary:** A classic ETL (Extract, Transform, Load) pipeline where Git serves as the data store. Data is collected from external sources, transformed into a canonical format, and committed to the repository as versioned, queryable files.\n\n### When to Use\n\n- You want a version-controlled data lake without standing up a database.\n- Small-to-medium datasets (tens of MB) that benefit from Git's diff, history, and branching.\n- Data pipelines where auditability and reproducibility matter more than query speed.\n\n### Steps\n\n1. **Collect** -- Pull data from source(s): APIs, web scrapes, file uploads, other repos.\n2. **Validate** -- Check data integrity: schema validation, null checks, type enforcement.\n3. **Transform** -- Normalize, clean, reshape. Convert to the canonical schema. Deduplicate against existing data in the store.\n4. **Diff** -- Compare transformed data against the current version in the repo. Compute what is new, changed, or deleted.\n5. **Store** -- Commit the updated dataset files to the repo. Use meaningful commit messages describing what changed (e.g., \"Add 14 new records from source X\").\n\n### Key Tools / MCPs\n\n- **Fetch MCP** -- pull data from APIs and web sources.\n- **Python** -- pandas or custom scripts for transformation.\n- **filesystem MCP** -- read/write data files.\n- **GitHub MCP / Git CLI** -- commit, push, branch as needed.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  schedule:\n    - cron: '0 */6 * * *'  # every 6 hours\n  workflow_dispatch:\n```\n\n### Example Use Cases\n\n- Collect cryptocurrency prices from three APIs every 6 hours; store as daily CSV files in `data/prices/`.\n- Pull open government datasets weekly; transform into a normalized schema; maintain a living dataset in the repo.\n- Aggregate internal metrics from multiple microservice health endpoints; store as JSON for a dashboard.\n\n### Failure Handling\n\n- **Atomic commits** -- only commit if the entire pipeline succeeds. Never commit partial or corrupted data.\n- **Schema drift detection** -- if source data no longer matches the expected schema, abort and alert rather than storing malformed data.\n- **Rollback via Git** -- if bad data is committed, revert the commit. The previous state is always recoverable.\n- **Dedup safety** -- idempotent writes ensure that re-running the pipeline does not create duplicate records.\n\n---\n\n## 8. Fan-Out > Process > Merge\n\n**Summary:** The Agent Teams pattern. A coordinator agent splits a large task into independent sub-tasks, dispatches them to parallel sub-agents (or sequential iterations), collects all results, and merges them into a unified output.\n\n### When to Use\n\n- A task is naturally decomposable into independent units of work (e.g., process each file, research each topic, analyze each competitor).\n- You want to reduce wall-clock time by parallelizing work.\n- The final deliverable requires combining results from multiple sub-tasks.\n\n### Steps\n\n1. **Plan** -- The coordinator analyzes the task and determines how to decompose it. Produces a work manifest: a list of sub-tasks with their inputs.\n2. **Fan-Out** -- Dispatch each sub-task. Options: parallel GitHub Actions jobs via a matrix strategy, sequential Claude tool calls, or `repository_dispatch` events to separate workflows.\n3. **Process** -- Each sub-agent executes its sub-task independently. Results are written to a known location (e.g., `temp/results/task_01.json`).\n4. **Collect** -- The coordinator waits for all sub-tasks to complete and gathers their outputs.\n5. **Merge** -- Combine results: concatenate, deduplicate, reconcile conflicts, and produce the final unified output.\n6. **Deliver** -- Commit the merged output or pass it to the next stage in a larger pipeline.\n\n### Key Tools / MCPs\n\n- **Claude** -- coordinator logic, sub-task execution, merge logic.\n- **GitHub Actions matrix** -- parallel job execution.\n- **filesystem MCP** -- read/write intermediate and final results.\n- **GitHub MCP** -- coordinate via issues, artifacts, or dispatch events.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      task_manifest:\n        description: 'JSON array of sub-tasks'\n        required: true\n  repository_dispatch:\n    types: [fan_out_request]\n```\n\n### Example Use Cases\n\n- Analyze 20 competitor websites: fan out one sub-agent per competitor, each produces a profile, merge into a single competitive analysis report.\n- Process a batch of 50 documents: each sub-agent summarizes one document, merge into a master summary with cross-references.\n- Multi-language translation: fan out one sub-agent per target language, merge all translations into a localized content bundle.\n\n### Failure Handling\n\n- **Partial success tolerance** -- if some sub-tasks fail, merge the successful results and report failures. Do not discard all work because of one failure.\n- **Retry failed sub-tasks** -- the coordinator can re-dispatch failed sub-tasks up to N times before giving up.\n- **Timeout enforcement** -- set a maximum wall-clock time for the fan-out phase. Collect whatever is done when the timer expires.\n- **Conflict resolution** -- if sub-task results conflict, the merge step uses Claude to reconcile or flags the conflict for human review.\n\n---\n\n## 9. Issue > Execute > PR\n\n**Summary:** The GitHub Agent HQ pattern. An agent receives a task specification via a GitHub Issue, autonomously executes the required workflow, and delivers the results as a draft Pull Request for human review.\n\n### When to Use\n\n- You want a human-in-the-loop task queue where work is requested via Issues and delivered via PRs.\n- The agent should be fully autonomous in execution but the output requires human approval before merging.\n- Building an internal tool where non-technical stakeholders can request work by opening an Issue.\n\n### Steps\n\n1. **Receive** -- A new Issue is opened (or an existing Issue is labeled with a trigger label like `agent-task`). GitHub Actions fires.\n2. **Parse task** -- Claude reads the Issue body and extracts the task specification: what to do, inputs, constraints, expected output.\n3. **Create branch** -- Create a feature branch named after the Issue (e.g., `agent/issue-42`).\n4. **Execute** -- Run the appropriate workflow or pattern to complete the task. This might invoke any other pattern in this catalog.\n5. **Commit results** -- Commit all output files to the feature branch with clear commit messages.\n6. **Open draft PR** -- Open a draft PR linked to the original Issue. The PR body includes a summary of what was done, key decisions made, and anything that needs human attention.\n7. **Comment on Issue** -- Post a comment on the Issue linking to the PR and summarizing the outcome.\n\n### Key Tools / MCPs\n\n- **GitHub MCP** -- read issues, create branches, commit, open PRs, post comments.\n- **Claude** -- parse task, execute logic, generate summaries.\n- **Any other MCP** -- depending on the task being executed.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  issues:\n    types: [opened, labeled]\n  issue_comment:\n    types: [created]       # support \"/execute\" command in comments\n```\n\n### Example Use Cases\n\n- A product manager opens an Issue: \"Research top 5 CRM tools and compare features.\" The agent researches, builds a comparison table, and opens a PR with the report.\n- An engineer opens an Issue: \"Add unit tests for the auth module.\" The agent generates tests and delivers them as a PR.\n- A stakeholder opens an Issue: \"Update the pricing page data for Q1.\" The agent pulls new data, updates the files, and opens a PR for review.\n\n### Failure Handling\n\n- **Status updates** -- the agent comments on the Issue at each major step (\"Starting research...\", \"Generating report...\", \"Opening PR...\") so progress is visible.\n- **Graceful failure** -- if the agent cannot complete the task, it comments on the Issue with a clear explanation of what went wrong and what it tried, then labels the Issue `agent-failed` for human triage.\n- **Scope guard** -- if Claude determines the task is ambiguous or out of scope, it asks a clarifying question in the Issue comments rather than guessing.\n- **Draft-only PRs** -- all PRs are opened as drafts. The agent never merges its own work.\n\n---\n\n## 10. n8n Import > Translate > Deploy\n\n**Summary:** A conversion pattern that ingests an n8n workflow JSON export, translates it into a WAT-native system (Claude Code + MCP + GitHub Actions), and deploys it as a fully functional GitHub-native workflow.\n\n### When to Use\n\n- You are migrating from n8n (or a similar visual workflow tool) to a GitHub-native architecture.\n- You want to leverage existing workflow logic without manually rewriting it.\n- You are evaluating whether an n8n workflow can run as a WAT system to reduce infrastructure dependencies.\n\n### Steps\n\n1. **Import** -- Read the n8n workflow JSON file. This contains nodes, connections, credentials references, and configuration.\n2. **Parse and map** -- Walk the node graph. For each n8n node type, identify the equivalent WAT component:\n   - HTTP Request node -> Fetch MCP call\n   - Code (JavaScript/Python) node -> inline script or Python file\n   - IF/Switch node -> Claude decision logic or conditional in workflow\n   - Webhook trigger -> `repository_dispatch` or `workflow_dispatch`\n   - Cron trigger -> `schedule` trigger in GitHub Actions\n   - Set/Merge nodes -> data transformation in Claude or Python\n3. **Translate** -- Generate the WAT system files:\n   - `.github/workflows/*.yml` -- GitHub Actions workflow definition.\n   - `prompts/` -- Claude system prompts for nodes that require AI logic.\n   - `scripts/` -- Python or shell scripts for code nodes.\n   - `config/` -- Configuration extracted from the n8n workflow.\n4. **Validate** -- Dry-run the generated workflow. Check that all node types were mapped, no credentials are hardcoded, and the control flow is correct.\n5. **Deploy** -- Commit the generated files to the repo. Open a PR with a detailed summary of the translation, noting any nodes that required manual review or could not be auto-translated.\n\n### Key Tools / MCPs\n\n- **filesystem MCP** -- read n8n JSON, write generated files.\n- **Claude** -- interpret node logic, generate prompts, translate code, produce workflow YAML.\n- **GitHub MCP** -- commit files, open PR.\n- **Python** -- parse n8n JSON, generate boilerplate.\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  push:\n    paths:\n      - 'imports/n8n/*.json'   # drop an n8n export to trigger conversion\n  workflow_dispatch:\n    inputs:\n      n8n_file:\n        description: 'Path to n8n JSON file in the repo'\n        required: true\n```\n\n### Example Use Cases\n\n- Migrate a 15-node n8n lead-scoring workflow to a Git-versioned, GitHub Actions-powered system.\n- Convert an n8n social media posting pipeline into a WAT **Generate > Review > Publish** system.\n- Translate an n8n monitoring workflow into a WAT **Monitor > Detect > Alert** pattern, eliminating the need for a running n8n instance.\n\n### Failure Handling\n\n- **Unsupported node catalog** -- maintain a list of n8n node types that cannot be auto-translated. When encountered, flag them in the PR description with a `TODO` and a suggested manual implementation.\n- **Credential safety** -- never translate credentials. Replace all credential references with GitHub Secrets placeholders (`${{ secrets.SERVICE_API_KEY }}`) and document which secrets need to be configured.\n- **Fidelity check** -- generate a side-by-side comparison of the n8n flow and the translated WAT flow so a human reviewer can verify correctness.\n- **Incremental migration** -- support translating a subset of the n8n workflow, allowing teams to migrate node-by-node rather than all-at-once.\n\n---\n\n## Pattern Composition Quick Reference\n\nPatterns are building blocks. Here are common compositions:\n\n| Composition | How It Works |\n|---|---|\n| **Monitor > Detect > Alert** + **Issue > Execute > PR** | Monitor detects a change, opens an Issue, which triggers the agent to act and deliver a PR. |\n| **Issue > Execute > PR** using **Fan-Out > Process > Merge** | A complex Issue task is decomposed and parallelized internally before the PR is opened. |\n| **Scrape > Process > Output** feeding **Collect > Transform > Store** | Scraping output is piped into the ETL pattern for versioned storage. |\n| **Listen > Decide > Act** routing to any pattern | An event-driven dispatcher that selects and triggers the appropriate pattern based on the event. |\n| **n8n Import > Translate > Deploy** producing any pattern | The translator identifies which WAT pattern best fits the n8n workflow and generates accordingly. |\n\n---\n\n## Choosing a Pattern\n\n| Question | Recommended Pattern |\n|---|---|\n| Do I need to pull data from websites? | **Scrape > Process > Output** |\n| Do I need to synthesize information from many sources? | **Research > Analyze > Report** |\n| Do I need to watch for changes over time? | **Monitor > Detect > Alert** |\n| Do I need to augment incoming data? | **Intake > Enrich > Deliver** |\n| Do I need AI-generated content with quality control? | **Generate > Review > Publish** |\n| Do I need to react to external events? | **Listen > Decide > Act** |\n| Do I need versioned data storage without a database? | **Collect > Transform > Store** |\n| Do I need to parallelize a large task? | **Fan-Out > Process > Merge** |\n| Do I need a task queue with human approval? | **Issue > Execute > PR** |\n| Do I need to migrate an n8n workflow? | **n8n Import > Translate > Deploy** |\n| Do I need B2B lead generation from web data? | **Intake > Enrich > Deliver** (lead-gen variant) |\n\n---\n\n## Proven Compositions (from builds)\n\n### Lead Generation Pipeline (lead-gen-machine)\n- **Pattern**: Intake > Enrich > Deliver + Scrape > Process > Output\n- **Flow**: Parse profile > Search web > Scrape sites > Extract contacts (Claude) > Score leads > Output CSV\n- **Key insight**: The Intake > Enrich > Deliver pattern works well when the \"enrichment\" involves multi-step web scraping + AI extraction. Each company is an independent unit of work, making this a strong candidate for Fan-Out > Process > Merge parallelization.\n- **Scoring pattern**: Decompose match criteria into independent dimensions (industry, size, location, keywords) with weighted point values. This makes the scoring transparent and tunable.\n- **Fallback chains**: Firecrawl > HTTP+BeautifulSoup for scraping, Claude > regex for extraction. Always have a degraded-but-functional fallback.\n\n### Marketing Pipeline (marketing-pipeline)\n- **Pattern**: Intake > Enrich > Deliver + Generate > Review > Publish\n- **Flow**: Ingest CSV > Enrich via Apollo/Hunter/Brave/Claude > Deep-score (5 dimensions) > Segment (Hot/Warm/Cold) > Generate outreach (Hot) > Generate nurture (Warm) > Output CSVs + emails\n- **Key insight**: Multi-API enrichment with graceful degradation. Apollo (primary) > Hunter (email verification) > Brave (research) > Claude (pain analysis). Each API layer adds value but the system works with only Anthropic API.\n- **Scoring pattern**: 5-dimension scoring (size fit, tech stack compatibility, budget signals, accessibility, pain signals) with transparent point breakdown. More dimensions = more nuanced than lead-gen-machine's 4-dimension approach.\n- **Content generation pattern**: Outreach and nurture are independent post-segmentation, making them natural Agent Teams candidates. Outreach is per-lead personalized; nurture is aggregate-informed.\n- **API fallback chain**: Apollo > Hunter > Brave > Claude > HTTP scraping. Four-level fallback with clear degradation at each level.\n- **CSV-in/CSV-out**: Accepts CSV input (compatible with lead-gen-machine output), produces segmented CSVs + markdown email sequences. Easy to chain systems.\n\n### Website Uptime Monitor (website-uptime-monitor)\n- **Pattern**: Monitor > Log (simplified from Monitor > Detect > Alert)\n- **Flow**: Check URL via HTTP GET > Measure response time > Determine up/down status > Append to CSV > Commit to Git\n- **Key insight**: Simplest possible monitoring system - no detection logic, no alerting, just raw data collection. Every check produces a log entry regardless of status. Git history IS the audit trail.\n- **No MCPs needed**: Direct Python `requests` library is simpler and more reliable than Fetch MCP for a single GET request. CSV append uses stdlib. Zero external dependencies beyond GitHub Actions.\n- **Exit code signaling**: Tool exits 0 if up, 1 if down - GitHub Actions UI shows workflow as \"failed\" when site is down, providing at-a-glance status without additional alerting logic.\n- **Concurrency handling**: GitHub Actions `concurrency` setting prevents simultaneous runs. Git push includes retry with rebase to handle rare concurrent commits.\n- **CSV as database**: Append-only CSV committed to Git provides versioned, auditable, queryable dataset. No external database needed. Git handles MB-scale data easily.\n- **Cron variance accepted**: GitHub Actions cron has ±5 minute variance - documented as expected behavior rather than a bug to fix.\n- **Three execution paths**: (1) Scheduled cron (primary), (2) Manual dispatch (testing), (3) Local CLI (development). Agent HQ (4) optional for issue-driven tasks.\n- **Cost awareness**: ~1,440 GitHub Actions minutes/month for 5-minute checks. Fits within free tier (2,000/month private, unlimited public).\n- **Extensibility points**: Add alerting by extending monitor.yml (Slack webhook, GitHub Issue). Add multiple URLs via matrix strategy or separate workflows. Add authentication via tool arguments + GitHub Secrets.\n\n### CSV-to-JSON Converter (csv-to-json-converter)\n- **Pattern**: Collect > Transform > Store\n- **Flow**: Collect CSV files > Analyze structure > Parse CSV > Infer types > Validate data > Convert to JSON/JSONL > Generate reports > Commit\n- **Key insight**: Multi-phase transformation with specialist subagents. Each phase (analyze, infer, validate, write) has a dedicated subagent with focused responsibilities. Main agent orchestrates the pipeline.\n- **Subagent architecture**: Four specialist subagents (csv-analyzer, type-inference-specialist, data-validator, json-writer) with minimal tool access. Subagents are the DEFAULT delegation mechanism, not Agent Teams.\n- **Type inference pattern**: Statistical analysis with confidence scoring (80% threshold). Detects int, float, boolean, datetime, string. Falls back to string for ambiguous columns. Handles 10+ null value representations.\n- **Encoding detection**: chardet for automatic encoding detection with UTF-8 fallback. Strips BOM (byte order mark) automatically. Supports UTF-8, Latin-1, Windows-1252, etc.\n- **Ragged row handling**: Pad short rows with null, truncate long rows with warning. Log all issues in validation report but continue processing (graceful degradation).\n- **Validation without failure**: Validator NEVER raises exceptions. Always returns a report. Strict mode controls whether issues halt the pipeline, but validation itself is fail-safe.\n- **JSONL streaming**: For large files (1M+ rows), JSONL format writes one record at a time. No array wrapper. Memory-efficient for multi-GB datasets.\n- **Batch processing modes**: Sequential (1-2 files) or parallel (3+ files with Agent Teams). Parallel is 5x faster wall time but same token cost. Always has sequential fallback.\n- **Three execution paths**: (1) CLI for local development, (2) GitHub Actions for production, (3) Agent HQ for issue-driven tasks. All three produce identical output.\n- **Metadata reporting**: run_summary.json (machine-readable) + validation_report.md (human-readable). Includes per-file stats, type inference results, validation issues, recommendations.\n- **No secrets required**: Uses only stdlib (csv, json, pathlib) + chardet + python-dateutil. No external APIs. Pure data transformation pipeline.\n- **Git commit discipline**: Stage ONLY output files (never `git add -A`). Commit message includes file count, row count, timestamp. Output directory is parameterized.\n\n### RSS Digest Monitor (rss-digest-monitor)\n- **Pattern**: Monitor > Collect > Transform > Deliver (with state persistence)\n- **Flow**: Load state > Fetch RSS feeds > Filter new posts > Generate HTML digest > Send email > Update state > Commit\n- **Key insight**: State persistence in Git prevents post duplication across runs. Composite GUID keys (feed_url::guid) prevent false deduplication. State is ONLY updated after successful email delivery, ensuring retry on failure.\n- **Subagent architecture**: Three specialist subagents (rss-fetcher-specialist, digest-generator-specialist, state-manager-specialist). Subagents are the DEFAULT delegation mechanism. Sequential execution is correct due to clear data dependencies.\n- **Per-feed error isolation**: One failed feed does NOT kill the entire run. Each feed is fetched independently with try/except. Failed feeds are logged and skipped. Graceful degradation ensures partial success.\n- **Composite GUID pattern**: Use `feed_url::entry_guid` as deduplication key instead of guid alone. Prevents false positives when different feeds use the same GUID format.\n- **State file size management**: Enforce maximum 10,000 GUIDs by keeping most recent entries. Prevents unbounded state growth. Log warning if limit is hit.\n- **Email with fallback**: MIME multipart with HTML primary and plain-text fallback. Ensures compatibility with all email clients. HTML is styled with inline CSS for maximum rendering support.\n- **Conditional email send**: Skip email generation if no new posts found. Silent run with state update only. Saves API calls and prevents empty emails.\n- **SMTP retry logic**: Retry once with 30s delay on transient failures (auth, network, timeout). Do NOT update state if email send fails -- posts retry on next run.\n- **First-run initialization**: Missing or corrupted state file initializes empty state. All posts are processed on first run. Log warning but continue (better to duplicate once than crash).\n- **Date parsing with fallback**: Use python-dateutil for robust parsing of varied date formats. If unparseable, use current timestamp. Include post anyway (better to duplicate than miss).\n- **Three execution paths**: (1) Scheduled cron at 8 AM UTC (primary), (2) Manual dispatch with force_send (testing), (3) Local CLI (development). All produce identical output.\n- **Run summary logging**: Each run produces `logs/YYYY-MM-DD_run.json` with feeds_checked, feeds_failed, new_posts, email_sent, failed_feeds array. Machine-readable audit trail.\n- **Git commit discipline**: Stage ONLY state/rss_state.json and logs/*.json. NEVER `git add -A`. Commit message includes date and post count for easy history review.\n- **No MCP dependencies**: Uses standard Python libraries (feedparser, smtplib, json, pathlib). Works out-of-the-box with only Python and requirements.txt. No external MCPs required.\n- **Cost awareness**: ~3-5 minutes per day = ~90-150 GitHub Actions minutes/month. Well within free tier (2,000/month private, unlimited public). Minimal token cost for state management only.\n\n## 11. Content Transformation with Tone Matching\n\n**Summary:** An AI-powered content repurposing pipeline that extracts content from a source URL, analyzes its tone and style, and generates platform-optimized variants (social media, email, etc.) that match the source tone automatically.\n\n### When to Use\n\n- You need to publish the same content across multiple platforms with different format requirements\n- Content must maintain consistent voice/tone across all platforms\n- Manual reformatting for each platform is time-consuming and error-prone\n- You want AI to handle platform-specific best practices (character limits, hashtags, formatting)\n\n### Steps\n\n1. **Fetch source content** -- Scrape the source URL (blog post, article) and extract clean text/markdown. Use Firecrawl with HTTP fallback for reliability.\n2. **Analyze tone** -- Use LLM (Claude) with structured output to analyze writing style across multiple dimensions: formality, technical level, humor, primary emotion. Return confidence score.\n3. **Generate platform variants (parallel)** -- For each target platform (Twitter, LinkedIn, email, Instagram):\n   - Send source content + tone analysis to LLM\n   - Request platform-optimized output matching source tone\n   - Enforce platform-specific constraints (char limits, hashtag counts, formatting rules)\n   - Validate character counts before accepting output\n4. **Merge and output** -- Combine all variants into single JSON file with metadata, tone analysis, and all platform content\n\n### Key Tools / MCPs\n\n- **Firecrawl MCP** -- reliable web scraping with JS rendering support\n- **Anthropic MCP** -- Claude for tone analysis and content generation\n- **HTTP + BeautifulSoup** -- fallback scraping if Firecrawl unavailable\n- **Python stdlib** -- JSON manipulation, filename slugification, output assembly\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      blog_url:\n        description: 'Blog post URL to repurpose'\n        required: true\n  # Can also be triggered on new blog post detection via RSS or webhook\n```\n\n### Example Use Cases\n\n- Marketing team publishes a blog post, wants Twitter thread, LinkedIn post, email newsletter section, and Instagram caption\n- Content creator wants to maximize reach by publishing same content on all major platforms\n- Agency needs to repurpose client blog posts for multi-channel campaigns\n- Developer advocates want to turn technical blog posts into social-friendly content\n\n### Subagent Architecture\n\n- **content-scraper-specialist** -- Handles web scraping with fallback strategies\n- **tone-analyzer-specialist** -- Analyzes source content tone/style\n- **content-generator-specialist** -- Coordinates multi-platform generation (can use Agent Teams for parallelization)\n- **output-assembler-specialist** -- Merges all content into final JSON\n\n### Agent Teams Parallelization\n\nPlatform generation is ideal for Agent Teams:\n- 4 independent platform generation tasks (Twitter, LinkedIn, email, Instagram)\n- Each takes 10-15 seconds sequentially = 40-55s total\n- Parallel execution with 4 teammates = 12-18s\n- **2x speedup** with identical results and same token cost\n\n### Platform-Specific Constraints\n\n| Platform | Char Limit | Hashtags | Format Notes |\n|----------|------------|----------|--------------|\n| Twitter | 280 per tweet | 2-3 per thread | Numbered thread (1/N format), hook in first tweet, CTA in last |\n| LinkedIn | 3000 max, 1300 target | 3-5 | Professional tone, hook before \"see more\" fold, line breaks |\n| Email | 500-800 words | N/A | Subject line (40-60 chars), scannable format, HTML + plain text |\n| Instagram | 2200 max | 10-15 | Casual tone, emojis (3-5), line breaks, hook before \"more\" button |\n\n### Tone Matching Pattern\n\n1. LLM analyzes source content with structured JSON schema\n2. Returns tone profile: {formality, technical_level, humor_level, primary_emotion, confidence}\n3. Platform generators receive tone profile in their prompts\n4. Each generator adjusts output style to match source tone (formal → formal, casual → casual)\n5. Result: All platforms sound like they were written by the same person\n\n### Failure Handling\n\n- **Scraping failure** -- Halt workflow immediately (no content = can't proceed). Log clear error about paywall/404/timeout.\n- **Tone analysis failure** -- Return default neutral profile, continue with warning. Quality slightly reduced but system remains functional.\n- **Single platform failure** -- Continue with other platforms. Include error structure for failed platform in output. Partial success is acceptable.\n- **Character limit exceeded** -- Tools automatically truncate with \"...\" and log warning. Better than crashing.\n\n### Performance & Cost\n\n**Execution time**:\n- Sequential: ~52-74 seconds\n- With Agent Teams: ~25-37 seconds (2x faster)\n\n**API cost per run** (Claude Sonnet 4):\n- Scraping: $0.01-0.02 (Firecrawl)\n- LLM calls: ~$0.09 (tone + 4 platforms)\n- **Total: ~$0.10-0.11 per blog post**\n\n### Success Criteria\n\n✅ Source content extracted (≥ 100 chars)\n✅ Tone analysis returns confidence ≥ 0.5\n✅ At least 2/4 platforms generate successfully\n✅ All character counts within platform limits\n✅ Output JSON file written to repo\n\n### Key Learnings\n\n- **Tone matching is powerful** -- AI can accurately replicate writing style when given structured tone analysis\n- **Parallel generation scales well** -- 4 independent LLM calls are perfect for Agent Teams\n- **Character validation is critical** -- Must validate before returning, not after\n- **Partial success is acceptable** -- 3/4 platforms working is better than all-or-nothing\n- **Firecrawl + fallback pattern works** -- Primary API with HTTP backup maximizes reliability\n- **Subagent specialization reduces complexity** -- Each subagent has clear, scoped responsibility\n\n### Related Patterns\n\nCombines elements of:\n- **Scrape > Process > Output** (content extraction)\n- **Fan-Out > Process > Merge** (parallel platform generation via Agent Teams)\n- **Generate > Review > Publish** (content creation with validation)\n\n## 12. Sequential State Management Pipeline\n\n**Summary:** A data transformation pipeline that maintains persistent state across runs using atomic file operations. Each execution reads current state, transforms data, generates output, updates state, and commits results -- all while preventing race conditions.\n\n### When to Use\n\n- You need sequential numbering or versioning that persists across workflow runs\n- Output depends on previous runs (counters, IDs, sequence numbers)\n- Concurrent execution must not create duplicates\n- State must survive container/server restarts\n- Git-native state storage is preferred over external databases\n\n### Steps\n\n1. **Read State** -- Load previous state from committed file\n2. **Lock State** -- Acquire file lock to prevent concurrent modifications\n3. **Transform Data** -- Process input using current state\n4. **Update State** -- Increment counter, add ID, update version\n5. **Generate Output** -- Produce artifacts using updated state\n6. **Commit State** -- Write state file and outputs to repo\n7. **Release Lock** -- Allow next execution to proceed\n\n### Key Tools / MCPs\n\n- **filelock** (Python) -- Atomic file locking with timeout\n- **Git** -- State file versioning and recovery\n- **filesystem MCP** -- Read/write state files\n- **JSON** (stdlib) -- State serialization\n\n### GitHub Actions Trigger\n\n```yaml\non:\n  workflow_dispatch:\n    inputs:\n      data:\n        description: 'Input data to process'\n        required: true\n  push:\n    paths:\n      - 'input/**'\n```\n\n### Example Use Cases\n\n- Invoice generator with sequential invoice numbers (INV-1001, INV-1002...)\n- Document versioning system (v1.0, v1.1, v2.0...)\n- Sequential ID assignment for records\n- Incrementing batch job numbers\n- Auto-incrementing PR numbers in custom systems\n\n### State File Format\n\n```json\n{\n  \"last_value\": 1042,\n  \"prefix\": \"INV-\",\n  \"padding\": 4,\n  \"metadata\": {\n    \"last_updated\": \"2026-02-11T14:30:00Z\",\n    \"total_count\": 1042\n  }\n}\n```\n\n### Atomic Operations Pattern\n\n```python\nfrom filelock import FileLock, Timeout\n\nlock_path = f\"{state_file}.lock\"\ntry:\n    with FileLock(lock_path, timeout=5):\n        # Read current state\n        state = json.loads(Path(state_file).read_text())\n        \n        # Modify state\n        state[\"last_value\"] += 1\n        \n        # Write updated state\n        Path(state_file).write_text(json.dumps(state, indent=2))\n        \n        # Return new value\n        return state[\"last_value\"]\nexcept Timeout:\n    # Fallback: use timestamp or other unique value\n    return generate_fallback_value()\n```\n\n### Failure Handling\n\n**Lock timeout (5 seconds)**\n- **Cause**: Concurrent execution or filesystem issue\n- **Action**: Use fallback mechanism (timestamp, UUID, or queue for retry)\n- **Log**: Warning with details for investigation\n- **Continue**: Workflow proceeds with fallback value\n\n**State file missing**\n- **Cause**: First run or file deleted\n- **Action**: Initialize to default starting value\n- **Log**: Info message about initialization\n- **Continue**: Normal operation from initial state\n\n**State file corrupted**\n- **Cause**: Incomplete write, manual edit, merge conflict\n- **Action**: Restore from Git history or reinitialize\n- **Log**: Error with corrupted content\n- **Halt**: Require manual intervention (prevents data loss)\n\n**Concurrent modifications**\n- **Prevented by**: File locking ensures only one process modifies at a time\n- **If lock fails**: Fallback prevents workflow failure\n- **Trade-off**: Fallback may break sequential ordering but ensures system continues\n\n### Git-Native State Management\n\nState files are committed to the repository:\n\n**Benefits:**\n- Version history (full audit trail)\n- Rollback capability (`git checkout HEAD~5 state.json`)\n- Merge conflict detection\n- No external database needed\n- Free hosting on GitHub\n\n**Considerations:**\n- Not suitable for high-frequency updates (>100/min)\n- Commit overhead (~1-2 seconds per update)\n- Repo size impact (minimal for small JSON files)\n\n### Fallback Strategies\n\nWhen atomic state update fails, use one of these fallbacks:\n\n| Strategy | When to Use | Trade-off |\n|----------|-------------|-----------|\n| **Timestamp** | Unique value needed, order not critical | Breaks sequential numbering |\n| **UUID** | Unique value needed, no pattern required | No human-readable sequence |\n| **Queue for retry** | Sequential order is critical | Delays processing |\n| **Range allocation** | High concurrency expected | More complex state management |\n\n### Integration Points\n\n**GitHub Actions:**\n```yaml\nsteps:\n  - name: Get next value\n    id: state\n    run: |\n      python tools/manage_state.py state.json get_next > output.json\n      VALUE=$(jq -r '.value' output.json)\n      echo \"VALUE=$VALUE\" >> $GITHUB_OUTPUT\n  \n  - name: Use value\n    run: |\n      process_data.py --id ${{ steps.state.outputs.VALUE }}\n  \n  - name: Commit state\n    run: |\n      git add state.json output/*\n      git commit -m \"Process ID ${{ steps.state.outputs.VALUE }}\"\n      git push\n```\n\n### Success Criteria\n\n- State file exists and is valid JSON\n- Lock acquired within timeout (5 seconds)\n- State incremented correctly\n- Output files reference correct state value\n- State file committed (or queued for commit)\n- Audit trail complete (log entry written)\n\n### Performance Characteristics\n\n- **Lock acquisition**: < 100ms (no contention) to 5s (with contention)\n- **State read/write**: < 50ms (small JSON files)\n- **Git commit**: 1-2 seconds\n- **Total overhead**: 2-7 seconds per execution\n\n**Bottleneck:** Git commit (unavoidable for state persistence)\n\n### Key Learnings (from invoice-generator build)\n\n- **Lock timeout must have fallback** -- Never let locking failure halt the workflow\n- **Initialize on missing file** -- Don't fail on first run\n- **Timestamp fallback works** -- Breaks sequence but ensures uniqueness\n- **Audit log is separate** -- State update and audit logging are independent\n- **State-before-output** -- Update state BEFORE generating output (prevents duplicate detection)\n- **Decimal for currency** -- Use Decimal type when state affects financial calculations\n\n### Anti-Patterns to Avoid\n\n- **No locking** -- Race conditions create duplicates\n- **Hardcoded initial value** -- Make it configurable\n- **Fail without fallback** -- Lock timeout should not crash the system\n- **Update state after output** -- Output first, then state (wrong order leads to duplicates on failure)\n- **Manual state edits** -- Always use the tool (manual edits bypass validation)\n- **Ignore lock timeouts** -- Log and investigate when locks time out frequently\n\n### Related Patterns\n\nCombines elements of:\n- **Collect > Transform > Store** (base pipeline)\n- **Monitor > Detect > Alert** (state changes can trigger alerts)\n- **Generate > Review > Publish** (state affects generated content)\n\nOften used with:\n- **Intake > Enrich > Deliver** (state provides IDs or version numbers)\n- **Fan-Out > Process > Merge** (each parallel task gets unique ID from state)\n\n## 13. Multi-Source Weekly Monitor with Snapshot Comparison\n","truncated":true,"truncatedBy":"bytes","totalLines":1693,"totalBytes":79762,"outputLines":963,"outputBytes":51115,"lastLinePartial":false,"firstLineExceedsLimit":false,"maxLines":2000,"maxBytes":51200}},"isError":false,"timestamp":1771078863247}}
{"type":"message","id":"c1cfa724","parentId":"b1323b5e","timestamp":"2026-02-14T14:21:03.250Z","message":{"role":"toolResult","toolCallId":"toolu_01RjJcW2Beaq7zEEHtt54BRG","toolName":"read","content":[{"type":"text","text":"# WAT Systems Factory -- Reusable Tool Pattern Catalog\n\n> **Version:** 0.1.0-seed\n> **Maintainer:** WAT Systems Factory / Agent HQ\n> **Purpose:** Canonical reference of composable tool patterns that factory-generated workflows can assemble into pipelines. Each pattern is self-contained, testable, and convertible to an MCP tool or n8n node.\n\n---\n\n## Table of Contents\n\n1. [Web Scraping & Search](#web-scraping--search)\n2. [File I/O](#file-io)\n3. [API Calls](#api-calls)\n4. [Data Processing](#data-processing)\n5. [AI Processing](#ai-processing)\n6. [Notifications](#notifications)\n7. [Git Operations](#git-operations)\n8. [GitHub API](#github-api)\n9. [Database Operations](#database-operations)\n10. [Media Processing](#media-processing)\n11. [n8n Conversion](#n8n-conversion)\n12. [Agent Teams Coordination](#agent-teams-coordination)\n13. [GitHub Agent HQ Interaction](#github-agent-hq-interaction)\n\n---\n\n## Web Scraping & Search\n\n### `firecrawl_scrape`\n\n**Description:** Scrapes a single URL or crawls an entire domain via the Firecrawl API, returning clean Markdown-formatted content suitable for downstream LLM consumption.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `mode: Literal[\"scrape\", \"crawl\"]`, `max_pages: int = 50`, `selectors: list[str] = []` |\n| **Output** | `dict` with keys `markdown: str`, `metadata: dict`, `links: list[str]` |\n| **Key Dependencies** | `firecrawl-py`, `httpx` |\n| **MCP Alternative** | `@anthropic/firecrawl-mcp` server -- exposes `firecrawl_scrape` and `firecrawl_crawl` tools directly |\n\n```python\nimport os\nfrom firecrawl import FirecrawlApp\n\ndef main(url: str, mode: str = \"scrape\", max_pages: int = 50,\n         selectors: list[str] | None = None) -> dict:\n    \"\"\"Scrape or crawl a URL via Firecrawl and return Markdown content.\"\"\"\n    app = FirecrawlApp(api_key=os.environ[\"FIRECRAWL_API_KEY\"])\n\n    if mode == \"crawl\":\n        result = app.crawl_url(url, params={\n            \"limit\": max_pages,\n            \"scrapeOptions\": {\"formats\": [\"markdown\"]},\n        })\n        pages = [{\"markdown\": p.get(\"markdown\", \"\"), \"url\": p.get(\"url\")}\n                 for p in result.get(\"data\", [])]\n        return {\"pages\": pages, \"count\": len(pages)}\n\n    # Default: single-page scrape\n    result = app.scrape_url(url, params={\"formats\": [\"markdown\"]})\n    return {\n        \"markdown\": result.get(\"markdown\", \"\"),\n        \"metadata\": result.get(\"metadata\", {}),\n        \"links\": result.get(\"links\", []),\n    }\n```\n\n---\n\n### `brave_search`\n\n**Description:** Runs a web search query through the Brave Search API and returns structured result objects with titles, URLs, and snippets.\n\n| Field | Detail |\n|---|---|\n| **Input** | `query: str`, `count: int = 10`, `freshness: str = \"\"` |\n| **Output** | `list[dict]` each with `title`, `url`, `description`, `age` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/brave-search-mcp` server -- exposes `brave_web_search` and `brave_local_search` |\n\n```python\nimport os, httpx\n\nBRAVE_ENDPOINT = \"https://api.search.brave.com/res/v1/web/search\"\n\ndef main(query: str, count: int = 10, freshness: str = \"\") -> list[dict]:\n    \"\"\"Execute a Brave web search and return structured results.\"\"\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"X-Subscription-Token\": os.environ[\"BRAVE_API_KEY\"],\n    }\n    params = {\"q\": query, \"count\": min(count, 20)}\n    if freshness:\n        params[\"freshness\"] = freshness  # e.g. \"pd\" (past day), \"pw\", \"pm\"\n\n    resp = httpx.get(BRAVE_ENDPOINT, headers=headers, params=params, timeout=15)\n    resp.raise_for_status()\n\n    results = []\n    for item in resp.json().get(\"web\", {}).get(\"results\", []):\n        results.append({\n            \"title\": item.get(\"title\"),\n            \"url\": item.get(\"url\"),\n            \"description\": item.get(\"description\"),\n            \"age\": item.get(\"age\", \"\"),\n        })\n    return results\n```\n\n---\n\n### `puppeteer_screenshot`\n\n**Description:** Launches a headless browser via Puppeteer (through its MCP server or a local Node bridge) to capture a screenshot or extract JavaScript-rendered DOM content from a page.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `action: Literal[\"screenshot\", \"extract\"]`, `selector: str = \"body\"`, `viewport: dict = {\"width\": 1280, \"height\": 720}` |\n| **Output** | `dict` with `base64_image: str` (for screenshot) or `html: str` (for extract) |\n| **Key Dependencies** | `playwright` (Python) or Node `puppeteer` via subprocess |\n| **MCP Alternative** | `@anthropic/puppeteer-mcp` server -- exposes `puppeteer_navigate`, `puppeteer_screenshot`, `puppeteer_click`, `puppeteer_fill` |\n\n```python\nfrom playwright.async_api import async_playwright\nimport asyncio, base64\n\nasync def _run(url: str, action: str, selector: str, viewport: dict) -> dict:\n    async with async_playwright() as pw:\n        browser = await pw.chromium.launch(headless=True)\n        page = await browser.new_page(viewport_size=viewport)\n        await page.goto(url, wait_until=\"networkidle\")\n\n        if action == \"screenshot\":\n            buf = await page.screenshot(full_page=True)\n            await browser.close()\n            return {\"base64_image\": base64.b64encode(buf).decode()}\n\n        content = await page.inner_html(selector)\n        await browser.close()\n        return {\"html\": content}\n\ndef main(url: str, action: str = \"screenshot\", selector: str = \"body\",\n         viewport: dict | None = None) -> dict:\n    \"\"\"Capture a screenshot or extract rendered HTML from a URL.\"\"\"\n    vp = viewport or {\"width\": 1280, \"height\": 720}\n    return asyncio.run(_run(url, action, selector, vp))\n```\n\n---\n\n## File I/O\n\n### `csv_read_write`\n\n**Description:** Reads a CSV file into a list of dictionaries or writes a list of dictionaries out to CSV, handling encoding detection and BOM stripping automatically.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `mode: Literal[\"read\", \"write\"]`, `data: list[dict] = []`, `encoding: str = \"utf-8-sig\"` |\n| **Output** | `list[dict]` on read; `dict` with `rows_written: int, path: str` on write |\n| **Key Dependencies** | `csv` (stdlib), `chardet` (optional encoding detection) |\n| **MCP Alternative** | `@anthropic/filesystem-mcp` for raw read/write; CSV parsing done in-tool |\n\n```python\nimport csv, io, pathlib\n\ndef main(path: str, mode: str = \"read\", data: list[dict] | None = None,\n         encoding: str = \"utf-8-sig\") -> dict | list[dict]:\n    \"\"\"Read or write CSV files with automatic encoding handling.\"\"\"\n    p = pathlib.Path(path)\n\n    if mode == \"read\":\n        text = p.read_text(encoding=encoding)\n        reader = csv.DictReader(io.StringIO(text))\n        return [dict(row) for row in reader]\n\n    # Write mode\n    if not data:\n        raise ValueError(\"data is required for write mode\")\n    fieldnames = list(data[0].keys())\n    with p.open(\"w\", newline=\"\", encoding=encoding) as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerows(data)\n    return {\"rows_written\": len(data), \"path\": str(p.resolve())}\n```\n\n---\n\n### `json_read_write`\n\n**Description:** Reads a JSON or JSONL file into Python objects or writes Python objects out to JSON/JSONL, with optional pretty-printing and schema validation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `mode: Literal[\"read\", \"write\"]`, `data: Any = None`, `jsonl: bool = False`, `indent: int = 2` |\n| **Output** | Parsed object(s) on read; `dict` with `path: str, size_bytes: int` on write |\n| **Key Dependencies** | `json` (stdlib), `jsonschema` (optional validation) |\n| **MCP Alternative** | `@anthropic/filesystem-mcp` for raw I/O |\n\n```python\nimport json, pathlib\n\ndef main(path: str, mode: str = \"read\", data=None,\n         jsonl: bool = False, indent: int = 2):\n    \"\"\"Read or write JSON / JSONL files.\"\"\"\n    p = pathlib.Path(path)\n\n    if mode == \"read\":\n        text = p.read_text(encoding=\"utf-8\")\n        if jsonl:\n            return [json.loads(line) for line in text.splitlines() if line.strip()]\n        return json.loads(text)\n\n    # Write mode\n    if jsonl:\n        lines = [json.dumps(item, ensure_ascii=False) for item in data]\n        p.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n    else:\n        p.write_text(json.dumps(data, indent=indent, ensure_ascii=False),\n                      encoding=\"utf-8\")\n    return {\"path\": str(p.resolve()), \"size_bytes\": p.stat().st_size}\n```\n\n---\n\n### `apollo_enrich`\n\n**Description:** Enriches a company name/domain with company data and decision-maker contacts via the Apollo.io API. Returns structured company info, tech stack, and key contacts.\n\n| Field | Detail |\n|---|---|\n| **Input** | `company_name: str`, `domain: str = None` |\n| **Output** | `dict` with company data, tech stack, decision makers |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; direct HTTP API |\n\n---\n\n### `hunter_email_search`\n\n**Description:** Searches for email addresses at a given domain via the Hunter.io API. Returns verified contacts with confidence scores.\n\n| Field | Detail |\n|---|---|\n| **Input** | `domain: str`, `limit: int = 5` |\n| **Output** | `dict` with emails, patterns, organization info |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; direct HTTP API |\n\n---\n\n### `multi_dimension_scorer`\n\n**Description:** Scores a data record across N independent dimensions with configurable point values. Used for lead scoring, content quality assessment, or any multi-criteria evaluation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `record: dict`, `dimensions: list[dict]` (each with name, max_points, scoring_function) |\n| **Output** | `dict` with dimension breakdown and total score |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None |\n\n---\n\n### `email_sequence_generator`\n\n**Description:** Generates a multi-email sequence (outreach or nurture) using Claude API. Takes company/audience context and a sequence template, returns structured JSON with subject lines, bodies, and send timing.\n\n| Field | Detail |\n|---|---|\n| **Input** | `context: dict`, `sequence_template: str`, `email_count: int` |\n| **Output** | `dict` with sequence of emails (subject, body, send_day) |\n| **Key Dependencies** | `anthropic` |\n| **MCP Alternative** | Anthropic MCP |\n\n---\n\n### `pdf_extract`\n\n**Description:** Extracts text content, metadata, and optionally tables from a PDF file, returning structured output ready for LLM ingestion or data-pipeline processing.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `pages: str = \"all\"`, `extract_tables: bool = False` |\n| **Output** | `dict` with `text: str`, `pages: list[dict]`, `metadata: dict`, `tables: list` |\n| **Key Dependencies** | `pymupdf` (fitz), `pdfplumber` (for tables) |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport fitz  # pymupdf\n\ndef main(path: str, pages: str = \"all\", extract_tables: bool = False) -> dict:\n    \"\"\"Extract text and metadata from a PDF file.\"\"\"\n    doc = fitz.open(path)\n    metadata = dict(doc.metadata)\n\n    page_range = range(len(doc))\n    if pages != \"all\":\n        # Parse ranges like \"1-5\" or \"3,7,10-12\"\n        page_range = _parse_page_range(pages, len(doc))\n\n    extracted_pages = []\n    for i in page_range:\n        page = doc[i]\n        extracted_pages.append({\n            \"page_number\": i + 1,\n            \"text\": page.get_text(\"text\"),\n        })\n\n    result = {\n        \"text\": \"\\n\\n\".join(p[\"text\"] for p in extracted_pages),\n        \"pages\": extracted_pages,\n        \"metadata\": metadata,\n    }\n\n    if extract_tables:\n        import pdfplumber\n        with pdfplumber.open(path) as pdf:\n            result[\"tables\"] = []\n            for i in page_range:\n                for table in pdf.pages[i].extract_tables():\n                    result[\"tables\"].append({\"page\": i + 1, \"rows\": table})\n\n    return result\n\ndef _parse_page_range(spec: str, total: int) -> list[int]:\n    indices = []\n    for part in spec.split(\",\"):\n        if \"-\" in part:\n            start, end = part.split(\"-\", 1)\n            indices.extend(range(int(start) - 1, min(int(end), total)))\n        else:\n            indices.append(int(part) - 1)\n    return [i for i in indices if 0 <= i < total]\n```\n\n---\n\n## API Calls\n\n### `rest_client`\n\n**Description:** A generic REST API client with configurable retry logic, exponential backoff, header injection, and response normalization -- the universal building block for any HTTP-based integration.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `method: str = \"GET\"`, `headers: dict = {}`, `body: Any = None`, `retries: int = 3`, `backoff: float = 1.0`, `timeout: int = 30` |\n| **Output** | `dict` with `status: int`, `headers: dict`, `body: Any`, `elapsed_ms: float` |\n| **Key Dependencies** | `httpx`, `tenacity` |\n| **MCP Alternative** | `@anthropic/fetch-mcp` for simple GET/POST |\n\n```python\nimport httpx, time\nfrom tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception\n\ndef _is_retryable(exc):\n    if isinstance(exc, httpx.HTTPStatusError):\n        return exc.response.status_code in (429, 500, 502, 503, 504)\n    return isinstance(exc, (httpx.ConnectTimeout, httpx.ReadTimeout))\n\ndef main(url: str, method: str = \"GET\", headers: dict | None = None,\n         body=None, retries: int = 3, backoff: float = 1.0,\n         timeout: int = 30) -> dict:\n    \"\"\"Make an HTTP request with retry logic and exponential backoff.\"\"\"\n\n    @retry(\n        stop=stop_after_attempt(retries),\n        wait=wait_exponential(multiplier=backoff, min=1, max=30),\n        retry=retry_if_exception(_is_retryable),\n        reraise=True,\n    )\n    def _do_request():\n        t0 = time.monotonic()\n        resp = httpx.request(\n            method=method.upper(),\n            url=url,\n            headers=headers or {},\n            json=body if isinstance(body, (dict, list)) else None,\n            content=body if isinstance(body, (str, bytes)) else None,\n            timeout=timeout,\n        )\n        elapsed = (time.monotonic() - t0) * 1000\n        resp.raise_for_status()\n        try:\n            resp_body = resp.json()\n        except Exception:\n            resp_body = resp.text\n        return {\n            \"status\": resp.status_code,\n            \"headers\": dict(resp.headers),\n            \"body\": resp_body,\n            \"elapsed_ms\": round(elapsed, 2),\n        }\n\n    return _do_request()\n```\n\n---\n\n### `graphql_client`\n\n**Description:** Sends GraphQL queries and mutations to any endpoint, with variable substitution, error extraction, and the same retry semantics as `rest_client`.\n\n| Field | Detail |\n|---|---|\n| **Input** | `endpoint: str`, `query: str`, `variables: dict = {}`, `headers: dict = {}`, `retries: int = 3` |\n| **Output** | `dict` with `data: Any`, `errors: list | None`, `status: int` |\n| **Key Dependencies** | `httpx`, `tenacity` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport httpx\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\ndef main(endpoint: str, query: str, variables: dict | None = None,\n         headers: dict | None = None, retries: int = 3) -> dict:\n    \"\"\"Execute a GraphQL query or mutation with retry logic.\"\"\"\n\n    @retry(stop=stop_after_attempt(retries),\n           wait=wait_exponential(multiplier=1, min=1, max=15))\n    def _execute():\n        payload = {\"query\": query}\n        if variables:\n            payload[\"variables\"] = variables\n        resp = httpx.post(\n            endpoint,\n            json=payload,\n            headers={\"Content-Type\": \"application/json\", **(headers or {})},\n            timeout=30,\n        )\n        resp.raise_for_status()\n        result = resp.json()\n        return {\n            \"data\": result.get(\"data\"),\n            \"errors\": result.get(\"errors\"),\n            \"status\": resp.status_code,\n        }\n\n    return _execute()\n```\n\n---\n\n### `oauth_token_refresh`\n\n**Description:** Manages OAuth 2.0 token lifecycle -- obtains tokens via client_credentials or authorization_code grants, caches them, and transparently refreshes before expiry.\n\n| Field | Detail |\n|---|---|\n| **Input** | `token_url: str`, `client_id: str`, `client_secret: str`, `grant_type: str = \"client_credentials\"`, `refresh_token: str = \"\"`, `scopes: list[str] = []` |\n| **Output** | `dict` with `access_token: str`, `expires_in: int`, `token_type: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; typically embedded within other tools |\n\n```python\nimport httpx, time\n\n_token_cache: dict = {}\n\ndef main(token_url: str, client_id: str, client_secret: str,\n         grant_type: str = \"client_credentials\",\n         refresh_token: str = \"\", scopes: list[str] | None = None) -> dict:\n    \"\"\"Obtain or refresh an OAuth 2.0 access token.\"\"\"\n    cache_key = f\"{token_url}:{client_id}\"\n\n    # Return cached token if still valid\n    cached = _token_cache.get(cache_key)\n    if cached and cached[\"expires_at\"] > time.time() + 60:\n        return {\n            \"access_token\": cached[\"access_token\"],\n            \"expires_in\": int(cached[\"expires_at\"] - time.time()),\n            \"token_type\": cached[\"token_type\"],\n        }\n\n    data = {\"grant_type\": grant_type, \"client_id\": client_id,\n            \"client_secret\": client_secret}\n    if refresh_token:\n        data[\"refresh_token\"] = refresh_token\n    if scopes:\n        data[\"scope\"] = \" \".join(scopes)\n\n    resp = httpx.post(token_url, data=data, timeout=15)\n    resp.raise_for_status()\n    token_data = resp.json()\n\n    _token_cache[cache_key] = {\n        \"access_token\": token_data[\"access_token\"],\n        \"token_type\": token_data.get(\"token_type\", \"Bearer\"),\n        \"expires_at\": time.time() + token_data.get(\"expires_in\", 3600),\n    }\n    return {\n        \"access_token\": token_data[\"access_token\"],\n        \"expires_in\": token_data.get(\"expires_in\", 3600),\n        \"token_type\": token_data.get(\"token_type\", \"Bearer\"),\n    }\n```\n\n---\n\n## Data Processing\n\n### `filter_sort`\n\n**Description:** Applies filter predicates and multi-key sorting to a list of dictionaries, supporting comparison operators, regex matching, and null handling.\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `filters: list[dict]` (each with `field`, `op`, `value`), `sort_by: list[dict]` (each with `field`, `order`) |\n| **Output** | `list[dict]` -- filtered and sorted records |\n| **Key Dependencies** | `re` (stdlib) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\nimport re, operator\n\nOPS = {\n    \"eq\": operator.eq, \"ne\": operator.ne,\n    \"gt\": operator.gt, \"ge\": operator.ge,\n    \"lt\": operator.lt, \"le\": operator.le,\n    \"contains\": lambda a, b: b in str(a),\n    \"regex\": lambda a, b: bool(re.search(b, str(a))),\n    \"in\": lambda a, b: a in b,\n}\n\ndef main(data: list[dict], filters: list[dict] | None = None,\n         sort_by: list[dict] | None = None) -> list[dict]:\n    \"\"\"Filter and sort a list of dictionaries.\"\"\"\n    result = data\n\n    # Apply filters\n    for f in (filters or []):\n        op_fn = OPS.get(f[\"op\"], operator.eq)\n        result = [row for row in result if op_fn(row.get(f[\"field\"]), f[\"value\"])]\n\n    # Apply sorting\n    if sort_by:\n        for s in reversed(sort_by):\n            reverse = s.get(\"order\", \"asc\") == \"desc\"\n            result.sort(key=lambda row: (row.get(s[\"field\"]) is None,\n                                          row.get(s[\"field\"], \"\")),\n                        reverse=reverse)\n\n    return result\n```\n\n---\n\n### `dedup`\n\n**Description:** Removes duplicate records from a dataset based on one or more key fields, with configurable strategies for which duplicate to keep (first, last, or merge).\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `keys: list[str]`, `strategy: Literal[\"first\", \"last\", \"merge\"] = \"first\"` |\n| **Output** | `dict` with `unique: list[dict]`, `duplicates_removed: int` |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\ndef main(data: list[dict], keys: list[str],\n         strategy: str = \"first\") -> dict:\n    \"\"\"Deduplicate records by key fields.\"\"\"\n    seen: dict[tuple, dict] = {}\n    order: list[tuple] = []\n\n    for row in data:\n        key = tuple(row.get(k) for k in keys)\n        if key not in seen:\n            seen[key] = row\n            order.append(key)\n        elif strategy == \"last\":\n            seen[key] = row\n        elif strategy == \"merge\":\n            # Merge: later values fill in blanks only\n            for k, v in row.items():\n                if seen[key].get(k) in (None, \"\"):\n                    seen[key][k] = v\n\n    unique = [seen[k] for k in order]\n    return {\n        \"unique\": unique,\n        \"duplicates_removed\": len(data) - len(unique),\n    }\n```\n\n---\n\n### `transform_map`\n\n**Description:** Applies field-level transformations to every record in a dataset -- renaming columns, computing derived fields, type-casting, and applying template expressions.\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `mappings: list[dict]` (each with `source`, `target`, `transform`), `drop_unmapped: bool = False` |\n| **Output** | `list[dict]` -- transformed records |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\nfrom datetime import datetime\n\nTRANSFORMS = {\n    \"upper\": lambda v: str(v).upper(),\n    \"lower\": lambda v: str(v).lower(),\n    \"strip\": lambda v: str(v).strip(),\n    \"int\": lambda v: int(v) if v not in (None, \"\") else None,\n    \"float\": lambda v: float(v) if v not in (None, \"\") else None,\n    \"isodate\": lambda v: datetime.fromisoformat(str(v)).isoformat(),\n    \"bool\": lambda v: str(v).lower() in (\"true\", \"1\", \"yes\"),\n    \"default\": lambda v: v,\n}\n\ndef main(data: list[dict], mappings: list[dict],\n         drop_unmapped: bool = False) -> list[dict]:\n    \"\"\"Apply field-level transformations to each record.\"\"\"\n    results = []\n    for row in data:\n        new_row = {} if drop_unmapped else dict(row)\n        for m in mappings:\n            source_val = row.get(m[\"source\"])\n            transform_fn = TRANSFORMS.get(m.get(\"transform\", \"default\"),\n                                           TRANSFORMS[\"default\"])\n            new_row[m[\"target\"]] = transform_fn(source_val)\n        results.append(new_row)\n    return results\n```\n\n---\n\n## AI Processing\n\n### `llm_prompt`\n\n**Description:** Sends a prompt to an LLM provider (OpenAI, Anthropic, or compatible endpoint) with system instructions, returning the raw text completion and token usage metadata.\n\n| Field | Detail |\n|---|---|\n| **Input** | `prompt: str`, `system: str = \"\"`, `provider: Literal[\"openai\", \"anthropic\"] = \"anthropic\"`, `model: str = \"\"`, `max_tokens: int = 4096`, `temperature: float = 0.3` |\n| **Output** | `dict` with `text: str`, `model: str`, `usage: dict` |\n| **Key Dependencies** | `anthropic`, `openai` |\n| **MCP Alternative** | None; this IS the core LLM call |\n\n```python\nimport os\n\ndef main(prompt: str, system: str = \"\", provider: str = \"anthropic\",\n         model: str = \"\", max_tokens: int = 4096,\n         temperature: float = 0.3) -> dict:\n    \"\"\"Send a prompt to an LLM and return the completion.\"\"\"\n\n    if provider == \"anthropic\":\n        import anthropic\n        client = anthropic.Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n        resolved_model = model or \"claude-sonnet-4-20250514\"\n        msg = client.messages.create(\n            model=resolved_model,\n            max_tokens=max_tokens,\n            temperature=temperature,\n            system=system or \"You are a helpful assistant.\",\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n        )\n        return {\n            \"text\": msg.content[0].text,\n            \"model\": resolved_model,\n            \"usage\": {\"input_tokens\": msg.usage.input_tokens,\n                      \"output_tokens\": msg.usage.output_tokens},\n        }\n\n    # OpenAI / compatible\n    import openai\n    client = openai.OpenAI(api_key=os.environ.get(\"OPENAI_API_KEY\"))\n    resolved_model = model or \"gpt-4o\"\n    messages = []\n    if system:\n        messages.append({\"role\": \"system\", \"content\": system})\n    messages.append({\"role\": \"user\", \"content\": prompt})\n\n    resp = client.chat.completions.create(\n        model=resolved_model, messages=messages,\n        max_tokens=max_tokens, temperature=temperature,\n    )\n    choice = resp.choices[0]\n    return {\n        \"text\": choice.message.content,\n        \"model\": resolved_model,\n        \"usage\": {\"input_tokens\": resp.usage.prompt_tokens,\n                  \"output_tokens\": resp.usage.completion_tokens},\n    }\n```\n\n---\n\n### `structured_extract`\n\n**Description:** Sends content to an LLM with a JSON schema instruction, parses the response into a validated Python object, and retries with corrective prompts if the response fails schema validation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `content: str`, `schema: dict` (JSON Schema), `instructions: str = \"\"`, `retries: int = 2` |\n| **Output** | `dict` with `data: Any` (validated), `raw: str`, `attempts: int` |\n| **Key Dependencies** | `anthropic` or `openai`, `jsonschema` |\n| **MCP Alternative** | None; core LLM extraction pattern |\n\n```python\nimport json, os\nfrom jsonschema import validate, ValidationError\n\ndef main(content: str, schema: dict, instructions: str = \"\",\n         retries: int = 2) -> dict:\n    \"\"\"Extract structured data from content using an LLM with schema validation.\"\"\"\n    import anthropic\n    client = anthropic.Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n\n    system_prompt = (\n        \"Extract information from the provided content and return ONLY valid JSON \"\n        \"matching the schema below. No markdown fences, no commentary.\\n\\n\"\n        f\"Schema:\\n```json\\n{json.dumps(schema, indent=2)}\\n```\"\n    )\n    if instructions:\n        system_prompt += f\"\\n\\nAdditional instructions: {instructions}\"\n\n    user_content = content\n    for attempt in range(1, retries + 2):\n        msg = client.messages.create(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            temperature=0.0,\n            system=system_prompt,\n            messages=[{\"role\": \"user\", \"content\": user_content}],\n        )\n        raw = msg.content[0].text.strip()\n\n        # Strip markdown fences if present\n        if raw.startswith(\"```\"):\n            raw = raw.split(\"\\n\", 1)[1].rsplit(\"```\", 1)[0].strip()\n\n        try:\n            parsed = json.loads(raw)\n            validate(instance=parsed, schema=schema)\n            return {\"data\": parsed, \"raw\": raw, \"attempts\": attempt}\n        except (json.JSONDecodeError, ValidationError) as exc:\n            if attempt > retries:\n                raise ValueError(f\"Failed after {attempt} attempts: {exc}\") from exc\n            user_content = (\n                f\"Your previous response was invalid: {exc}\\n\\n\"\n                f\"Original content:\\n{content}\\n\\n\"\n                \"Please try again, returning ONLY valid JSON.\"\n            )\n\n    raise RuntimeError(\"Unreachable\")\n```\n\n---\n\n### `embedding_generate`\n\n**Description:** Generates vector embeddings for one or more text inputs using OpenAI, Voyage, or a local model, returning arrays ready for storage in a vector database.\n\n| Field | Detail |\n|---|---|\n| **Input** | `texts: list[str]`, `provider: Literal[\"openai\", \"voyage\"] = \"openai\"`, `model: str = \"\"` |\n| **Output** | `dict` with `embeddings: list[list[float]]`, `model: str`, `dimensions: int` |\n| **Key Dependencies** | `openai` or `voyageai` |\n| **MCP Alternative** | None standard |\n\n```python\nimport os\n\ndef main(texts: list[str], provider: str = \"openai\",\n         model: str = \"\") -> dict:\n    \"\"\"Generate vector embeddings for text inputs.\"\"\"\n\n    if provider == \"openai\":\n        import openai\n        client = openai.OpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])\n        resolved = model or \"text-embedding-3-small\"\n        resp = client.embeddings.create(input=texts, model=resolved)\n        vecs = [item.embedding for item in resp.data]\n        return {\n            \"embeddings\": vecs,\n            \"model\": resolved,\n            \"dimensions\": len(vecs[0]) if vecs else 0,\n        }\n\n    if provider == \"voyage\":\n        import voyageai\n        client = voyageai.Client(api_key=os.environ[\"VOYAGE_API_KEY\"])\n        resolved = model or \"voyage-2\"\n        resp = client.embed(texts, model=resolved)\n        return {\n            \"embeddings\": resp.embeddings,\n            \"model\": resolved,\n            \"dimensions\": len(resp.embeddings[0]) if resp.embeddings else 0,\n        }\n\n    raise ValueError(f\"Unsupported provider: {provider}\")\n```\n\n---\n\n## Notifications\n\n### `slack_notify`\n\n**Description:** Sends a message to a Slack channel or thread via the Slack Web API or an incoming webhook, supporting Block Kit for rich formatting.\n\n| Field | Detail |\n|---|---|\n| **Input** | `channel: str`, `text: str`, `blocks: list[dict] = []`, `thread_ts: str = \"\"`, `use_webhook: bool = False` |\n| **Output** | `dict` with `ok: bool`, `ts: str`, `channel: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/slack-mcp` server -- exposes `slack_post_message`, `slack_list_channels`, etc. |\n\n```python\nimport os, httpx\n\ndef main(channel: str, text: str, blocks: list[dict] | None = None,\n         thread_ts: str = \"\", use_webhook: bool = False) -> dict:\n    \"\"\"Send a Slack message to a channel or thread.\"\"\"\n\n    if use_webhook:\n        webhook_url = os.environ[\"SLACK_WEBHOOK_URL\"]\n        payload = {\"text\": text}\n        if blocks:\n            payload[\"blocks\"] = blocks\n        resp = httpx.post(webhook_url, json=payload, timeout=10)\n        resp.raise_for_status()\n        return {\"ok\": True, \"ts\": \"\", \"channel\": channel}\n\n    token = os.environ[\"SLACK_BOT_TOKEN\"]\n    payload = {\"channel\": channel, \"text\": text}\n    if blocks:\n        payload[\"blocks\"] = blocks\n    if thread_ts:\n        payload[\"thread_ts\"] = thread_ts\n\n    resp = httpx.post(\n        \"https://slack.com/api/chat.postMessage\",\n        json=payload,\n        headers={\"Authorization\": f\"Bearer {token}\",\n                 \"Content-Type\": \"application/json\"},\n        timeout=10,\n    )\n    data = resp.json()\n    return {\"ok\": data.get(\"ok\", False), \"ts\": data.get(\"ts\", \"\"),\n            \"channel\": data.get(\"channel\", channel)}\n```\n\n---\n\n### `discord_webhook`\n\n**Description:** Posts a message or embed to a Discord channel via a webhook URL, with support for rich embeds, username overrides, and file attachments.\n\n| Field | Detail |\n|---|---|\n| **Input** | `webhook_url: str`, `content: str = \"\"`, `embeds: list[dict] = []`, `username: str = \"\"` |\n| **Output** | `dict` with `status: int`, `success: bool` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport httpx\n\ndef main(webhook_url: str, content: str = \"\", embeds: list[dict] | None = None,\n         username: str = \"\") -> dict:\n    \"\"\"Send a message or embed to Discord via webhook.\"\"\"\n    payload: dict = {}\n    if content:\n        payload[\"content\"] = content\n    if embeds:\n        payload[\"embeds\"] = embeds\n    if username:\n        payload[\"username\"] = username\n\n    if not payload:\n        raise ValueError(\"Must provide content or embeds\")\n\n    resp = httpx.post(webhook_url, json=payload, timeout=10)\n    return {\n        \"status\": resp.status_code,\n        \"success\": resp.status_code in (200, 204),\n    }\n```\n\n---\n\n### `email_send`\n\n**Description:** Sends an email via SMTP or a transactional email API (SendGrid, Resend), supporting HTML body, plain-text fallback, and file attachments.\n\n| Field | Detail |\n|---|---|\n| **Input** | `to: list[str]`, `subject: str`, `body_html: str = \"\"`, `body_text: str = \"\"`, `provider: Literal[\"smtp\", \"sendgrid\", \"resend\"] = \"resend\"`, `from_addr: str = \"\"` |\n| **Output** | `dict` with `success: bool`, `message_id: str` |\n| **Key Dependencies** | `httpx`, `smtplib` (stdlib) |\n| **MCP Alternative** | None standard |\n\n```python\nimport os, httpx\n\ndef main(to: list[str], subject: str, body_html: str = \"\",\n         body_text: str = \"\", provider: str = \"resend\",\n         from_addr: str = \"\") -> dict:\n    \"\"\"Send an email via a transactional provider or SMTP.\"\"\"\n    sender = from_addr or os.environ.get(\"EMAIL_FROM\", \"noreply@example.com\")\n\n    if provider == \"resend\":\n        resp = httpx.post(\n            \"https://api.resend.com/emails\",\n            headers={\"Authorization\": f\"Bearer {os.environ['RESEND_API_KEY']}\",\n                     \"Content-Type\": \"application/json\"},\n            json={\n                \"from\": sender, \"to\": to, \"subject\": subject,\n                \"html\": body_html or f\"<pre>{body_text}</pre>\",\n                \"text\": body_text or \"\",\n            },\n            timeout=15,\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        return {\"success\": True, \"message_id\": data.get(\"id\", \"\")}\n\n    if provider == \"sendgrid\":\n        resp = httpx.post(\n            \"https://api.sendgrid.com/v3/mail/send\",\n            headers={\"Authorization\": f\"Bearer {os.environ['SENDGRID_API_KEY']}\",\n                     \"Content-Type\": \"application/json\"},\n            json={\n                \"personalizations\": [{\"to\": [{\"email\": e} for e in to]}],\n                \"from\": {\"email\": sender},\n                \"subject\": subject,\n                \"content\": [\n                    {\"type\": \"text/plain\", \"value\": body_text or \"\"},\n                    {\"type\": \"text/html\", \"value\": body_html or body_text},\n                ],\n            },\n            timeout=15,\n        )\n        resp.raise_for_status()\n        return {\"success\": True, \"message_id\": resp.headers.get(\"X-Message-Id\", \"\")}\n\n    # SMTP fallback\n    import smtplib\n    from email.mime.text import MIMEText\n    msg = MIMEText(body_html or body_text, \"html\" if body_html else \"plain\")\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = sender\n    msg[\"To\"] = \", \".join(to)\n    with smtplib.SMTP(os.environ[\"SMTP_HOST\"], int(os.environ.get(\"SMTP_PORT\", 587))) as s:\n        s.starttls()\n        s.login(os.environ[\"SMTP_USER\"], os.environ[\"SMTP_PASS\"])\n        s.send_message(msg)\n    return {\"success\": True, \"message_id\": \"\"}\n```\n\n---\n\n## Git Operations\n\n### `git_commit_push`\n\n**Description:** Stages specified files (or all changes), creates a commit with a conventional-commit message, and optionally pushes to the remote -- the bread-and-butter of automated code updates.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo_path: str`, `message: str`, `files: list[str] = []`, `push: bool = True`, `branch: str = \"\"` |\n| **Output** | `dict` with `commit_sha: str`, `branch: str`, `pushed: bool` |\n| **Key Dependencies** | `subprocess` (stdlib), `git` CLI |\n| **MCP Alternative** | `@anthropic/git-mcp` server -- exposes `git_status`, `git_commit`, `git_push`, etc. |\n\n```python\nimport subprocess\n\ndef _git(repo: str, *args: str) -> str:\n    result = subprocess.run(\n        [\"git\", *args], cwd=repo,\n        capture_output=True, text=True, check=True,\n    )\n    return result.stdout.strip()\n\ndef main(repo_path: str, message: str, files: list[str] | None = None,\n         push: bool = True, branch: str = \"\") -> dict:\n    \"\"\"Stage, commit, and optionally push changes in a git repo.\"\"\"\n    if branch:\n        try:\n            _git(repo_path, \"checkout\", branch)\n        except subprocess.CalledProcessError:\n            _git(repo_path, \"checkout\", \"-b\", branch)\n\n    # Stage\n    if files:\n        for f in files:\n            _git(repo_path, \"add\", f)\n    else:\n        _git(repo_path, \"add\", \"-A\")\n\n    # Commit\n    _git(repo_path, \"commit\", \"-m\", message)\n    sha = _git(repo_path, \"rev-parse\", \"HEAD\")\n\n    current_branch = _git(repo_path, \"rev-parse\", \"--abbrev-ref\", \"HEAD\")\n\n    pushed = False\n    if push:\n        _git(repo_path, \"push\", \"-u\", \"origin\", current_branch)\n        pushed = True\n\n    return {\"commit_sha\": sha, \"branch\": current_branch, \"pushed\": pushed}\n```\n\n---\n\n### `git_branch_manage`\n\n**Description:** Creates, lists, switches, or deletes branches in a local repository, with optional remote tracking setup.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo_path: str`, `action: Literal[\"create\", \"switch\", \"delete\", \"list\"]`, `branch: str = \"\"`, `from_ref: str = \"main\"` |\n| **Output** | `dict` with `branch: str`, `action: str`, `branches: list[str]` (for list action) |\n| **Key Dependencies** | `subprocess` (stdlib), `git` CLI |\n| **MCP Alternative** | `@anthropic/git-mcp` |\n\n```python\nimport subprocess\n\ndef _git(repo: str, *args: str) -> str:\n    result = subprocess.run(\n        [\"git\", *args], cwd=repo,\n        capture_output=True, text=True, check=True,\n    )\n    return result.stdout.strip()\n\ndef main(repo_path: str, action: str = \"list\", branch: str = \"\",\n         from_ref: str = \"main\") -> dict:\n    \"\"\"Create, switch, delete, or list branches.\"\"\"\n\n    if action == \"list\":\n        raw = _git(repo_path, \"branch\", \"-a\")\n        branches = [b.strip().lstrip(\"* \") for b in raw.splitlines()]\n        return {\"action\": \"list\", \"branches\": branches, \"branch\": \"\"}\n\n    if not branch:\n        raise ValueError(\"branch name required for create/switch/delete\")\n\n    if action == \"create\":\n        _git(repo_path, \"checkout\", \"-b\", branch, from_ref)\n        return {\"action\": \"create\", \"branch\": branch, \"branches\": []}\n\n    if action == \"switch\":\n        _git(repo_path, \"checkout\", branch)\n        return {\"action\": \"switch\", \"branch\": branch, \"branches\": []}\n\n    if action == \"delete\":\n        _git(repo_path, \"branch\", \"-d\", branch)\n        return {\"action\": \"delete\", \"branch\": branch, \"branches\": []}\n\n    raise ValueError(f\"Unknown action: {action}\")\n```\n\n---\n\n### `git_read_repo`\n\n**Description:** Reads repository structure and file contents without requiring a local clone, using either a local path or the GitHub API for remote repos.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str` (local path or `owner/repo`), `path: str = \"\"`, `ref: str = \"main\"`, `depth: int = 2` |\n| **Output** | `dict` with `tree: list[dict]`, `file_content: str` (if path points to a file) |\n| **Key Dependencies** | `httpx`, `subprocess` (stdlib) |\n| **MCP Alternative** | `@anthropic/github-mcp` for remote repos |\n\n```python\nimport os, httpx, subprocess, pathlib\n\ndef main(repo: str, path: str = \"\", ref: str = \"main\",\n         depth: int = 2) -> dict:\n    \"\"\"Read repository tree or file contents.\"\"\"\n\n    # Local repo\n    if os.path.isdir(repo):\n        target = pathlib.Path(repo) / path\n        if target.is_file():\n            return {\"tree\": [], \"file_content\": target.read_text(encoding=\"utf-8\")}\n        tree = []\n        for item in sorted(target.rglob(\"*\")):\n            rel = item.relative_to(pathlib.Path(repo))\n            if len(rel.parts) <= depth and not any(p.startswith(\".\") for p in rel.parts):\n                tree.append({\n                    \"path\": str(rel), \"type\": \"dir\" if item.is_dir() else \"file\",\n                    \"size\": item.stat().st_size if item.is_file() else 0,\n                })\n        return {\"tree\": tree, \"file_content\": \"\"}\n\n    # Remote GitHub repo\n    headers = {\"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n               \"Accept\": \"application/vnd.github.v3+json\"}\n    base = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    resp = httpx.get(base, headers=headers, params={\"ref\": ref}, timeout=15)\n    resp.raise_for_status()\n    data = resp.json()\n\n    if isinstance(data, dict) and data.get(\"type\") == \"file\":\n        import base64\n        content = base64.b64decode(data[\"content\"]).decode(\"utf-8\")\n        return {\"tree\": [], \"file_content\": content}\n\n    tree = [{\"path\": item[\"path\"], \"type\": item[\"type\"], \"size\": item.get(\"size\", 0)}\n            for item in data]\n    return {\"tree\": tree, \"file_content\": \"\"}\n```\n\n---\n\n## GitHub API\n\n### `github_create_issue`\n\n**Description:** Creates a new issue on a GitHub repository with title, body, labels, assignees, and milestone, returning the full issue URL and number.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str` (`owner/repo`), `title: str`, `body: str = \"\"`, `labels: list[str] = []`, `assignees: list[str] = []`, `milestone: int = 0` |\n| **Output** | `dict` with `number: int`, `url: str`, `html_url: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/github-mcp` -- exposes `create_issue` |\n\n```python\nimport os, httpx\n\ndef main(repo: str, title: str, body: str = \"\",\n         labels: list[str] | None = None,\n         assignees: list[str] | None = None,\n         milestone: int = 0) -> dict:\n    \"\"\"Create a GitHub issue.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    payload: dict = {\"title\": title, \"body\": body}\n    if labels:\n        payload[\"labels\"] = labels\n    if assignees:\n        payload[\"assignees\"] = assignees\n    if milestone:\n        payload[\"milestone\"] = milestone\n\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/issues\",\n        headers=headers, json=payload, timeout=15,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    return {\n        \"number\": data[\"number\"],\n        \"url\": data[\"url\"],\n        \"html_url\": data[\"html_url\"],\n    }\n```\n\n---\n\n### `github_pull_request`\n\n**Description:** Creates or updates a pull request, with support for draft PRs, auto-merge labels, and reviewer assignment.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str`, `title: str`, `body: str`, `head: str`, `base: str = \"main\"`, `draft: bool = False`, `reviewers: list[str] = []` |\n| **Output** | `dict` with `number: int`, `html_url: str`, `state: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/github-mcp` -- exposes `create_pull_request` |\n\n```python\nimport os, httpx\n\ndef main(repo: str, title: str, body: str, head: str,\n         base: str = \"main\", draft: bool = False,\n         reviewers: list[str] | None = None) -> dict:\n    \"\"\"Create a GitHub pull request.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    payload = {\n        \"title\": title, \"body\": body,\n        \"head\": head, \"base\": base, \"draft\": draft,\n    }\n\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/pulls\",\n        headers=headers, json=payload, timeout=15,\n    )\n    resp.raise_for_status()\n    pr = resp.json()\n\n    # Request reviewers if specified\n    if reviewers:\n        httpx.post(\n            f\"https://api.github.com/repos/{repo}/pulls/{pr['number']}/requested_reviewers\",\n            headers=headers,\n            json={\"reviewers\": reviewers},\n            timeout=10,\n        )\n\n    return {\n        \"number\": pr[\"number\"],\n        \"html_url\": pr[\"html_url\"],\n        \"state\": pr[\"state\"],\n    }\n```\n\n---\n\n### `github_workflow_dispatch`\n\n**Description:** Triggers a GitHub Actions workflow via the repository dispatch or workflow_dispatch API, passing custom inputs and waiting optionally for completion status.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str`, `workflow_id: str` (filename or ID), `ref: str = \"main\"`, `inputs: dict = {}`, `wait: bool = False`, `timeout: int = 300` |\n| **Output** | `dict` with `triggered: bool`, `run_id: int`, `status: str`, `conclusion: str` |\n| **Key Dependencies** | `httpx`, `time` (stdlib) |\n| **MCP Alternative** | `@anthropic/github-mcp` |\n\n```python\nimport os, httpx, time\n\ndef main(repo: str, workflow_id: str, ref: str = \"main\",\n         inputs: dict | None = None, wait: bool = False,\n         timeout: int = 300) -> dict:\n    \"\"\"Trigger a GitHub Actions workflow and optionally wait for completion.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    # Trigger\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/actions/workflows/{workflow_id}/dispatches\",\n        headers=headers,\n        json={\"ref\": ref, \"inputs\": inputs or {}},\n        timeout=15,\n    )\n    resp.raise_for_status()\n\n    if not wait:\n        return {\"triggered\": True, \"run_id\": 0, \"status\": \"queued\", \"conclusion\": \"\"}\n\n    # Poll for the new run\n    time.sleep(3)\n    deadline = time.time() + timeout\n    while time.time() < deadline:\n        runs_resp = httpx.get(\n            f\"https://api.github.com/repos/{repo}/actions/workflows/{workflow_id}/runs\",\n            headers=headers, params={\"branch\": ref, \"per_page\": 1},\n            timeout=15,\n        )\n        runs = runs_resp.json().get(\"workflow_runs\", [])\n        if runs:\n            run = runs[0]\n            if run[\"status\"] == \"completed\":\n                return {\n                    \"triggered\": True, \"run_id\": run[\"id\"],\n                    \"status\": run[\"status\"], \"conclusion\": run[\"conclusion\"],\n                }\n        time.sleep(10)\n\n    return {\"triggered\": True, \"run_id\": 0, \"status\": \"timeout\", \"conclusion\": \"\"}\n```\n\n---\n\n## Database Operations\n\n### `supabase_query`\n\n**Description:** Executes queries against a Supabase project using the PostgREST API -- supports select, insert, update, upsert, and delete with filter chaining.\n\n| Field | Detail |\n|---|---|\n| **Input** | `table: str`, `action: Literal[\"select\", \"insert\", \"update\", \"upsert\", \"delete\"]`, `data: dict | list[dict] = {}`, `filters: list[dict] = []`, `select_columns: str = \"*\"`, `limit: int = 100` |\n| **Output** | `dict` with `data: list[dict]`, `count: int`, `status: int` |\n| **Key Dependencies** | `supabase` (supabase-py) |\n| **MCP Alternative** | `@anthropic/supabase-mcp` server |\n\n```python\nimport os\nfrom supabase import create_client\n\ndef main(table: str, action: str = \"select\", data=None,\n         filters: list[dict] | None = None,\n         select_columns: str = \"*\", limit: int = 100) -> dict:\n    \"\"\"Execute a Supabase database operation.\"\"\"\n    client = create_client(\n        os.environ[\"SUPABASE_URL\"],\n        os.environ[\"SUPABASE_SERVICE_KEY\"],\n    )\n\n    query = client.table(table)\n\n    if action == \"select\":\n        query = query.select(select_columns)\n        for f in (filters or []):\n            query = getattr(query, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = query.limit(limit).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"insert\":\n        result = query.insert(data).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 201}\n\n    if action == \"upsert\":\n        result = query.upsert(data).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"update\":\n        q = query.update(data)\n        for f in (filters or []):\n            q = getattr(q, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = q.execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"delete\":\n        q = query.delete()\n        for f in (filters or []):\n            q = getattr(q, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = q.execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    raise ValueError(f\"Unknown action: {action}\")\n```\n\n---\n\n### `sqlite_query`\n\n**Description:** Opens (or creates) a local SQLite database and executes arbitrary SQL, returning rows as dictionaries -- ideal for lightweight local state, caching, and intermediate pipeline storage.\n\n| Field | Detail |\n|---|---|\n| **Input** | `db_path: str`, `sql: str`, `params: list = []`, `mode: Literal[\"query\", \"execute\", \"script\"] = \"query\"` |\n| **Output** | `dict` with `rows: list[dict]`, `rowcount: int`, `lastrowid: int` |\n| **Key Dependencies** | `sqlite3` (stdlib) |\n| **MCP Alternative** | `@anthropic/sqlite-mcp` server |\n\n```python\nimport sqlite3\n\ndef main(db_path: str, sql: str, params: list | None = None,\n         mode: str = \"query\") -> dict:\n    \"\"\"Execute SQL against a SQLite database.\"\"\"\n    conn = sqlite3.connect(db_path)\n    conn.row_factory = sqlite3.Row\n    cur = conn.cursor()\n\n    try:\n        if mode == \"script\":\n            cur.executescript(sql)\n            conn.commit()\n            return {\"rows\": [], \"rowcount\": cur.rowcount, \"lastrowid\": cur.lastrowid}\n\n        if mode == \"execute\":\n            cur.execute(sql, params or [])\n            conn.commit()\n            return {\"rows\": [], \"rowcount\": cur.rowcount, \"lastrowid\": cur.lastrowid}\n\n        # query mode\n        cur.execute(sql, params or [])\n        rows = [dict(row) for row in cur.fetchall()]\n        return {\"rows\": rows, \"rowcount\": len(rows), \"lastrowid\": 0}\n\n    finally:\n        conn.close()\n```\n\n---\n\n### `airtable_ops`\n\n**Description:** Reads, creates, updates, or deletes records in an Airtable base, handling pagination and field-type coercion automatically.\n\n| Field | Detail |\n|---|---|\n| **Input** | `base_id: str`, `table_name: str`, `action: Literal[\"list\", \"create\", \"update\", \"delete\"]`, `records: list[dict] = []`, `filter_formula: str = \"\"`, `max_records: int = 100` |\n| **Output** | `dict` with `records: list[dict]`, `count: int` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport os, httpx\n\nBASE_URL = \"https://api.airtable.com/v0\"\n\ndef _headers():\n    return {\n        \"Authorization\": f\"Bearer {os.environ['AIRTABLE_API_KEY']}\",\n        \"Content-Type\": \"application/json\",\n    }\n\ndef main(base_id: str, table_name: str, action: str = \"list\",\n         records: list[dict] | None = None,\n         filter_formula: str = \"\", max_records: int = 100) -> dict:\n    \"\"\"Perform CRUD operations on Airtable records.\"\"\"\n    url = f\"{BASE_URL}/{base_id}/{table_name}\"\n\n    if action == \"list\":\n        params: dict = {\"maxRecords\": max_records}\n        if filter_formula:\n            params[\"filterByFormula\"] = filter_formula\n        all_records, offset = [], None\n        while True:\n            if offset:\n                params[\"offset\"] = offset\n            resp = httpx.get(url, headers=_headers(), params=params, timeout=15)\n            resp.raise_for_status()\n            data = resp.json()\n            all_records.extend(data.get(\"records\", []))\n            offset = data.get(\"offset\")\n            if not offset or len(all_records) >= max_records:\n                break\n        return {\"records\": all_records, \"count\": len(all_records)}\n\n    if action == \"create\":\n        payload = {\"records\": [{\"fields\": r} for r in (records or [])]}\n        resp = httpx.post(url, headers=_headers(), json=payload, timeout=15)\n        resp.raise_for_status()\n        created = resp.json().get(\"records\", [])\n        return {\"records\": created, \"count\": len(created)}\n\n    if action == \"update\":\n        payload = {\"records\": records or []}  # expects [{\"id\": ..., \"fields\": {...}}]\n        resp = httpx.patch(url, headers=_headers(), json=payload, timeout=15)\n        resp.raise_for_status()\n        updated = resp.json().get(\"records\", [])\n        return {\"records\": updated, \"count\": len(updated)}\n\n    if action == \"delete\":\n        ids = [r if isinstance(r, str) else r.get(\"id\") for r in (records or [])]\n        resp = httpx.delete(url, headers=_headers(),\n                            params={\"records[]\": ids}, timeout=15)\n        resp.raise_for_status()\n        return {\"records\": resp.json().get(\"records\", []),\n\n[Showing lines 1-1444 of 4333 (50.0KB limit). Use offset=1445 to continue.]"}],"details":{"truncation":{"content":"# WAT Systems Factory -- Reusable Tool Pattern Catalog\n\n> **Version:** 0.1.0-seed\n> **Maintainer:** WAT Systems Factory / Agent HQ\n> **Purpose:** Canonical reference of composable tool patterns that factory-generated workflows can assemble into pipelines. Each pattern is self-contained, testable, and convertible to an MCP tool or n8n node.\n\n---\n\n## Table of Contents\n\n1. [Web Scraping & Search](#web-scraping--search)\n2. [File I/O](#file-io)\n3. [API Calls](#api-calls)\n4. [Data Processing](#data-processing)\n5. [AI Processing](#ai-processing)\n6. [Notifications](#notifications)\n7. [Git Operations](#git-operations)\n8. [GitHub API](#github-api)\n9. [Database Operations](#database-operations)\n10. [Media Processing](#media-processing)\n11. [n8n Conversion](#n8n-conversion)\n12. [Agent Teams Coordination](#agent-teams-coordination)\n13. [GitHub Agent HQ Interaction](#github-agent-hq-interaction)\n\n---\n\n## Web Scraping & Search\n\n### `firecrawl_scrape`\n\n**Description:** Scrapes a single URL or crawls an entire domain via the Firecrawl API, returning clean Markdown-formatted content suitable for downstream LLM consumption.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `mode: Literal[\"scrape\", \"crawl\"]`, `max_pages: int = 50`, `selectors: list[str] = []` |\n| **Output** | `dict` with keys `markdown: str`, `metadata: dict`, `links: list[str]` |\n| **Key Dependencies** | `firecrawl-py`, `httpx` |\n| **MCP Alternative** | `@anthropic/firecrawl-mcp` server -- exposes `firecrawl_scrape` and `firecrawl_crawl` tools directly |\n\n```python\nimport os\nfrom firecrawl import FirecrawlApp\n\ndef main(url: str, mode: str = \"scrape\", max_pages: int = 50,\n         selectors: list[str] | None = None) -> dict:\n    \"\"\"Scrape or crawl a URL via Firecrawl and return Markdown content.\"\"\"\n    app = FirecrawlApp(api_key=os.environ[\"FIRECRAWL_API_KEY\"])\n\n    if mode == \"crawl\":\n        result = app.crawl_url(url, params={\n            \"limit\": max_pages,\n            \"scrapeOptions\": {\"formats\": [\"markdown\"]},\n        })\n        pages = [{\"markdown\": p.get(\"markdown\", \"\"), \"url\": p.get(\"url\")}\n                 for p in result.get(\"data\", [])]\n        return {\"pages\": pages, \"count\": len(pages)}\n\n    # Default: single-page scrape\n    result = app.scrape_url(url, params={\"formats\": [\"markdown\"]})\n    return {\n        \"markdown\": result.get(\"markdown\", \"\"),\n        \"metadata\": result.get(\"metadata\", {}),\n        \"links\": result.get(\"links\", []),\n    }\n```\n\n---\n\n### `brave_search`\n\n**Description:** Runs a web search query through the Brave Search API and returns structured result objects with titles, URLs, and snippets.\n\n| Field | Detail |\n|---|---|\n| **Input** | `query: str`, `count: int = 10`, `freshness: str = \"\"` |\n| **Output** | `list[dict]` each with `title`, `url`, `description`, `age` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/brave-search-mcp` server -- exposes `brave_web_search` and `brave_local_search` |\n\n```python\nimport os, httpx\n\nBRAVE_ENDPOINT = \"https://api.search.brave.com/res/v1/web/search\"\n\ndef main(query: str, count: int = 10, freshness: str = \"\") -> list[dict]:\n    \"\"\"Execute a Brave web search and return structured results.\"\"\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"X-Subscription-Token\": os.environ[\"BRAVE_API_KEY\"],\n    }\n    params = {\"q\": query, \"count\": min(count, 20)}\n    if freshness:\n        params[\"freshness\"] = freshness  # e.g. \"pd\" (past day), \"pw\", \"pm\"\n\n    resp = httpx.get(BRAVE_ENDPOINT, headers=headers, params=params, timeout=15)\n    resp.raise_for_status()\n\n    results = []\n    for item in resp.json().get(\"web\", {}).get(\"results\", []):\n        results.append({\n            \"title\": item.get(\"title\"),\n            \"url\": item.get(\"url\"),\n            \"description\": item.get(\"description\"),\n            \"age\": item.get(\"age\", \"\"),\n        })\n    return results\n```\n\n---\n\n### `puppeteer_screenshot`\n\n**Description:** Launches a headless browser via Puppeteer (through its MCP server or a local Node bridge) to capture a screenshot or extract JavaScript-rendered DOM content from a page.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `action: Literal[\"screenshot\", \"extract\"]`, `selector: str = \"body\"`, `viewport: dict = {\"width\": 1280, \"height\": 720}` |\n| **Output** | `dict` with `base64_image: str` (for screenshot) or `html: str` (for extract) |\n| **Key Dependencies** | `playwright` (Python) or Node `puppeteer` via subprocess |\n| **MCP Alternative** | `@anthropic/puppeteer-mcp` server -- exposes `puppeteer_navigate`, `puppeteer_screenshot`, `puppeteer_click`, `puppeteer_fill` |\n\n```python\nfrom playwright.async_api import async_playwright\nimport asyncio, base64\n\nasync def _run(url: str, action: str, selector: str, viewport: dict) -> dict:\n    async with async_playwright() as pw:\n        browser = await pw.chromium.launch(headless=True)\n        page = await browser.new_page(viewport_size=viewport)\n        await page.goto(url, wait_until=\"networkidle\")\n\n        if action == \"screenshot\":\n            buf = await page.screenshot(full_page=True)\n            await browser.close()\n            return {\"base64_image\": base64.b64encode(buf).decode()}\n\n        content = await page.inner_html(selector)\n        await browser.close()\n        return {\"html\": content}\n\ndef main(url: str, action: str = \"screenshot\", selector: str = \"body\",\n         viewport: dict | None = None) -> dict:\n    \"\"\"Capture a screenshot or extract rendered HTML from a URL.\"\"\"\n    vp = viewport or {\"width\": 1280, \"height\": 720}\n    return asyncio.run(_run(url, action, selector, vp))\n```\n\n---\n\n## File I/O\n\n### `csv_read_write`\n\n**Description:** Reads a CSV file into a list of dictionaries or writes a list of dictionaries out to CSV, handling encoding detection and BOM stripping automatically.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `mode: Literal[\"read\", \"write\"]`, `data: list[dict] = []`, `encoding: str = \"utf-8-sig\"` |\n| **Output** | `list[dict]` on read; `dict` with `rows_written: int, path: str` on write |\n| **Key Dependencies** | `csv` (stdlib), `chardet` (optional encoding detection) |\n| **MCP Alternative** | `@anthropic/filesystem-mcp` for raw read/write; CSV parsing done in-tool |\n\n```python\nimport csv, io, pathlib\n\ndef main(path: str, mode: str = \"read\", data: list[dict] | None = None,\n         encoding: str = \"utf-8-sig\") -> dict | list[dict]:\n    \"\"\"Read or write CSV files with automatic encoding handling.\"\"\"\n    p = pathlib.Path(path)\n\n    if mode == \"read\":\n        text = p.read_text(encoding=encoding)\n        reader = csv.DictReader(io.StringIO(text))\n        return [dict(row) for row in reader]\n\n    # Write mode\n    if not data:\n        raise ValueError(\"data is required for write mode\")\n    fieldnames = list(data[0].keys())\n    with p.open(\"w\", newline=\"\", encoding=encoding) as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n        writer.writerows(data)\n    return {\"rows_written\": len(data), \"path\": str(p.resolve())}\n```\n\n---\n\n### `json_read_write`\n\n**Description:** Reads a JSON or JSONL file into Python objects or writes Python objects out to JSON/JSONL, with optional pretty-printing and schema validation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `mode: Literal[\"read\", \"write\"]`, `data: Any = None`, `jsonl: bool = False`, `indent: int = 2` |\n| **Output** | Parsed object(s) on read; `dict` with `path: str, size_bytes: int` on write |\n| **Key Dependencies** | `json` (stdlib), `jsonschema` (optional validation) |\n| **MCP Alternative** | `@anthropic/filesystem-mcp` for raw I/O |\n\n```python\nimport json, pathlib\n\ndef main(path: str, mode: str = \"read\", data=None,\n         jsonl: bool = False, indent: int = 2):\n    \"\"\"Read or write JSON / JSONL files.\"\"\"\n    p = pathlib.Path(path)\n\n    if mode == \"read\":\n        text = p.read_text(encoding=\"utf-8\")\n        if jsonl:\n            return [json.loads(line) for line in text.splitlines() if line.strip()]\n        return json.loads(text)\n\n    # Write mode\n    if jsonl:\n        lines = [json.dumps(item, ensure_ascii=False) for item in data]\n        p.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n    else:\n        p.write_text(json.dumps(data, indent=indent, ensure_ascii=False),\n                      encoding=\"utf-8\")\n    return {\"path\": str(p.resolve()), \"size_bytes\": p.stat().st_size}\n```\n\n---\n\n### `apollo_enrich`\n\n**Description:** Enriches a company name/domain with company data and decision-maker contacts via the Apollo.io API. Returns structured company info, tech stack, and key contacts.\n\n| Field | Detail |\n|---|---|\n| **Input** | `company_name: str`, `domain: str = None` |\n| **Output** | `dict` with company data, tech stack, decision makers |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; direct HTTP API |\n\n---\n\n### `hunter_email_search`\n\n**Description:** Searches for email addresses at a given domain via the Hunter.io API. Returns verified contacts with confidence scores.\n\n| Field | Detail |\n|---|---|\n| **Input** | `domain: str`, `limit: int = 5` |\n| **Output** | `dict` with emails, patterns, organization info |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; direct HTTP API |\n\n---\n\n### `multi_dimension_scorer`\n\n**Description:** Scores a data record across N independent dimensions with configurable point values. Used for lead scoring, content quality assessment, or any multi-criteria evaluation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `record: dict`, `dimensions: list[dict]` (each with name, max_points, scoring_function) |\n| **Output** | `dict` with dimension breakdown and total score |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None |\n\n---\n\n### `email_sequence_generator`\n\n**Description:** Generates a multi-email sequence (outreach or nurture) using Claude API. Takes company/audience context and a sequence template, returns structured JSON with subject lines, bodies, and send timing.\n\n| Field | Detail |\n|---|---|\n| **Input** | `context: dict`, `sequence_template: str`, `email_count: int` |\n| **Output** | `dict` with sequence of emails (subject, body, send_day) |\n| **Key Dependencies** | `anthropic` |\n| **MCP Alternative** | Anthropic MCP |\n\n---\n\n### `pdf_extract`\n\n**Description:** Extracts text content, metadata, and optionally tables from a PDF file, returning structured output ready for LLM ingestion or data-pipeline processing.\n\n| Field | Detail |\n|---|---|\n| **Input** | `path: str`, `pages: str = \"all\"`, `extract_tables: bool = False` |\n| **Output** | `dict` with `text: str`, `pages: list[dict]`, `metadata: dict`, `tables: list` |\n| **Key Dependencies** | `pymupdf` (fitz), `pdfplumber` (for tables) |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport fitz  # pymupdf\n\ndef main(path: str, pages: str = \"all\", extract_tables: bool = False) -> dict:\n    \"\"\"Extract text and metadata from a PDF file.\"\"\"\n    doc = fitz.open(path)\n    metadata = dict(doc.metadata)\n\n    page_range = range(len(doc))\n    if pages != \"all\":\n        # Parse ranges like \"1-5\" or \"3,7,10-12\"\n        page_range = _parse_page_range(pages, len(doc))\n\n    extracted_pages = []\n    for i in page_range:\n        page = doc[i]\n        extracted_pages.append({\n            \"page_number\": i + 1,\n            \"text\": page.get_text(\"text\"),\n        })\n\n    result = {\n        \"text\": \"\\n\\n\".join(p[\"text\"] for p in extracted_pages),\n        \"pages\": extracted_pages,\n        \"metadata\": metadata,\n    }\n\n    if extract_tables:\n        import pdfplumber\n        with pdfplumber.open(path) as pdf:\n            result[\"tables\"] = []\n            for i in page_range:\n                for table in pdf.pages[i].extract_tables():\n                    result[\"tables\"].append({\"page\": i + 1, \"rows\": table})\n\n    return result\n\ndef _parse_page_range(spec: str, total: int) -> list[int]:\n    indices = []\n    for part in spec.split(\",\"):\n        if \"-\" in part:\n            start, end = part.split(\"-\", 1)\n            indices.extend(range(int(start) - 1, min(int(end), total)))\n        else:\n            indices.append(int(part) - 1)\n    return [i for i in indices if 0 <= i < total]\n```\n\n---\n\n## API Calls\n\n### `rest_client`\n\n**Description:** A generic REST API client with configurable retry logic, exponential backoff, header injection, and response normalization -- the universal building block for any HTTP-based integration.\n\n| Field | Detail |\n|---|---|\n| **Input** | `url: str`, `method: str = \"GET\"`, `headers: dict = {}`, `body: Any = None`, `retries: int = 3`, `backoff: float = 1.0`, `timeout: int = 30` |\n| **Output** | `dict` with `status: int`, `headers: dict`, `body: Any`, `elapsed_ms: float` |\n| **Key Dependencies** | `httpx`, `tenacity` |\n| **MCP Alternative** | `@anthropic/fetch-mcp` for simple GET/POST |\n\n```python\nimport httpx, time\nfrom tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception\n\ndef _is_retryable(exc):\n    if isinstance(exc, httpx.HTTPStatusError):\n        return exc.response.status_code in (429, 500, 502, 503, 504)\n    return isinstance(exc, (httpx.ConnectTimeout, httpx.ReadTimeout))\n\ndef main(url: str, method: str = \"GET\", headers: dict | None = None,\n         body=None, retries: int = 3, backoff: float = 1.0,\n         timeout: int = 30) -> dict:\n    \"\"\"Make an HTTP request with retry logic and exponential backoff.\"\"\"\n\n    @retry(\n        stop=stop_after_attempt(retries),\n        wait=wait_exponential(multiplier=backoff, min=1, max=30),\n        retry=retry_if_exception(_is_retryable),\n        reraise=True,\n    )\n    def _do_request():\n        t0 = time.monotonic()\n        resp = httpx.request(\n            method=method.upper(),\n            url=url,\n            headers=headers or {},\n            json=body if isinstance(body, (dict, list)) else None,\n            content=body if isinstance(body, (str, bytes)) else None,\n            timeout=timeout,\n        )\n        elapsed = (time.monotonic() - t0) * 1000\n        resp.raise_for_status()\n        try:\n            resp_body = resp.json()\n        except Exception:\n            resp_body = resp.text\n        return {\n            \"status\": resp.status_code,\n            \"headers\": dict(resp.headers),\n            \"body\": resp_body,\n            \"elapsed_ms\": round(elapsed, 2),\n        }\n\n    return _do_request()\n```\n\n---\n\n### `graphql_client`\n\n**Description:** Sends GraphQL queries and mutations to any endpoint, with variable substitution, error extraction, and the same retry semantics as `rest_client`.\n\n| Field | Detail |\n|---|---|\n| **Input** | `endpoint: str`, `query: str`, `variables: dict = {}`, `headers: dict = {}`, `retries: int = 3` |\n| **Output** | `dict` with `data: Any`, `errors: list | None`, `status: int` |\n| **Key Dependencies** | `httpx`, `tenacity` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport httpx\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\ndef main(endpoint: str, query: str, variables: dict | None = None,\n         headers: dict | None = None, retries: int = 3) -> dict:\n    \"\"\"Execute a GraphQL query or mutation with retry logic.\"\"\"\n\n    @retry(stop=stop_after_attempt(retries),\n           wait=wait_exponential(multiplier=1, min=1, max=15))\n    def _execute():\n        payload = {\"query\": query}\n        if variables:\n            payload[\"variables\"] = variables\n        resp = httpx.post(\n            endpoint,\n            json=payload,\n            headers={\"Content-Type\": \"application/json\", **(headers or {})},\n            timeout=30,\n        )\n        resp.raise_for_status()\n        result = resp.json()\n        return {\n            \"data\": result.get(\"data\"),\n            \"errors\": result.get(\"errors\"),\n            \"status\": resp.status_code,\n        }\n\n    return _execute()\n```\n\n---\n\n### `oauth_token_refresh`\n\n**Description:** Manages OAuth 2.0 token lifecycle -- obtains tokens via client_credentials or authorization_code grants, caches them, and transparently refreshes before expiry.\n\n| Field | Detail |\n|---|---|\n| **Input** | `token_url: str`, `client_id: str`, `client_secret: str`, `grant_type: str = \"client_credentials\"`, `refresh_token: str = \"\"`, `scopes: list[str] = []` |\n| **Output** | `dict` with `access_token: str`, `expires_in: int`, `token_type: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None; typically embedded within other tools |\n\n```python\nimport httpx, time\n\n_token_cache: dict = {}\n\ndef main(token_url: str, client_id: str, client_secret: str,\n         grant_type: str = \"client_credentials\",\n         refresh_token: str = \"\", scopes: list[str] | None = None) -> dict:\n    \"\"\"Obtain or refresh an OAuth 2.0 access token.\"\"\"\n    cache_key = f\"{token_url}:{client_id}\"\n\n    # Return cached token if still valid\n    cached = _token_cache.get(cache_key)\n    if cached and cached[\"expires_at\"] > time.time() + 60:\n        return {\n            \"access_token\": cached[\"access_token\"],\n            \"expires_in\": int(cached[\"expires_at\"] - time.time()),\n            \"token_type\": cached[\"token_type\"],\n        }\n\n    data = {\"grant_type\": grant_type, \"client_id\": client_id,\n            \"client_secret\": client_secret}\n    if refresh_token:\n        data[\"refresh_token\"] = refresh_token\n    if scopes:\n        data[\"scope\"] = \" \".join(scopes)\n\n    resp = httpx.post(token_url, data=data, timeout=15)\n    resp.raise_for_status()\n    token_data = resp.json()\n\n    _token_cache[cache_key] = {\n        \"access_token\": token_data[\"access_token\"],\n        \"token_type\": token_data.get(\"token_type\", \"Bearer\"),\n        \"expires_at\": time.time() + token_data.get(\"expires_in\", 3600),\n    }\n    return {\n        \"access_token\": token_data[\"access_token\"],\n        \"expires_in\": token_data.get(\"expires_in\", 3600),\n        \"token_type\": token_data.get(\"token_type\", \"Bearer\"),\n    }\n```\n\n---\n\n## Data Processing\n\n### `filter_sort`\n\n**Description:** Applies filter predicates and multi-key sorting to a list of dictionaries, supporting comparison operators, regex matching, and null handling.\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `filters: list[dict]` (each with `field`, `op`, `value`), `sort_by: list[dict]` (each with `field`, `order`) |\n| **Output** | `list[dict]` -- filtered and sorted records |\n| **Key Dependencies** | `re` (stdlib) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\nimport re, operator\n\nOPS = {\n    \"eq\": operator.eq, \"ne\": operator.ne,\n    \"gt\": operator.gt, \"ge\": operator.ge,\n    \"lt\": operator.lt, \"le\": operator.le,\n    \"contains\": lambda a, b: b in str(a),\n    \"regex\": lambda a, b: bool(re.search(b, str(a))),\n    \"in\": lambda a, b: a in b,\n}\n\ndef main(data: list[dict], filters: list[dict] | None = None,\n         sort_by: list[dict] | None = None) -> list[dict]:\n    \"\"\"Filter and sort a list of dictionaries.\"\"\"\n    result = data\n\n    # Apply filters\n    for f in (filters or []):\n        op_fn = OPS.get(f[\"op\"], operator.eq)\n        result = [row for row in result if op_fn(row.get(f[\"field\"]), f[\"value\"])]\n\n    # Apply sorting\n    if sort_by:\n        for s in reversed(sort_by):\n            reverse = s.get(\"order\", \"asc\") == \"desc\"\n            result.sort(key=lambda row: (row.get(s[\"field\"]) is None,\n                                          row.get(s[\"field\"], \"\")),\n                        reverse=reverse)\n\n    return result\n```\n\n---\n\n### `dedup`\n\n**Description:** Removes duplicate records from a dataset based on one or more key fields, with configurable strategies for which duplicate to keep (first, last, or merge).\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `keys: list[str]`, `strategy: Literal[\"first\", \"last\", \"merge\"] = \"first\"` |\n| **Output** | `dict` with `unique: list[dict]`, `duplicates_removed: int` |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\ndef main(data: list[dict], keys: list[str],\n         strategy: str = \"first\") -> dict:\n    \"\"\"Deduplicate records by key fields.\"\"\"\n    seen: dict[tuple, dict] = {}\n    order: list[tuple] = []\n\n    for row in data:\n        key = tuple(row.get(k) for k in keys)\n        if key not in seen:\n            seen[key] = row\n            order.append(key)\n        elif strategy == \"last\":\n            seen[key] = row\n        elif strategy == \"merge\":\n            # Merge: later values fill in blanks only\n            for k, v in row.items():\n                if seen[key].get(k) in (None, \"\"):\n                    seen[key][k] = v\n\n    unique = [seen[k] for k in order]\n    return {\n        \"unique\": unique,\n        \"duplicates_removed\": len(data) - len(unique),\n    }\n```\n\n---\n\n### `transform_map`\n\n**Description:** Applies field-level transformations to every record in a dataset -- renaming columns, computing derived fields, type-casting, and applying template expressions.\n\n| Field | Detail |\n|---|---|\n| **Input** | `data: list[dict]`, `mappings: list[dict]` (each with `source`, `target`, `transform`), `drop_unmapped: bool = False` |\n| **Output** | `list[dict]` -- transformed records |\n| **Key Dependencies** | None (stdlib only) |\n| **MCP Alternative** | None; pure logic tool |\n\n```python\nfrom datetime import datetime\n\nTRANSFORMS = {\n    \"upper\": lambda v: str(v).upper(),\n    \"lower\": lambda v: str(v).lower(),\n    \"strip\": lambda v: str(v).strip(),\n    \"int\": lambda v: int(v) if v not in (None, \"\") else None,\n    \"float\": lambda v: float(v) if v not in (None, \"\") else None,\n    \"isodate\": lambda v: datetime.fromisoformat(str(v)).isoformat(),\n    \"bool\": lambda v: str(v).lower() in (\"true\", \"1\", \"yes\"),\n    \"default\": lambda v: v,\n}\n\ndef main(data: list[dict], mappings: list[dict],\n         drop_unmapped: bool = False) -> list[dict]:\n    \"\"\"Apply field-level transformations to each record.\"\"\"\n    results = []\n    for row in data:\n        new_row = {} if drop_unmapped else dict(row)\n        for m in mappings:\n            source_val = row.get(m[\"source\"])\n            transform_fn = TRANSFORMS.get(m.get(\"transform\", \"default\"),\n                                           TRANSFORMS[\"default\"])\n            new_row[m[\"target\"]] = transform_fn(source_val)\n        results.append(new_row)\n    return results\n```\n\n---\n\n## AI Processing\n\n### `llm_prompt`\n\n**Description:** Sends a prompt to an LLM provider (OpenAI, Anthropic, or compatible endpoint) with system instructions, returning the raw text completion and token usage metadata.\n\n| Field | Detail |\n|---|---|\n| **Input** | `prompt: str`, `system: str = \"\"`, `provider: Literal[\"openai\", \"anthropic\"] = \"anthropic\"`, `model: str = \"\"`, `max_tokens: int = 4096`, `temperature: float = 0.3` |\n| **Output** | `dict` with `text: str`, `model: str`, `usage: dict` |\n| **Key Dependencies** | `anthropic`, `openai` |\n| **MCP Alternative** | None; this IS the core LLM call |\n\n```python\nimport os\n\ndef main(prompt: str, system: str = \"\", provider: str = \"anthropic\",\n         model: str = \"\", max_tokens: int = 4096,\n         temperature: float = 0.3) -> dict:\n    \"\"\"Send a prompt to an LLM and return the completion.\"\"\"\n\n    if provider == \"anthropic\":\n        import anthropic\n        client = anthropic.Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n        resolved_model = model or \"claude-sonnet-4-20250514\"\n        msg = client.messages.create(\n            model=resolved_model,\n            max_tokens=max_tokens,\n            temperature=temperature,\n            system=system or \"You are a helpful assistant.\",\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n        )\n        return {\n            \"text\": msg.content[0].text,\n            \"model\": resolved_model,\n            \"usage\": {\"input_tokens\": msg.usage.input_tokens,\n                      \"output_tokens\": msg.usage.output_tokens},\n        }\n\n    # OpenAI / compatible\n    import openai\n    client = openai.OpenAI(api_key=os.environ.get(\"OPENAI_API_KEY\"))\n    resolved_model = model or \"gpt-4o\"\n    messages = []\n    if system:\n        messages.append({\"role\": \"system\", \"content\": system})\n    messages.append({\"role\": \"user\", \"content\": prompt})\n\n    resp = client.chat.completions.create(\n        model=resolved_model, messages=messages,\n        max_tokens=max_tokens, temperature=temperature,\n    )\n    choice = resp.choices[0]\n    return {\n        \"text\": choice.message.content,\n        \"model\": resolved_model,\n        \"usage\": {\"input_tokens\": resp.usage.prompt_tokens,\n                  \"output_tokens\": resp.usage.completion_tokens},\n    }\n```\n\n---\n\n### `structured_extract`\n\n**Description:** Sends content to an LLM with a JSON schema instruction, parses the response into a validated Python object, and retries with corrective prompts if the response fails schema validation.\n\n| Field | Detail |\n|---|---|\n| **Input** | `content: str`, `schema: dict` (JSON Schema), `instructions: str = \"\"`, `retries: int = 2` |\n| **Output** | `dict` with `data: Any` (validated), `raw: str`, `attempts: int` |\n| **Key Dependencies** | `anthropic` or `openai`, `jsonschema` |\n| **MCP Alternative** | None; core LLM extraction pattern |\n\n```python\nimport json, os\nfrom jsonschema import validate, ValidationError\n\ndef main(content: str, schema: dict, instructions: str = \"\",\n         retries: int = 2) -> dict:\n    \"\"\"Extract structured data from content using an LLM with schema validation.\"\"\"\n    import anthropic\n    client = anthropic.Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n\n    system_prompt = (\n        \"Extract information from the provided content and return ONLY valid JSON \"\n        \"matching the schema below. No markdown fences, no commentary.\\n\\n\"\n        f\"Schema:\\n```json\\n{json.dumps(schema, indent=2)}\\n```\"\n    )\n    if instructions:\n        system_prompt += f\"\\n\\nAdditional instructions: {instructions}\"\n\n    user_content = content\n    for attempt in range(1, retries + 2):\n        msg = client.messages.create(\n            model=\"claude-sonnet-4-20250514\",\n            max_tokens=4096,\n            temperature=0.0,\n            system=system_prompt,\n            messages=[{\"role\": \"user\", \"content\": user_content}],\n        )\n        raw = msg.content[0].text.strip()\n\n        # Strip markdown fences if present\n        if raw.startswith(\"```\"):\n            raw = raw.split(\"\\n\", 1)[1].rsplit(\"```\", 1)[0].strip()\n\n        try:\n            parsed = json.loads(raw)\n            validate(instance=parsed, schema=schema)\n            return {\"data\": parsed, \"raw\": raw, \"attempts\": attempt}\n        except (json.JSONDecodeError, ValidationError) as exc:\n            if attempt > retries:\n                raise ValueError(f\"Failed after {attempt} attempts: {exc}\") from exc\n            user_content = (\n                f\"Your previous response was invalid: {exc}\\n\\n\"\n                f\"Original content:\\n{content}\\n\\n\"\n                \"Please try again, returning ONLY valid JSON.\"\n            )\n\n    raise RuntimeError(\"Unreachable\")\n```\n\n---\n\n### `embedding_generate`\n\n**Description:** Generates vector embeddings for one or more text inputs using OpenAI, Voyage, or a local model, returning arrays ready for storage in a vector database.\n\n| Field | Detail |\n|---|---|\n| **Input** | `texts: list[str]`, `provider: Literal[\"openai\", \"voyage\"] = \"openai\"`, `model: str = \"\"` |\n| **Output** | `dict` with `embeddings: list[list[float]]`, `model: str`, `dimensions: int` |\n| **Key Dependencies** | `openai` or `voyageai` |\n| **MCP Alternative** | None standard |\n\n```python\nimport os\n\ndef main(texts: list[str], provider: str = \"openai\",\n         model: str = \"\") -> dict:\n    \"\"\"Generate vector embeddings for text inputs.\"\"\"\n\n    if provider == \"openai\":\n        import openai\n        client = openai.OpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])\n        resolved = model or \"text-embedding-3-small\"\n        resp = client.embeddings.create(input=texts, model=resolved)\n        vecs = [item.embedding for item in resp.data]\n        return {\n            \"embeddings\": vecs,\n            \"model\": resolved,\n            \"dimensions\": len(vecs[0]) if vecs else 0,\n        }\n\n    if provider == \"voyage\":\n        import voyageai\n        client = voyageai.Client(api_key=os.environ[\"VOYAGE_API_KEY\"])\n        resolved = model or \"voyage-2\"\n        resp = client.embed(texts, model=resolved)\n        return {\n            \"embeddings\": resp.embeddings,\n            \"model\": resolved,\n            \"dimensions\": len(resp.embeddings[0]) if resp.embeddings else 0,\n        }\n\n    raise ValueError(f\"Unsupported provider: {provider}\")\n```\n\n---\n\n## Notifications\n\n### `slack_notify`\n\n**Description:** Sends a message to a Slack channel or thread via the Slack Web API or an incoming webhook, supporting Block Kit for rich formatting.\n\n| Field | Detail |\n|---|---|\n| **Input** | `channel: str`, `text: str`, `blocks: list[dict] = []`, `thread_ts: str = \"\"`, `use_webhook: bool = False` |\n| **Output** | `dict` with `ok: bool`, `ts: str`, `channel: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/slack-mcp` server -- exposes `slack_post_message`, `slack_list_channels`, etc. |\n\n```python\nimport os, httpx\n\ndef main(channel: str, text: str, blocks: list[dict] | None = None,\n         thread_ts: str = \"\", use_webhook: bool = False) -> dict:\n    \"\"\"Send a Slack message to a channel or thread.\"\"\"\n\n    if use_webhook:\n        webhook_url = os.environ[\"SLACK_WEBHOOK_URL\"]\n        payload = {\"text\": text}\n        if blocks:\n            payload[\"blocks\"] = blocks\n        resp = httpx.post(webhook_url, json=payload, timeout=10)\n        resp.raise_for_status()\n        return {\"ok\": True, \"ts\": \"\", \"channel\": channel}\n\n    token = os.environ[\"SLACK_BOT_TOKEN\"]\n    payload = {\"channel\": channel, \"text\": text}\n    if blocks:\n        payload[\"blocks\"] = blocks\n    if thread_ts:\n        payload[\"thread_ts\"] = thread_ts\n\n    resp = httpx.post(\n        \"https://slack.com/api/chat.postMessage\",\n        json=payload,\n        headers={\"Authorization\": f\"Bearer {token}\",\n                 \"Content-Type\": \"application/json\"},\n        timeout=10,\n    )\n    data = resp.json()\n    return {\"ok\": data.get(\"ok\", False), \"ts\": data.get(\"ts\", \"\"),\n            \"channel\": data.get(\"channel\", channel)}\n```\n\n---\n\n### `discord_webhook`\n\n**Description:** Posts a message or embed to a Discord channel via a webhook URL, with support for rich embeds, username overrides, and file attachments.\n\n| Field | Detail |\n|---|---|\n| **Input** | `webhook_url: str`, `content: str = \"\"`, `embeds: list[dict] = []`, `username: str = \"\"` |\n| **Output** | `dict` with `status: int`, `success: bool` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport httpx\n\ndef main(webhook_url: str, content: str = \"\", embeds: list[dict] | None = None,\n         username: str = \"\") -> dict:\n    \"\"\"Send a message or embed to Discord via webhook.\"\"\"\n    payload: dict = {}\n    if content:\n        payload[\"content\"] = content\n    if embeds:\n        payload[\"embeds\"] = embeds\n    if username:\n        payload[\"username\"] = username\n\n    if not payload:\n        raise ValueError(\"Must provide content or embeds\")\n\n    resp = httpx.post(webhook_url, json=payload, timeout=10)\n    return {\n        \"status\": resp.status_code,\n        \"success\": resp.status_code in (200, 204),\n    }\n```\n\n---\n\n### `email_send`\n\n**Description:** Sends an email via SMTP or a transactional email API (SendGrid, Resend), supporting HTML body, plain-text fallback, and file attachments.\n\n| Field | Detail |\n|---|---|\n| **Input** | `to: list[str]`, `subject: str`, `body_html: str = \"\"`, `body_text: str = \"\"`, `provider: Literal[\"smtp\", \"sendgrid\", \"resend\"] = \"resend\"`, `from_addr: str = \"\"` |\n| **Output** | `dict` with `success: bool`, `message_id: str` |\n| **Key Dependencies** | `httpx`, `smtplib` (stdlib) |\n| **MCP Alternative** | None standard |\n\n```python\nimport os, httpx\n\ndef main(to: list[str], subject: str, body_html: str = \"\",\n         body_text: str = \"\", provider: str = \"resend\",\n         from_addr: str = \"\") -> dict:\n    \"\"\"Send an email via a transactional provider or SMTP.\"\"\"\n    sender = from_addr or os.environ.get(\"EMAIL_FROM\", \"noreply@example.com\")\n\n    if provider == \"resend\":\n        resp = httpx.post(\n            \"https://api.resend.com/emails\",\n            headers={\"Authorization\": f\"Bearer {os.environ['RESEND_API_KEY']}\",\n                     \"Content-Type\": \"application/json\"},\n            json={\n                \"from\": sender, \"to\": to, \"subject\": subject,\n                \"html\": body_html or f\"<pre>{body_text}</pre>\",\n                \"text\": body_text or \"\",\n            },\n            timeout=15,\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        return {\"success\": True, \"message_id\": data.get(\"id\", \"\")}\n\n    if provider == \"sendgrid\":\n        resp = httpx.post(\n            \"https://api.sendgrid.com/v3/mail/send\",\n            headers={\"Authorization\": f\"Bearer {os.environ['SENDGRID_API_KEY']}\",\n                     \"Content-Type\": \"application/json\"},\n            json={\n                \"personalizations\": [{\"to\": [{\"email\": e} for e in to]}],\n                \"from\": {\"email\": sender},\n                \"subject\": subject,\n                \"content\": [\n                    {\"type\": \"text/plain\", \"value\": body_text or \"\"},\n                    {\"type\": \"text/html\", \"value\": body_html or body_text},\n                ],\n            },\n            timeout=15,\n        )\n        resp.raise_for_status()\n        return {\"success\": True, \"message_id\": resp.headers.get(\"X-Message-Id\", \"\")}\n\n    # SMTP fallback\n    import smtplib\n    from email.mime.text import MIMEText\n    msg = MIMEText(body_html or body_text, \"html\" if body_html else \"plain\")\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = sender\n    msg[\"To\"] = \", \".join(to)\n    with smtplib.SMTP(os.environ[\"SMTP_HOST\"], int(os.environ.get(\"SMTP_PORT\", 587))) as s:\n        s.starttls()\n        s.login(os.environ[\"SMTP_USER\"], os.environ[\"SMTP_PASS\"])\n        s.send_message(msg)\n    return {\"success\": True, \"message_id\": \"\"}\n```\n\n---\n\n## Git Operations\n\n### `git_commit_push`\n\n**Description:** Stages specified files (or all changes), creates a commit with a conventional-commit message, and optionally pushes to the remote -- the bread-and-butter of automated code updates.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo_path: str`, `message: str`, `files: list[str] = []`, `push: bool = True`, `branch: str = \"\"` |\n| **Output** | `dict` with `commit_sha: str`, `branch: str`, `pushed: bool` |\n| **Key Dependencies** | `subprocess` (stdlib), `git` CLI |\n| **MCP Alternative** | `@anthropic/git-mcp` server -- exposes `git_status`, `git_commit`, `git_push`, etc. |\n\n```python\nimport subprocess\n\ndef _git(repo: str, *args: str) -> str:\n    result = subprocess.run(\n        [\"git\", *args], cwd=repo,\n        capture_output=True, text=True, check=True,\n    )\n    return result.stdout.strip()\n\ndef main(repo_path: str, message: str, files: list[str] | None = None,\n         push: bool = True, branch: str = \"\") -> dict:\n    \"\"\"Stage, commit, and optionally push changes in a git repo.\"\"\"\n    if branch:\n        try:\n            _git(repo_path, \"checkout\", branch)\n        except subprocess.CalledProcessError:\n            _git(repo_path, \"checkout\", \"-b\", branch)\n\n    # Stage\n    if files:\n        for f in files:\n            _git(repo_path, \"add\", f)\n    else:\n        _git(repo_path, \"add\", \"-A\")\n\n    # Commit\n    _git(repo_path, \"commit\", \"-m\", message)\n    sha = _git(repo_path, \"rev-parse\", \"HEAD\")\n\n    current_branch = _git(repo_path, \"rev-parse\", \"--abbrev-ref\", \"HEAD\")\n\n    pushed = False\n    if push:\n        _git(repo_path, \"push\", \"-u\", \"origin\", current_branch)\n        pushed = True\n\n    return {\"commit_sha\": sha, \"branch\": current_branch, \"pushed\": pushed}\n```\n\n---\n\n### `git_branch_manage`\n\n**Description:** Creates, lists, switches, or deletes branches in a local repository, with optional remote tracking setup.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo_path: str`, `action: Literal[\"create\", \"switch\", \"delete\", \"list\"]`, `branch: str = \"\"`, `from_ref: str = \"main\"` |\n| **Output** | `dict` with `branch: str`, `action: str`, `branches: list[str]` (for list action) |\n| **Key Dependencies** | `subprocess` (stdlib), `git` CLI |\n| **MCP Alternative** | `@anthropic/git-mcp` |\n\n```python\nimport subprocess\n\ndef _git(repo: str, *args: str) -> str:\n    result = subprocess.run(\n        [\"git\", *args], cwd=repo,\n        capture_output=True, text=True, check=True,\n    )\n    return result.stdout.strip()\n\ndef main(repo_path: str, action: str = \"list\", branch: str = \"\",\n         from_ref: str = \"main\") -> dict:\n    \"\"\"Create, switch, delete, or list branches.\"\"\"\n\n    if action == \"list\":\n        raw = _git(repo_path, \"branch\", \"-a\")\n        branches = [b.strip().lstrip(\"* \") for b in raw.splitlines()]\n        return {\"action\": \"list\", \"branches\": branches, \"branch\": \"\"}\n\n    if not branch:\n        raise ValueError(\"branch name required for create/switch/delete\")\n\n    if action == \"create\":\n        _git(repo_path, \"checkout\", \"-b\", branch, from_ref)\n        return {\"action\": \"create\", \"branch\": branch, \"branches\": []}\n\n    if action == \"switch\":\n        _git(repo_path, \"checkout\", branch)\n        return {\"action\": \"switch\", \"branch\": branch, \"branches\": []}\n\n    if action == \"delete\":\n        _git(repo_path, \"branch\", \"-d\", branch)\n        return {\"action\": \"delete\", \"branch\": branch, \"branches\": []}\n\n    raise ValueError(f\"Unknown action: {action}\")\n```\n\n---\n\n### `git_read_repo`\n\n**Description:** Reads repository structure and file contents without requiring a local clone, using either a local path or the GitHub API for remote repos.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str` (local path or `owner/repo`), `path: str = \"\"`, `ref: str = \"main\"`, `depth: int = 2` |\n| **Output** | `dict` with `tree: list[dict]`, `file_content: str` (if path points to a file) |\n| **Key Dependencies** | `httpx`, `subprocess` (stdlib) |\n| **MCP Alternative** | `@anthropic/github-mcp` for remote repos |\n\n```python\nimport os, httpx, subprocess, pathlib\n\ndef main(repo: str, path: str = \"\", ref: str = \"main\",\n         depth: int = 2) -> dict:\n    \"\"\"Read repository tree or file contents.\"\"\"\n\n    # Local repo\n    if os.path.isdir(repo):\n        target = pathlib.Path(repo) / path\n        if target.is_file():\n            return {\"tree\": [], \"file_content\": target.read_text(encoding=\"utf-8\")}\n        tree = []\n        for item in sorted(target.rglob(\"*\")):\n            rel = item.relative_to(pathlib.Path(repo))\n            if len(rel.parts) <= depth and not any(p.startswith(\".\") for p in rel.parts):\n                tree.append({\n                    \"path\": str(rel), \"type\": \"dir\" if item.is_dir() else \"file\",\n                    \"size\": item.stat().st_size if item.is_file() else 0,\n                })\n        return {\"tree\": tree, \"file_content\": \"\"}\n\n    # Remote GitHub repo\n    headers = {\"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n               \"Accept\": \"application/vnd.github.v3+json\"}\n    base = f\"https://api.github.com/repos/{repo}/contents/{path}\"\n    resp = httpx.get(base, headers=headers, params={\"ref\": ref}, timeout=15)\n    resp.raise_for_status()\n    data = resp.json()\n\n    if isinstance(data, dict) and data.get(\"type\") == \"file\":\n        import base64\n        content = base64.b64decode(data[\"content\"]).decode(\"utf-8\")\n        return {\"tree\": [], \"file_content\": content}\n\n    tree = [{\"path\": item[\"path\"], \"type\": item[\"type\"], \"size\": item.get(\"size\", 0)}\n            for item in data]\n    return {\"tree\": tree, \"file_content\": \"\"}\n```\n\n---\n\n## GitHub API\n\n### `github_create_issue`\n\n**Description:** Creates a new issue on a GitHub repository with title, body, labels, assignees, and milestone, returning the full issue URL and number.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str` (`owner/repo`), `title: str`, `body: str = \"\"`, `labels: list[str] = []`, `assignees: list[str] = []`, `milestone: int = 0` |\n| **Output** | `dict` with `number: int`, `url: str`, `html_url: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/github-mcp` -- exposes `create_issue` |\n\n```python\nimport os, httpx\n\ndef main(repo: str, title: str, body: str = \"\",\n         labels: list[str] | None = None,\n         assignees: list[str] | None = None,\n         milestone: int = 0) -> dict:\n    \"\"\"Create a GitHub issue.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    payload: dict = {\"title\": title, \"body\": body}\n    if labels:\n        payload[\"labels\"] = labels\n    if assignees:\n        payload[\"assignees\"] = assignees\n    if milestone:\n        payload[\"milestone\"] = milestone\n\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/issues\",\n        headers=headers, json=payload, timeout=15,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    return {\n        \"number\": data[\"number\"],\n        \"url\": data[\"url\"],\n        \"html_url\": data[\"html_url\"],\n    }\n```\n\n---\n\n### `github_pull_request`\n\n**Description:** Creates or updates a pull request, with support for draft PRs, auto-merge labels, and reviewer assignment.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str`, `title: str`, `body: str`, `head: str`, `base: str = \"main\"`, `draft: bool = False`, `reviewers: list[str] = []` |\n| **Output** | `dict` with `number: int`, `html_url: str`, `state: str` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | `@anthropic/github-mcp` -- exposes `create_pull_request` |\n\n```python\nimport os, httpx\n\ndef main(repo: str, title: str, body: str, head: str,\n         base: str = \"main\", draft: bool = False,\n         reviewers: list[str] | None = None) -> dict:\n    \"\"\"Create a GitHub pull request.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    payload = {\n        \"title\": title, \"body\": body,\n        \"head\": head, \"base\": base, \"draft\": draft,\n    }\n\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/pulls\",\n        headers=headers, json=payload, timeout=15,\n    )\n    resp.raise_for_status()\n    pr = resp.json()\n\n    # Request reviewers if specified\n    if reviewers:\n        httpx.post(\n            f\"https://api.github.com/repos/{repo}/pulls/{pr['number']}/requested_reviewers\",\n            headers=headers,\n            json={\"reviewers\": reviewers},\n            timeout=10,\n        )\n\n    return {\n        \"number\": pr[\"number\"],\n        \"html_url\": pr[\"html_url\"],\n        \"state\": pr[\"state\"],\n    }\n```\n\n---\n\n### `github_workflow_dispatch`\n\n**Description:** Triggers a GitHub Actions workflow via the repository dispatch or workflow_dispatch API, passing custom inputs and waiting optionally for completion status.\n\n| Field | Detail |\n|---|---|\n| **Input** | `repo: str`, `workflow_id: str` (filename or ID), `ref: str = \"main\"`, `inputs: dict = {}`, `wait: bool = False`, `timeout: int = 300` |\n| **Output** | `dict` with `triggered: bool`, `run_id: int`, `status: str`, `conclusion: str` |\n| **Key Dependencies** | `httpx`, `time` (stdlib) |\n| **MCP Alternative** | `@anthropic/github-mcp` |\n\n```python\nimport os, httpx, time\n\ndef main(repo: str, workflow_id: str, ref: str = \"main\",\n         inputs: dict | None = None, wait: bool = False,\n         timeout: int = 300) -> dict:\n    \"\"\"Trigger a GitHub Actions workflow and optionally wait for completion.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    # Trigger\n    resp = httpx.post(\n        f\"https://api.github.com/repos/{repo}/actions/workflows/{workflow_id}/dispatches\",\n        headers=headers,\n        json={\"ref\": ref, \"inputs\": inputs or {}},\n        timeout=15,\n    )\n    resp.raise_for_status()\n\n    if not wait:\n        return {\"triggered\": True, \"run_id\": 0, \"status\": \"queued\", \"conclusion\": \"\"}\n\n    # Poll for the new run\n    time.sleep(3)\n    deadline = time.time() + timeout\n    while time.time() < deadline:\n        runs_resp = httpx.get(\n            f\"https://api.github.com/repos/{repo}/actions/workflows/{workflow_id}/runs\",\n            headers=headers, params={\"branch\": ref, \"per_page\": 1},\n            timeout=15,\n        )\n        runs = runs_resp.json().get(\"workflow_runs\", [])\n        if runs:\n            run = runs[0]\n            if run[\"status\"] == \"completed\":\n                return {\n                    \"triggered\": True, \"run_id\": run[\"id\"],\n                    \"status\": run[\"status\"], \"conclusion\": run[\"conclusion\"],\n                }\n        time.sleep(10)\n\n    return {\"triggered\": True, \"run_id\": 0, \"status\": \"timeout\", \"conclusion\": \"\"}\n```\n\n---\n\n## Database Operations\n\n### `supabase_query`\n\n**Description:** Executes queries against a Supabase project using the PostgREST API -- supports select, insert, update, upsert, and delete with filter chaining.\n\n| Field | Detail |\n|---|---|\n| **Input** | `table: str`, `action: Literal[\"select\", \"insert\", \"update\", \"upsert\", \"delete\"]`, `data: dict | list[dict] = {}`, `filters: list[dict] = []`, `select_columns: str = \"*\"`, `limit: int = 100` |\n| **Output** | `dict` with `data: list[dict]`, `count: int`, `status: int` |\n| **Key Dependencies** | `supabase` (supabase-py) |\n| **MCP Alternative** | `@anthropic/supabase-mcp` server |\n\n```python\nimport os\nfrom supabase import create_client\n\ndef main(table: str, action: str = \"select\", data=None,\n         filters: list[dict] | None = None,\n         select_columns: str = \"*\", limit: int = 100) -> dict:\n    \"\"\"Execute a Supabase database operation.\"\"\"\n    client = create_client(\n        os.environ[\"SUPABASE_URL\"],\n        os.environ[\"SUPABASE_SERVICE_KEY\"],\n    )\n\n    query = client.table(table)\n\n    if action == \"select\":\n        query = query.select(select_columns)\n        for f in (filters or []):\n            query = getattr(query, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = query.limit(limit).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"insert\":\n        result = query.insert(data).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 201}\n\n    if action == \"upsert\":\n        result = query.upsert(data).execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"update\":\n        q = query.update(data)\n        for f in (filters or []):\n            q = getattr(q, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = q.execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    if action == \"delete\":\n        q = query.delete()\n        for f in (filters or []):\n            q = getattr(q, f.get(\"op\", \"eq\"))(f[\"field\"], f[\"value\"])\n        result = q.execute()\n        return {\"data\": result.data, \"count\": len(result.data), \"status\": 200}\n\n    raise ValueError(f\"Unknown action: {action}\")\n```\n\n---\n\n### `sqlite_query`\n\n**Description:** Opens (or creates) a local SQLite database and executes arbitrary SQL, returning rows as dictionaries -- ideal for lightweight local state, caching, and intermediate pipeline storage.\n\n| Field | Detail |\n|---|---|\n| **Input** | `db_path: str`, `sql: str`, `params: list = []`, `mode: Literal[\"query\", \"execute\", \"script\"] = \"query\"` |\n| **Output** | `dict` with `rows: list[dict]`, `rowcount: int`, `lastrowid: int` |\n| **Key Dependencies** | `sqlite3` (stdlib) |\n| **MCP Alternative** | `@anthropic/sqlite-mcp` server |\n\n```python\nimport sqlite3\n\ndef main(db_path: str, sql: str, params: list | None = None,\n         mode: str = \"query\") -> dict:\n    \"\"\"Execute SQL against a SQLite database.\"\"\"\n    conn = sqlite3.connect(db_path)\n    conn.row_factory = sqlite3.Row\n    cur = conn.cursor()\n\n    try:\n        if mode == \"script\":\n            cur.executescript(sql)\n            conn.commit()\n            return {\"rows\": [], \"rowcount\": cur.rowcount, \"lastrowid\": cur.lastrowid}\n\n        if mode == \"execute\":\n            cur.execute(sql, params or [])\n            conn.commit()\n            return {\"rows\": [], \"rowcount\": cur.rowcount, \"lastrowid\": cur.lastrowid}\n\n        # query mode\n        cur.execute(sql, params or [])\n        rows = [dict(row) for row in cur.fetchall()]\n        return {\"rows\": rows, \"rowcount\": len(rows), \"lastrowid\": 0}\n\n    finally:\n        conn.close()\n```\n\n---\n\n### `airtable_ops`\n\n**Description:** Reads, creates, updates, or deletes records in an Airtable base, handling pagination and field-type coercion automatically.\n\n| Field | Detail |\n|---|---|\n| **Input** | `base_id: str`, `table_name: str`, `action: Literal[\"list\", \"create\", \"update\", \"delete\"]`, `records: list[dict] = []`, `filter_formula: str = \"\"`, `max_records: int = 100` |\n| **Output** | `dict` with `records: list[dict]`, `count: int` |\n| **Key Dependencies** | `httpx` |\n| **MCP Alternative** | None standard; wrap as custom MCP tool |\n\n```python\nimport os, httpx\n\nBASE_URL = \"https://api.airtable.com/v0\"\n\ndef _headers():\n    return {\n        \"Authorization\": f\"Bearer {os.environ['AIRTABLE_API_KEY']}\",\n        \"Content-Type\": \"application/json\",\n    }\n\ndef main(base_id: str, table_name: str, action: str = \"list\",\n         records: list[dict] | None = None,\n         filter_formula: str = \"\", max_records: int = 100) -> dict:\n    \"\"\"Perform CRUD operations on Airtable records.\"\"\"\n    url = f\"{BASE_URL}/{base_id}/{table_name}\"\n\n    if action == \"list\":\n        params: dict = {\"maxRecords\": max_records}\n        if filter_formula:\n            params[\"filterByFormula\"] = filter_formula\n        all_records, offset = [], None\n        while True:\n            if offset:\n                params[\"offset\"] = offset\n            resp = httpx.get(url, headers=_headers(), params=params, timeout=15)\n            resp.raise_for_status()\n            data = resp.json()\n            all_records.extend(data.get(\"records\", []))\n            offset = data.get(\"offset\")\n            if not offset or len(all_records) >= max_records:\n                break\n        return {\"records\": all_records, \"count\": len(all_records)}\n\n    if action == \"create\":\n        payload = {\"records\": [{\"fields\": r} for r in (records or [])]}\n        resp = httpx.post(url, headers=_headers(), json=payload, timeout=15)\n        resp.raise_for_status()\n        created = resp.json().get(\"records\", [])\n        return {\"records\": created, \"count\": len(created)}\n\n    if action == \"update\":\n        payload = {\"records\": records or []}  # expects [{\"id\": ..., \"fields\": {...}}]\n        resp = httpx.patch(url, headers=_headers(), json=payload, timeout=15)\n        resp.raise_for_status()\n        updated = resp.json().get(\"records\", [])\n        return {\"records\": updated, \"count\": len(updated)}\n\n    if action == \"delete\":\n        ids = [r if isinstance(r, str) else r.get(\"id\") for r in (records or [])]\n        resp = httpx.delete(url, headers=_headers(),\n                            params={\"records[]\": ids}, timeout=15)\n        resp.raise_for_status()\n        return {\"records\": resp.json().get(\"records\", []),","truncated":true,"truncatedBy":"bytes","totalLines":4333,"totalBytes":155320,"outputLines":1444,"outputBytes":51200,"lastLinePartial":false,"firstLineExceedsLimit":false,"maxLines":2000,"maxBytes":51200}},"isError":false,"timestamp":1771078863250}}
{"type":"message","id":"75598bcd","parentId":"c1cfa724","timestamp":"2026-02-14T14:21:03.252Z","message":{"role":"toolResult","toolCallId":"toolu_01VWNzuw5jazknJD7QubsoFd","toolName":"read","content":[{"type":"text","text":"# MCP Registry\n\nThe factory's awareness of all available MCPs and integrations. This is the single source of truth for what tools are available when building WAT systems.\n\n**Usage**: Before generating tools, always check this registry. Prefer MCPs over raw API calls when available — less code to maintain, fewer bugs. But always provide a fallback.\n\n**Adding new MCPs**: Add a new entry following the format below. The factory will automatically discover it during the Research step.\n\n---\n\n## Web & Data Access\n\n### Firecrawl\n- **Description**: Web scraping and crawling service. Extracts clean content from websites, handles JavaScript rendering, and returns structured data.\n- **Key Capabilities**: Scrape single pages, crawl entire sites, extract structured data, handle JS-heavy sites, return markdown or JSON\n- **Common Use Cases**: Company research, content extraction, competitive analysis, price monitoring\n- **Tool Pattern**: `firecrawl_scrape(url) → markdown/JSON content`\n- **Secret**: `FIRECRAWL_API_KEY`\n- **Fallback**: Direct HTTP with `requests` + `beautifulsoup4` (won't handle JS rendering)\n\n### Brave Search\n- **Description**: Web search API. Returns search results with snippets and metadata.\n- **Key Capabilities**: Web search, news search, image search, summarized results\n- **Common Use Cases**: Research gathering, fact-checking, finding URLs, news monitoring\n- **Tool Pattern**: `brave_search(query) → list of search results with URLs and snippets`\n- **Secret**: `BRAVE_SEARCH_API_KEY`\n- **Fallback**: Google Custom Search API or SerpAPI\n\n### Puppeteer\n- **Description**: Browser automation MCP. Controls a headless Chrome instance for web interaction.\n- **Key Capabilities**: Navigate pages, fill forms, click buttons, take screenshots, extract DOM content\n- **Common Use Cases**: Scraping dynamic sites, form submission, visual testing, PDF generation\n- **Tool Pattern**: `puppeteer_navigate(url) → page content; puppeteer_screenshot() → image`\n- **Secret**: None (local browser)\n- **Fallback**: Playwright via Python `playwright` package\n\n### Fetch\n- **Description**: Simple HTTP fetch MCP. Makes HTTP requests and returns responses.\n- **Key Capabilities**: GET, POST, PUT, DELETE requests with headers and body\n- **Common Use Cases**: API calls, webhooks, simple page fetches\n- **Tool Pattern**: `fetch(url, method, headers, body) → response`\n- **Secret**: None\n- **Fallback**: Python `requests` library\n\n---\n\n## Code & DevOps\n\n### GitHub\n- **Description**: GitHub API integration. Full access to repos, issues, PRs, Actions, and more.\n- **Key Capabilities**: Create/read/update repos, issues, PRs, manage Actions, read file contents, manage releases\n- **Common Use Cases**: Automated PR creation, issue management, repo setup, CI/CD integration\n- **Tool Pattern**: `github_create_issue(repo, title, body); github_create_pr(repo, ...)`\n- **Secret**: `GITHUB_TOKEN` or `GITHUB_PAT`\n- **Fallback**: `gh` CLI or direct GitHub REST API via `requests`\n\n### Docker\n- **Description**: Docker container management MCP.\n- **Key Capabilities**: Build, run, stop, and manage containers\n- **Common Use Cases**: Isolated tool execution, testing environments\n- **Tool Pattern**: `docker_run(image, command) → output`\n- **Secret**: None (local Docker daemon)\n- **Fallback**: `subprocess.run([\"docker\", ...])`\n\n---\n\n## Communication\n\n### Slack\n- **Description**: Slack messaging MCP. Send messages, read channels, manage threads.\n- **Key Capabilities**: Send messages, post to channels, read channel history, manage threads, upload files\n- **Common Use Cases**: Notifications, alerts, status updates, team communication\n- **Tool Pattern**: `slack_send(channel, message); slack_read(channel) → messages`\n- **Secret**: `SLACK_BOT_TOKEN` or `SLACK_WEBHOOK_URL`\n- **Fallback**: Slack Incoming Webhook via HTTP POST\n\n### Telegram\n- **Description**: Telegram Bot API MCP. Send and receive messages via Telegram bots.\n- **Key Capabilities**: Send messages, photos, documents; read updates; inline keyboards\n- **Common Use Cases**: Alerts, notifications, command-driven bots, status reports\n- **Tool Pattern**: `telegram_send(chat_id, message); telegram_get_updates() → messages`\n- **Secret**: `TELEGRAM_BOT_TOKEN`\n- **Fallback**: Telegram Bot API via HTTP\n\n### Gmail\n- **Description**: Gmail API MCP. Send and read emails.\n- **Key Capabilities**: Send emails, read inbox, search emails, manage labels\n- **Common Use Cases**: Email notifications, inbox monitoring, automated responses\n- **Tool Pattern**: `gmail_send(to, subject, body); gmail_search(query) → emails`\n- **Secret**: `GMAIL_CREDENTIALS`\n- **Fallback**: SMTP via `smtplib`\n\n### Discord\n- **Description**: Discord messaging via webhooks or bot.\n- **Key Capabilities**: Send messages, embeds, files to channels\n- **Common Use Cases**: Team notifications, alerts, community updates\n- **Tool Pattern**: `discord_send(webhook_url, message)`\n- **Secret**: `DISCORD_WEBHOOK_URL`\n- **Fallback**: Discord webhook via HTTP POST\n\n---\n\n## Storage & Databases\n\n### Supabase\n- **Description**: Supabase (Postgres + Auth + Storage) MCP. Full database and storage access.\n- **Key Capabilities**: CRUD operations, real-time subscriptions, file storage, auth management\n- **Common Use Cases**: Persistent data storage, user management, file hosting\n- **Tool Pattern**: `supabase_insert(table, data); supabase_query(table, filters) → rows`\n- **Secret**: `SUPABASE_URL`, `SUPABASE_KEY`\n- **Fallback**: Direct PostgreSQL via `psycopg2` or Supabase REST API\n\n### Google Drive\n- **Description**: Google Drive file management MCP.\n- **Key Capabilities**: Upload, download, list, search, share files and folders\n- **Common Use Cases**: File storage, document sharing, backup\n- **Tool Pattern**: `gdrive_upload(file, folder_id); gdrive_list(folder_id) → files`\n- **Secret**: `GOOGLE_CREDENTIALS`\n- **Fallback**: Google Drive API via `google-api-python-client`\n\n### Airtable\n- **Description**: Airtable database MCP. CRUD operations on Airtable bases and tables.\n- **Key Capabilities**: Create, read, update, delete records; list tables; manage views\n- **Common Use Cases**: Lightweight database, CRM data, project tracking, content calendars\n- **Tool Pattern**: `airtable_create(base, table, record); airtable_list(base, table) → records`\n- **Secret**: `AIRTABLE_API_KEY`\n- **Fallback**: Airtable REST API via `requests`\n\n### Notion\n- **Description**: Notion API MCP. Manage pages, databases, and blocks.\n- **Key Capabilities**: Create/update pages, query databases, manage blocks\n- **Common Use Cases**: Knowledge base, documentation, project management, content publishing\n- **Tool Pattern**: `notion_create_page(parent, title, content); notion_query_db(db_id, filter) → pages`\n- **Secret**: `NOTION_API_KEY`\n- **Fallback**: Notion API via `requests`\n\n### SQLite\n- **Description**: Local SQLite database MCP. Embedded SQL database.\n- **Key Capabilities**: Create tables, CRUD operations, run SQL queries\n- **Common Use Cases**: Local data caching, lightweight storage, offline-first data\n- **Tool Pattern**: `sqlite_query(db_path, sql) → rows`\n- **Secret**: None (local file)\n- **Fallback**: Python `sqlite3` standard library module\n\n---\n\n## AI & Processing\n\n### OpenAI\n- **Description**: OpenAI API MCP. Access GPT models, DALL-E, Whisper, and embeddings.\n- **Key Capabilities**: Chat completions, image generation, speech-to-text, embeddings, structured output\n- **Common Use Cases**: Text generation, summarization, classification, image creation, transcription\n- **Tool Pattern**: `openai_chat(messages) → response; openai_embed(text) → vector`\n- **Secret**: `OPENAI_API_KEY`\n- **Fallback**: OpenAI Python SDK directly\n\n### Anthropic\n- **Description**: Anthropic API for Claude models.\n- **Key Capabilities**: Chat completions, tool use, structured output, long context\n- **Common Use Cases**: Complex reasoning, analysis, code generation, document processing\n- **Tool Pattern**: `anthropic_message(messages) → response`\n- **Secret**: `ANTHROPIC_API_KEY`\n- **Fallback**: Anthropic Python SDK directly\n\n### ElevenLabs\n- **Description**: AI voice synthesis and cloning.\n- **Key Capabilities**: Text-to-speech, voice cloning, audio generation\n- **Common Use Cases**: Audio content creation, podcasts, voice notifications\n- **Tool Pattern**: `elevenlabs_tts(text, voice_id) → audio_file`\n- **Secret**: `ELEVENLABS_API_KEY`\n- **Fallback**: ElevenLabs REST API\n\n### Replicate\n- **Description**: Run ML models via API. Access thousands of open-source models.\n- **Key Capabilities**: Image generation, video generation, audio processing, custom models\n- **Common Use Cases**: Image manipulation, model inference, content generation\n- **Tool Pattern**: `replicate_run(model, input) → output`\n- **Secret**: `REPLICATE_API_TOKEN`\n- **Fallback**: Replicate Python SDK or REST API\n\n---\n\n## Business & Productivity\n\n### Stripe\n- **Description**: Stripe payment processing API.\n- **Key Capabilities**: Create charges, manage subscriptions, list transactions, handle webhooks\n- **Common Use Cases**: Payment tracking, subscription management, revenue reporting\n- **Tool Pattern**: `stripe_list_charges(filters) → charges`\n- **Secret**: `STRIPE_API_KEY`\n- **Fallback**: Stripe Python SDK\n\n### Google Sheets\n- **Description**: Google Sheets API MCP.\n- **Key Capabilities**: Read/write cells, create sheets, format, formulas\n- **Common Use Cases**: Data input/output, reporting, dashboards, data collection\n- **Tool Pattern**: `sheets_read(spreadsheet_id, range) → data; sheets_write(spreadsheet_id, range, data)`\n- **Secret**: `GOOGLE_CREDENTIALS`\n- **Fallback**: `gspread` Python library\n\n### Google Calendar\n- **Description**: Google Calendar API MCP.\n- **Key Capabilities**: Create/read/update events, list calendars, manage attendees\n- **Common Use Cases**: Scheduling, event tracking, availability checks\n- **Tool Pattern**: `calendar_create_event(calendar_id, event); calendar_list(calendar_id) → events`\n- **Secret**: `GOOGLE_CREDENTIALS`\n- **Fallback**: Google Calendar API via `google-api-python-client`\n\n### Linear\n- **Description**: Linear project management API.\n- **Key Capabilities**: Create/update issues, manage projects, track cycles\n- **Common Use Cases**: Task creation, sprint management, automated issue tracking\n- **Tool Pattern**: `linear_create_issue(team, title, description)`\n- **Secret**: `LINEAR_API_KEY`\n- **Fallback**: Linear GraphQL API via `requests`\n\n---\n\n## Local & System\n\n### Filesystem\n- **Description**: Local filesystem access MCP.\n- **Key Capabilities**: Read, write, list, delete files and directories\n- **Common Use Cases**: File processing, data storage, configuration management\n- **Tool Pattern**: `fs_read(path) → content; fs_write(path, content)`\n- **Secret**: None\n- **Fallback**: Python `pathlib` / built-in `open()`\n\n### Shell / Desktop Commander\n- **Description**: Execute shell commands on the local system.\n- **Key Capabilities**: Run commands, manage processes, system information\n- **Common Use Cases**: Tool execution, system automation, build processes\n- **Tool Pattern**: `shell_exec(command) → output`\n- **Secret**: None\n- **Fallback**: Python `subprocess`\n\n---\n\n## Social & Content\n\n### Twitter/X\n- **Description**: Twitter/X API integration.\n- **Key Capabilities**: Post tweets, read timelines, search tweets, manage lists\n- **Common Use Cases**: Social media posting, monitoring mentions, content distribution\n- **Tool Pattern**: `twitter_post(text); twitter_search(query) → tweets`\n- **Secret**: `TWITTER_BEARER_TOKEN`\n- **Fallback**: Twitter API v2 via `requests`\n\n### LinkedIn\n- **Description**: LinkedIn API integration.\n- **Key Capabilities**: Post updates, read profile, company pages\n- **Common Use Cases**: Professional content posting, company updates\n- **Tool Pattern**: `linkedin_post(text, image_url)`\n- **Secret**: `LINKEDIN_ACCESS_TOKEN`\n- **Fallback**: LinkedIn API via `requests`\n\n### YouTube\n- **Description**: YouTube Data API.\n- **Key Capabilities**: Search videos, get video details, manage playlists, read comments\n- **Common Use Cases**: Video research, content analysis, playlist management\n- **Tool Pattern**: `youtube_search(query) → videos; youtube_video_details(video_id) → metadata`\n- **Secret**: `YOUTUBE_API_KEY`\n- **Fallback**: YouTube Data API via `google-api-python-client`\n\n---\n\n## Custom / Any API\n\nAny REST API can be integrated into a WAT system without an MCP:\n\n1. Write a Python tool using `requests` with proper auth headers\n2. Store API credentials in GitHub Secrets\n3. Reference via `os.environ[\"SECRET_NAME\"]` in the tool\n4. Add retry logic with `tenacity` or manual retry loops\n5. Document the API in the system's CLAUDE.md\n\nThe factory is never limited to the MCPs listed here. This registry helps with tool selection, but any API accessible via HTTP can be wrapped as a Python tool.\n\n---\n\n## Media Processing\n\n### NCA Toolkit (Self-Hosted)\n- **Description**: Self-hosted media processing API running at `https://media.wat-factory.cloud`. Replaces services like CloudConvert, Placid, and PDF.co. Handles audio, video, image conversion, transcription, captioning, and more.\n- **Base URL**: `https://media.wat-factory.cloud`\n- **Auth**: `x-api-key` header with `NCA_API_KEY` environment variable\n- **Key Capabilities**:\n  - Transcribe audio/video to text (Whisper) — `POST /v1/media/transcribe`\n  - Convert media between formats — `POST /v1/media/convert`\n  - Convert to MP3 — `POST /v1/media/convert/mp3`\n  - Add captions to video — `POST /v1/video/caption`\n  - Concatenate videos — `POST /v1/video/concatenate`\n  - Concatenate audio — `POST /v1/audio/concatenate`\n  - Trim video — `POST /v1/video/trim`\n  - Cut segments from video — `POST /v1/video/cut`\n  - Split video — `POST /v1/video/split`\n  - Extract thumbnail — `POST /v1/video/thumbnail`\n  - Screenshot webpage — `POST /v1/image/screenshot/webpage`\n  - Convert image to video — `POST /v1/image/convert/video`\n  - Download media from URL (yt-dlp) — `POST /v1/BETA/media/download`\n  - Detect silence — `POST /v1/media/silence`\n  - Extract metadata — `POST /v1/media/metadata`\n  - Generate ASS subtitles — `POST /v1/media/generate/ass`\n  - Upload to S3/R2 — `POST /v1/s3/upload`\n  - Run FFmpeg commands — `POST /v1/ffmpeg/compose`\n  - Execute Python code — `POST /v1/code/execute/python`\n  - Test connectivity — `GET /v1/toolkit/test`\n  - Check job status — `GET /v1/toolkit/job/status?job_id=<id>`\n- **Common Use Cases**: Video transcription, audio/video format conversion, auto-captioning videos for social media, webpage screenshots, media downloading, thumbnail extraction\n- **Tool Pattern**:\n  ```python\n  import os, requests\n  from urllib.parse import quote\n\n  NCA_URL = \"https://media.wat-factory.cloud\"\n  R2_PUBLIC = \"https://pub-b692c36a8374480593a007a38bc7116c.r2.dev\"\n  headers = {\"x-api-key\": os.environ[\"NCA_API_KEY\"], \"Content-Type\": \"application/json\"}\n\n  # === YouTube Transcription (two-step process) ===\n  # Step 1: Download the video (uses yt-dlp, stores on R2)\n  dl = requests.post(f\"{NCA_URL}/v1/BETA/media/download\", headers=headers, json={\n      \"media_url\": \"https://youtube.com/watch?v=VIDEO_ID\"\n  }).json()\n\n  # Step 2: Get the filename from the response and build the PUBLIC R2 URL\n  # IMPORTANT: The storage URL returned uses the private R2 endpoint which is not accessible.\n  # You MUST use the public R2 dev URL instead.\n  # IMPORTANT: Filenames often contain spaces, parentheses, and unicode characters.\n  # You MUST URL-encode the filename.\n  filename = dl[\"response\"][\"media\"][\"media_url\"].split(\"/nca-media/\")[-1]\n  public_url = f\"{R2_PUBLIC}/{filename}\"  # filename is already URL-encoded from the response\n\n  # Step 3: Transcribe using the public URL\n  transcript = requests.post(f\"{NCA_URL}/v1/media/transcribe\", headers=headers, json={\n      \"media_url\": public_url\n  }).json()\n  text = transcript[\"response\"][\"text\"]\n\n  # === Direct media transcription (non-YouTube, publicly accessible URL) ===\n  resp = requests.post(f\"{NCA_URL}/v1/media/transcribe\", headers=headers, json={\n      \"media_url\": \"https://example.com/audio.mp3\"\n  })\n\n  # === Screenshot a webpage ===\n  resp = requests.post(f\"{NCA_URL}/v1/image/screenshot/webpage\", headers=headers, json={\n      \"url\": \"https://example.com\",\n      \"width\": 1920,\n      \"height\": 1080\n  })\n  ```\n- **Secret**: `NCA_API_KEY`\n- **Fallback**: Direct FFmpeg via subprocess (limited — no transcription, no cloud upload)\n- **CRITICAL NOTES**:\n  - The `/v1/media/transcribe` endpoint does NOT support YouTube URLs directly. You MUST first download via `/v1/BETA/media/download`, then transcribe the downloaded file.\n  - The `media_url` returned by the download endpoint uses the private R2 storage URL (`fa8408d96e71300f9e63b83ad7177384.r2.cloudflarestorage.com`). This URL is NOT publicly accessible. Replace the domain with the public R2 URL: `pub-b692c36a8374480593a007a38bc7116c.r2.dev`\n  - All field names use `media_url` (not `url`), except for screenshot which uses `url`.\n  - Transcription runs Whisper on CPU. A 20-minute video takes ~3-4 minutes. Set request timeouts accordingly (at least 600 seconds).\n  - Supports async processing with `webhook_url` parameter for long-running jobs.\n"}],"isError":false,"timestamp":1771078863251}}
{"type":"message","id":"c7d249e7","parentId":"75598bcd","timestamp":"2026-02-14T14:21:03.253Z","message":{"role":"toolResult","toolCallId":"toolu_01Gp5MdGF277oPD4o6LzD7Kf","toolName":"read","content":[{"type":"text","text":"name: \"{System Name}\"\ndescription: |\n\n## Purpose\nWAT System PRP (Product Requirements Prompt) — a structured blueprint that gives the factory enough context to build a complete, working system in one pass.\n\n## Core Principles\n1. **Context is King**: Include ALL necessary documentation, references, and caveats\n2. **Validation Loops**: Provide executable checks the factory can run at each gate\n3. **Information Dense**: Use keywords and patterns from the WAT framework\n4. **Progressive Success**: Start simple, validate, then enhance\n5. **Global rules**: Follow all rules in CLAUDE.md\n\n---\n\n## Goal\n[What system needs to be built. Be specific about the end state: what it does, who uses it, and what success looks like when deployed.]\n\n## Why\n- [Business value and user impact]\n- [What manual process this automates or what gap it fills]\n- [Who benefits and how often they benefit]\n\n## What\n[User-visible behavior and technical requirements. Describe what the system does from the perspective of someone triggering it.]\n\n### Success Criteria\n- [ ] [Specific measurable outcome 1]\n- [ ] [Specific measurable outcome 2]\n- [ ] [Specific measurable outcome 3]\n- [ ] System runs autonomously via GitHub Actions on schedule\n- [ ] Results are committed back to repo or delivered via webhook/notification\n- [ ] All three execution paths work: CLI, GitHub Actions, Agent HQ\n\n---\n\n## Inputs\n[What goes into the system. Be specific about format, source, and any validation requirements.]\n\n```yaml\n- name: \"{input_name}\"\n  type: \"{string | JSON | file | URL | list}\"\n  source: \"{manual input | API | file path | webhook payload}\"\n  required: true\n  description: \"{What this input is and what format it should be in}\"\n  example: \"{A concrete example value}\"\n```\n\n## Outputs\n[What comes out of the system. Where do results go?]\n\n```yaml\n- name: \"{output_name}\"\n  type: \"{JSON | CSV | Markdown | file | webhook}\"\n  destination: \"{repo commit | email | Slack | webhook URL | file path}\"\n  description: \"{What this output contains}\"\n  example: \"{A concrete example or link to sample}\"\n```\n\n---\n\n## All Needed Context\n\n### Documentation & References\n```yaml\n# MUST READ — Include these in context when building\n- url: \"{Official API docs URL}\"\n  why: \"{Specific sections/methods the tools will need}\"\n\n- url: \"{Library documentation URL}\"\n  why: \"{Specific patterns or gotchas to follow}\"\n\n- file: \"{path/to/existing/pattern.py}\"\n  why: \"{Pattern to follow, conventions to match}\"\n\n- doc: \"config/mcp_registry.md\"\n  why: \"Check which MCPs provide the capabilities this system needs\"\n\n- doc: \"library/patterns.md\"\n  why: \"Select the best workflow pattern for this system\"\n\n- doc: \"library/tool_catalog.md\"\n  why: \"Identify reusable tool patterns to adapt\"\n```\n\n### Workflow Pattern Selection\n```yaml\n# Reference library/patterns.md — select the best-fit pattern\npattern: \"{Pattern name from library/patterns.md, e.g., Scrape > Process > Output}\"\nrationale: \"{Why this pattern fits the problem}\"\nmodifications: \"{Any adjustments needed to the standard pattern}\"\n```\n\n### MCP & Tool Requirements\n```yaml\n# Reference config/mcp_registry.md — list capabilities needed\ncapabilities:\n  - name: \"{capability, e.g., web scraping}\"\n    primary_mcp: \"{MCP name from registry, e.g., firecrawl}\"\n    alternative_mcp: \"{Alternative MCP}\"\n    fallback: \"{Direct API/HTTP approach if no MCP available}\"\n    secret_name: \"{UPPERCASE_SECRET_NAME}\"\n\n  - name: \"{capability 2}\"\n    primary_mcp: \"{MCP name}\"\n    alternative_mcp: \"{Alternative}\"\n    fallback: \"{Fallback approach}\"\n    secret_name: \"{SECRET_NAME}\"\n```\n\n### Known Gotchas & Constraints\n```\n# CRITICAL: {API/service name} has rate limit of {N} requests per {period}\n# CRITICAL: {Library} requires {specific setup or version}\n# CRITICAL: {Data source} returns {unexpected format} — must handle {edge case}\n# CRITICAL: Secrets are NEVER hardcoded — always use GitHub Secrets or .env\n# CRITICAL: Every tool must have try/except, logging, type hints, and a main() function\n```\n\n---\n\n## System Design\n\n### Subagent Architecture\n[Define the specialist subagents this system needs. One subagent per major capability or workflow phase.]\n\n```yaml\nsubagents:\n  - name: \"{function}-specialist\"\n    description: \"When Claude should delegate to this subagent — be specific\"\n    tools: \"Read, Bash, Grep\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"{What this subagent does — step 1}\"\n      - \"{What this subagent does — step 2}\"\n    inputs: \"{What data it receives}\"\n    outputs: \"{What data it produces}\"\n\n  - name: \"{function}-specialist\"\n    description: \"When Claude should delegate to this subagent\"\n    tools: \"Read, Write, Bash\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"{Responsibility 1}\"\n      - \"{Responsibility 2}\"\n    inputs: \"{Input data}\"\n    outputs: \"{Output data}\"\n```\n\n### Agent Teams Analysis\n```yaml\n# Apply the 3+ Independent Tasks Rule\nindependent_tasks:\n  - \"{Task A — no dependency on other tasks}\"\n  - \"{Task B — no dependency on other tasks}\"\n  - \"{Task C — no dependency on other tasks}\"\n\nindependent_task_count: \"{N}\"\nrecommendation: \"{Use Agent Teams | Sequential execution}\"\nrationale: \"{Why — e.g., '3 independent API calls each taking 10s = 30s sequential vs 10s parallel'}\"\n\n# If Agent Teams recommended:\nteam_lead_responsibilities:\n  - \"Create shared task list\"\n  - \"Spawn teammates for independent tasks\"\n  - \"Merge results and run quality control\"\n\nteammates:\n  - name: \"{Teammate 1}\"\n    task: \"{Scoped task description}\"\n    inputs: \"{What it receives}\"\n    outputs: \"{What it produces}\"\n\n# If NOT recommended:\nsequential_rationale: \"{Why sequential is sufficient — e.g., 'all tasks depend on previous output'}\"\n```\n\n### GitHub Actions Triggers\n```yaml\ntriggers:\n  - type: \"{workflow_dispatch | schedule | repository_dispatch}\"\n    config: \"{cron expression, input parameters, or event type}\"\n    description: \"{When and why this trigger fires}\"\n```\n\n---\n\n## Implementation Blueprint\n\n### Workflow Steps\n[Ordered list of workflow phases. Each step becomes a section in workflow.md.]\n\n```yaml\nsteps:\n  - name: \"{Step 1 name}\"\n    description: \"{What happens in this step}\"\n    subagent: \"{Which subagent handles this, if any}\"\n    tools: [\"{tool_1.py}\", \"{tool_2.py}\"]\n    inputs: \"{What this step receives}\"\n    outputs: \"{What this step produces}\"\n    failure_mode: \"{What can go wrong}\"\n    fallback: \"{What to do if it fails}\"\n\n  - name: \"{Step 2 name}\"\n    description: \"{Description}\"\n    subagent: \"{subagent name}\"\n    tools: [\"{tool_name.py}\"]\n    inputs: \"{From previous step}\"\n    outputs: \"{For next step}\"\n    failure_mode: \"{Failure scenario}\"\n    fallback: \"{Recovery action}\"\n```\n\n### Tool Specifications\n[For each tool the system needs. Reference library/tool_catalog.md for reusable patterns.]\n\n```yaml\ntools:\n  - name: \"{tool_name}.py\"\n    purpose: \"{One-line description}\"\n    catalog_pattern: \"{Pattern name from tool_catalog.md, or 'new' if custom}\"\n    inputs:\n      - \"{arg1}: {type} — {description}\"\n      - \"{arg2}: {type} — {description}\"\n    outputs: \"{JSON structure or file format}\"\n    dependencies: [\"{pip package 1}\", \"{pip package 2}\"]\n    mcp_used: \"{MCP name, or 'none'}\"\n    error_handling: \"{How errors are handled}\"\n\n  - name: \"{tool_name_2}.py\"\n    purpose: \"{Description}\"\n    catalog_pattern: \"{Pattern or 'new'}\"\n    inputs:\n      - \"{arg}: {type} — {description}\"\n    outputs: \"{Output format}\"\n    dependencies: [\"{package}\"]\n    mcp_used: \"{MCP or 'none'}\"\n    error_handling: \"{Error approach}\"\n```\n\n### Per-Tool Pseudocode\n```python\n# {tool_name}.py\ndef main():\n    # PATTERN: {Which catalog pattern this follows}\n    # Step 1: Parse inputs\n    args = parse_args()  # argparse or env vars\n\n    # Step 2: {Core logic description}\n    # GOTCHA: {Important caveat about this API/library}\n    result = do_work(args.input)\n\n    # Step 3: Output results\n    # PATTERN: Structured JSON to stdout\n    print(json.dumps(result))\n\n# {tool_name_2}.py\ndef main():\n    # PATTERN: {Catalog pattern}\n    # CRITICAL: {Key constraint — rate limit, auth, format}\n    pass\n```\n\n### Integration Points\n```yaml\nSECRETS:\n  - name: \"{SECRET_NAME}\"\n    purpose: \"{What API/service this authenticates}\"\n    required: true\n\nENVIRONMENT:\n  - file: \".env.example\"\n    vars:\n      - \"{VAR_NAME}={placeholder_value}  # {description}\"\n\nDEPENDENCIES:\n  - file: \"requirements.txt\"\n    packages:\n      - \"{package}=={version}  # {why}\"\n\nGITHUB_ACTIONS:\n  - trigger: \"{workflow_dispatch | schedule | repository_dispatch}\"\n    config: \"{Details}\"\n```\n\n---\n\n## Validation Loop\n\n### Level 1: Syntax & Structure\n```bash\n# Run FIRST — every tool must pass before proceeding to Level 2\n# AST parse — verify valid Python syntax\npython -c \"import ast; ast.parse(open('tools/{tool_name}.py').read())\"\n\n# Import check — verify no missing dependencies\npython -c \"import importlib; importlib.import_module('tools.{tool_name}')\"\n\n# Structure check — verify main() exists\npython -c \"from tools.{tool_name} import main; assert callable(main)\"\n\n# Repeat for every tool file\n# Expected: All pass with no errors. If any fail, fix before proceeding.\n```\n\n### Level 2: Unit Tests\n```bash\n# Run SECOND — each tool must produce correct output for sample inputs\n# Test each tool independently with mock/sample data\n\npython tools/{tool_name}.py --input \"{sample_input}\"\n# Expected output: {expected JSON or result}\n\npython tools/{tool_name_2}.py --input \"{sample_input}\"\n# Expected output: {expected result}\n\n# If any tool fails: Read the error, fix the root cause, re-run.\n# NEVER mock to make tests pass — fix the actual code.\n```\n\n### Level 3: Integration Tests\n```bash\n# Run THIRD — verify tools work together as a pipeline\n# Simulate the full workflow with sample data\n\n# Step 1: Run first tool\npython tools/{tool_1}.py --input \"{sample}\" > /tmp/step1_output.json\n\n# Step 2: Feed output to next tool\npython tools/{tool_2}.py --input /tmp/step1_output.json > /tmp/step2_output.json\n\n# Step 3: Verify final output\npython -c \"\nimport json\nresult = json.load(open('/tmp/step2_output.json'))\nassert '{expected_key}' in result, 'Missing expected key in output'\nprint('Integration test passed')\n\"\n\n# Verify workflow.md references match actual tool files\n# Verify CLAUDE.md documents all tools and subagents\n# Verify .github/workflows/ YAML is valid\n```\n\n---\n\n## Final Validation Checklist\n- [ ] All tools pass Level 1 (syntax, imports, structure)\n- [ ] All tools pass Level 2 (unit tests with sample data)\n- [ ] Pipeline passes Level 3 (integration test end-to-end)\n- [ ] workflow.md has failure modes and fallbacks for every step\n- [ ] CLAUDE.md documents all tools, subagents, MCPs, and secrets\n- [ ] .github/workflows/ has timeout-minutes and failure notifications\n- [ ] .env.example lists all required environment variables\n- [ ] .gitignore excludes .env, __pycache__/, credentials\n- [ ] README.md covers all three execution paths (CLI, Actions, Agent HQ)\n- [ ] No hardcoded secrets anywhere in the codebase\n- [ ] Subagent files have valid YAML frontmatter and specific system prompts\n- [ ] requirements.txt lists all Python dependencies\n\n---\n\n## Anti-Patterns to Avoid\n- Do not hardcode API keys, tokens, or credentials — use GitHub Secrets or .env\n- Do not use `git add -A` or `git add .` — stage only specific files\n- Do not skip validation because \"it should work\" — run all three levels\n- Do not catch bare `except:` — always catch specific exception types\n- Do not build tools that require interactive input — all tools must run unattended\n- Do not create MCP-dependent tools without HTTP/API fallbacks\n- Do not design subagents that call other subagents — only the main agent delegates\n- Do not use Agent Teams when fewer than 3 independent tasks exist — the overhead is not justified\n- Do not commit .env files, credentials, or API keys to the repository\n- Do not ignore failing tests — fix the root cause, never mock to pass\n- Do not generate workflow steps without failure modes and fallback actions\n- Do not write tools without try/except, logging, type hints, and a main() function\n\n---\n\n## Confidence Score: {N}/10\n\n**Score rationale:**\n- [{Area}]: {Why confident or uncertain} — Confidence: {high | medium | low}\n- [{Area}]: {Rationale} — Confidence: {high | medium | low}\n- [{Area}]: {Rationale} — Confidence: {high | medium | low}\n\n**Ambiguity flags** (areas requiring clarification before building):\n- [ ] {Ambiguous requirement 1 — what needs clarification and why}\n- [ ] {Ambiguous requirement 2 — what needs clarification and why}\n\n**If any ambiguity flag is checked, DO NOT proceed to build. Ask the user to clarify first.**\n\n---\n\n## Factory Build Prompt\n\nWhen this PRP is ready, execute the build with:\n\n```\n/execute-prp PRPs/{system-name}.md\n```\n\nThis will trigger `factory/workflow.md` with the above requirements as structured input.\n"}],"isError":false,"timestamp":1771078863252}}
{"type":"message","id":"2fea74e3","parentId":"c7d249e7","timestamp":"2026-02-14T14:26:42.076Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Great! I've read all the necessary reference materials. Now I need to generate a comprehensive PRP for the \"site-intelligence-pack\" system based on the problem description provided.\n\nLet me break down what I understand about this system:\n\n1. **Purpose**: Comprehensive website analysis system with three specialist components that analyze websites and produce evidence-backed business intelligence reports.\n\n2. **Key Requirements**:\n   - Input format: Single domain or batch CSV\n   - Triggering: workflow_dispatch + optional nightly scheduled batch\n   - Output: JSON + README committed to repo\n   - Scale: 200 pages max per site\n   - Must respect robots.txt\n   - Rate limiting: 1-2 req/sec\n   - Integration: Firecrawl + GitHub\n\n3. **Three Specialist Components**:\n   - relevance-ranker-specialist: Ranks pages using heuristics + semantic scoring\n   - deep-extract-specialist: Deep scrapes top K pages, extracts structured fields\n   - synthesis-validator-specialist: Builds final JSON pack, validates evidence\n\n4. **Core Requirements**:\n   - MUST respect robots.txt\n   - No authentication bypass\n   - Evidence-backed findings (every claim has url + excerpt)\n   - De-duplication of URLs\n   - Page inventory focus (home, about, offers, pricing, etc.)\n   - Failure modes: fallback to HTTP if Firecrawl fails\n\n5. **JSON Schema**: Defined structure with site info, inventory, ranked_pages, deep_extract_notes, synthesized_findings, evidence_index, run_metadata\n\nNow let me structure this into a complete PRP following the template...","thinkingSignature":"EowNCkYICxgCKkDMVdmC83l5eywLeyHrYS3L4pR+BQYCtcjqIxYDIkG9uc1PXIjFEdIehuyYLMxSqHGJuXJvxgbXZrurqlKYHHWCEgzukTWSMykDn4HwGeMaDFvBlgnjTr/uuHn1UiIwXfYdY8EottEkp5dlMKx9McyMFs3Jyp21YUaKy5a4BgIbxDuS41eJheod18FMb8/kKvMLVQ7zgkYklBavW9JnIFW4cGkono2ILCb9IL3fEJ0PieFiLnLm3kF1U0VeN430ARjpwY5nu1dhV4FI/pc8Ijomd3ZXxsE9k6nVNNGyg8YTOUaJ9J0mVvTlbyrw7RDZGswPquC+4+SkcIcUVn+neYNuYL1ez5tUsmI0jVg/7gfgRcfbTAUvKaDz2o08RFXAQ1IelZ/1yDBC/4bkFGMMjaERaBeTJERwsNHTPkq6TYXSiU6uvQEIVc4mkqjknbFYbZcxzkss4BxCV2spj7PLSIO13mlNWh9jxw/ywugmDTeYA3xBHJorIlpWDl1OfSbpe6JDlct4HaGe3dM0v2i185owzmhgM+knpzkLG2g5rj5gzNFos5CyiuRNgg8ye6DBrRJg36uZ4vDOC9y7fXmL/hoWdfh+YpD8PWA4iJp1NdshqPVchMM8b5Od3/HU0k5Nkr3PAOSaxcsA9tOEc//cG21wJn/FFisyZN/SQ8sK6uNYmJoCnPmEXuEs91GxAjTSRLEYGEaytwoBkHhfePaJSqsj/zgHwDDDGHYkxftcT6YNnleVlqoSIrtKHxdN1wYJo9VsDh9RTMTDHy5OuaBTNGdCKLvN903msYBwgjoKaNXaktZHLTkvla5T8IU30pJq6AtYlEXZsjbWGcAVIweQWmo4F6JHk8H8TwH+kvKLG7R3QftDFDAJCSsdvVVuDgnjykGDsZb6gS30n9BOV6I/tM4GXnCxkULXtA6cjFQgJ6XuLRKI5/+kLBLahWp/NVyoePyLV/99aoBl3uKLizGQEQBmkZA23lXEwOhv2DgRN+mSlENL/2GiODRhuzjCYlkB1CvPkadgyOaR16PaHZO+UsZoUPxfGBtV/jryQ9dEVBn0rgEZPRjs+GNED9m+mHDb9+khjwPXLLUjVIimi1R8tIgCQv0nuFaac23abnXTzTg45jLuIcY5VfnQzX3AhNUCp6km9MDl9d+FIf8HN4svv2n9vKaAkbO5e3+fSwld4HXnPU6x4PkPIpiy6kKf4PFDg5BCddxn7zJPJkn+uECfougoEJme7YQ8LhHE3GebLjoH8y1183e9P85FI1YnH228qrcwkkKEy41yvrF0MnLtt0dFYaMnPZbzzxu8iP6z1Bypmr33ExHSNTdVfXGPQRyvwtXQA0Fqr4c8MIpuroICk8IPi2rX4Adcy2ZmvipHuXEJOy43FRVIhVUIKZ2DqyHcWi9mHOIApH9+c4XbpPx9TTmIDzCF74bpBethFfqCFHIXF9wREqWURHKYxOS7Wz+itnxXSMkOxTZ4vf8UWCe35k9qUGfrf8ulU2MW7tIsgioqhf1sDyvVr+FELogjjBjG+zohZqPRgr4wwCNkb1w1fKJdBbRLqJURMFO9mqywg1gAB7ro51vYdmg788Ok0eUx70Uax680gNERMKej9UOq6KpsPojmQf0bwkvQamV2F0MGttl2eKxavVyb2MoFthF6mEcXtcFR3SacCwX0NAmvRLv9UZCETPntxwaiSfpi5m/xMzEmFqV6M33mCjPjXKVrPXMGVKGbgyoq4xk/X6w7w6HrFRXeCWQUCAhQif/m1JdHACyrFHN7VtULuAfhx4lkDOO4Whg8MYUFoiT+qRA5soym+c/xfO8MSj1QVlTuvI+SJQjb8j7DSGjuGdsBCih+NWWKkbLrDR8+BIYX5vXgkiJjLjbnUSs4TRxccA7yRpuwQdNbp0zofjMH6adEgu/pwsLnbge8CUBaQFa1cI08DH3QbWI1ASv1kIE8XZ6c+QY383n+wEHlSUguoxqaf+L3TF4hGUz0C28LSMNcNARqpu1NRRzeUwEyLfVpusnwVBTW8DbWOBQJuGf3MSkFLTRWAxheHAk2JGLFsLsQ69xPornRDq67Ri4bYjil4LcrPrLstM3jfmcXFXlkBR5z397nhJGCBP39TW7P4CMZMKj+3LJmbb5COFXG1ikcJZ0tAKaunzDOo+Hic5Z1pboDNSRwTLXVk24yij2icpaQRzerw3uIP0r/2oGNTHXieJ5nTp00/lW0ZxAYAQ=="},{"type":"text","text":"I'll now generate a comprehensive PRP for the site-intelligence-pack system. Let me create the file following the template structure."},{"type":"toolCall","id":"toolu_01Fm5ofmurdJ66YjS5eY4TpF","name":"write","arguments":{"path":"PRPs/site-intelligence-pack.md","content":"name: \"Site Intelligence Pack\"\ndescription: |\n  Comprehensive website analysis system with three specialist components for analyzing websites and producing evidence-backed business intelligence reports.\n\n## Purpose\nBuild a GitHub-native, automated website intelligence gathering system that analyzes target domains through a three-phase pipeline: (1) crawl and inventory discovery, (2) intelligent page ranking and prioritization, (3) deep extraction of structured business data, and (4) synthesis into an evidence-backed intelligence pack. The system must respect robots.txt, handle failures gracefully, and produce auditable, citation-backed reports suitable for competitive analysis, market research, and lead qualification.\n\n## Core Principles\n1. **Context is King**: Include ALL necessary documentation, references, and caveats\n2. **Validation Loops**: Provide executable checks the factory can run at each gate\n3. **Information Dense**: Use keywords and patterns from the WAT framework\n4. **Progressive Success**: Start simple, validate, then enhance\n5. **Global rules**: Follow all rules in CLAUDE.md\n\n---\n\n## Goal\nBuild a fully autonomous website intelligence system that accepts a domain (or batch CSV of domains), crawls and analyzes the site, extracts structured business intelligence, and produces a comprehensive JSON intelligence pack with a human-readable summary report — all committed to the repository with full evidence provenance and compliance with robots.txt.\n\nSuccess looks like: A user opens a GitHub Issue with \"Analyze example.com\", and 5-10 minutes later a PR is opened with a complete intelligence pack (JSON + README) containing ranked pages, extracted offers/pricing/policies, and synthesized business insights — every claim backed by URL + excerpt citations.\n\n## Why\n- **Business value**: Enables competitive intelligence, lead qualification, and market research at scale without manual research teams\n- **User impact**: Converts hours of manual website research into minutes of automated analysis\n- **Automation gap**: Eliminates manual website reading, note-taking, and data extraction for business intelligence\n- **Who benefits**: Sales teams (lead qualification), product teams (competitive analysis), research teams (market intelligence) — used on-demand or nightly batch\n- **Frequency**: On-demand (workflow_dispatch) for ad-hoc research; optional nightly scheduled batch for ongoing monitoring\n\n## What\nFrom the perspective of someone triggering the system:\n\n**Single domain mode (workflow_dispatch)**:\n1. User provides a domain (e.g., `example.com`)\n2. System crawls the site (respecting robots.txt), discovers pages, and builds an inventory\n3. System ranks pages by relevance (heuristics + semantic scoring)\n4. System deep-extracts top K pages for structured data (offers, pricing, policies, etc.)\n5. System synthesizes findings into a structured intelligence pack with evidence index\n6. System validates that all claims have supporting evidence (url + excerpt)\n7. System commits output files (JSON + README) to `outputs/{domain}/`\n8. System opens a PR or commits directly (based on AUTO_MERGE setting)\n\n**Batch mode (scheduled or workflow_dispatch with CSV)**:\n1. System reads `inputs/targets.csv` (columns: `domain`, optional `priority`)\n2. System processes each domain sequentially (to respect rate limits)\n3. System outputs one intelligence pack per domain to `outputs/{domain}/`\n4. System commits all outputs in a single commit with summary\n\n**Failure modes handled**:\n- Robots.txt disallows crawling → skip crawl, report robots.txt excerpt in output\n- Pages require login/paywall → mark as inaccessible with reason, continue with accessible pages\n- Firecrawl fails → fallback to direct HTTP + BeautifulSoup\n- Fewer than 5 pages extracted → open GitHub Issue with failure summary, still commit partial output\n- Rate limit hit → pause, wait, retry with exponential backoff\n\n### Success Criteria\n- [x] System accepts single domain via workflow_dispatch input or batch CSV from `inputs/targets.csv`\n- [x] System respects robots.txt: fetches robots.txt first, skips disallowed paths, includes robots summary in output\n- [x] System crawls up to 200 pages per site (default), discovers key pages (home, about, pricing, faq, contact, policies, terms, blog)\n- [x] System ranks pages by relevance using heuristics (path keywords) + lightweight semantic scoring (titles/headings/first N chars)\n- [x] System deep-extracts top K pages (default 10) for structured fields: offers, pricing, guarantees, process steps, FAQs, contact methods, policies, testimonials\n- [x] System synthesizes findings into structured JSON: positioning, offers_and_pricing, customer_journey, trust_signals, compliance_and_policies, unknowns_and_gaps\n- [x] System validates evidence: every claim in synthesized_findings must have evidence_index entry with url + excerpt + extracted_at + page_title\n- [x] System de-duplicates URLs: canonicalize URLs (strip utm params, normalize trailing slashes, lowercase host), cluster near-identical pages\n- [x] System rate-limits: ~1-2 req/sec, stops early on repeated errors\n- [x] System commits outputs to repo: `outputs/{domain}/inventory.json`, `ranked_pages.json`, `deep_extract.json`, `site_intelligence_pack.json`, `README.md` (run report)\n- [x] System runs autonomously via GitHub Actions on schedule (optional nightly batch) or workflow_dispatch (single domain)\n- [x] All three execution paths work: CLI (local testing), GitHub Actions (production), Agent HQ (issue-driven)\n- [x] System opens GitHub Issue on major failures (fewer than 5 pages extracted) with failure summary and still commits partial output\n- [x] System handles fallback: Firecrawl failure → HTTP + BeautifulSoup; still blocked → produce partial pack with \"inaccessible\" section\n\n---\n\n## Inputs\n\n```yaml\n- name: \"domain\"\n  type: \"string\"\n  source: \"workflow_dispatch input OR first column of inputs/targets.csv\"\n  required: true (for single-domain mode)\n  description: \"Target domain to analyze (without protocol). Examples: example.com, www.example.com\"\n  example: \"stripe.com\"\n\n- name: \"batch_csv_path\"\n  type: \"string (file path)\"\n  source: \"workflow_dispatch input OR default to inputs/targets.csv\"\n  required: false (for batch mode)\n  description: \"Path to CSV file containing batch targets. Columns: domain (required), priority (optional)\"\n  example: \"inputs/targets.csv\"\n\n- name: \"max_pages\"\n  type: \"integer\"\n  source: \"workflow_dispatch input OR environment variable\"\n  required: false\n  description: \"Maximum pages to crawl per site (default: 200)\"\n  example: \"200\"\n\n- name: \"top_k_deep_extract\"\n  type: \"integer\"\n  source: \"workflow_dispatch input OR environment variable\"\n  required: false\n  description: \"Number of top-ranked pages to deep extract (default: 10)\"\n  example: \"10\"\n\n- name: \"rate_limit_rps\"\n  type: \"float\"\n  source: \"workflow_dispatch input OR environment variable\"\n  required: false\n  description: \"Rate limit in requests per second (default: 1.5)\"\n  example: \"1.5\"\n```\n\n## Outputs\n\n```yaml\n- name: \"site_intelligence_pack.json\"\n  type: \"JSON\"\n  destination: \"repo commit at outputs/{domain}/site_intelligence_pack.json\"\n  description: \"Complete intelligence pack with site info, inventory, ranked pages, deep extract notes, synthesized findings, evidence index, and run metadata\"\n  example: |\n    {\n      \"site\": {\n        \"target_url\": \"https://stripe.com\",\n        \"domain\": \"stripe.com\",\n        \"crawled_at_iso\": \"2026-02-14T14:30:00Z\",\n        \"robots\": {\n          \"fetched_url\": \"https://stripe.com/robots.txt\",\n          \"allowed_summary\": \"Most paths allowed\",\n          \"disallowed_summary\": \"Disallowed: /admin, /internal\",\n          \"raw_excerpt\": \"User-agent: *\\nDisallow: /admin\"\n        }\n      },\n      \"inventory\": [...],\n      \"ranked_pages\": [...],\n      \"deep_extract_notes\": {...},\n      \"synthesized_findings\": {...},\n      \"evidence_index\": {...},\n      \"run_metadata\": {...}\n    }\n\n- name: \"inventory.json\"\n  type: \"JSON\"\n  destination: \"repo commit at outputs/{domain}/inventory.json\"\n  description: \"Full page inventory with URLs, titles, discovery info, HTTP status, content hashes, dedup clusters\"\n  example: \"Array of {url, canonical_url, title, discovered_from, http_status, content_hash, dedup_cluster_id, notes}\"\n\n- name: \"ranked_pages.json\"\n  type: \"JSON\"\n  destination: \"repo commit at outputs/{domain}/ranked_pages.json\"\n  description: \"Pages ranked by relevance with scores, reasons, and categories\"\n  example: \"Array of {url, canonical_url, rank, reasons: [string], category: string}\"\n\n- name: \"deep_extract.json\"\n  type: \"JSON\"\n  destination: \"repo commit at outputs/{domain}/deep_extract.json\"\n  description: \"Deep-extracted structured data from top K pages\"\n  example: \"Object with pages array containing extracted_entities, offers, pricing, how_it_works, faq, testimonials, policies, constraints\"\n\n- name: \"README.md\"\n  type: \"Markdown\"\n  destination: \"repo commit at outputs/{domain}/README.md\"\n  description: \"Human-readable run report with summary, key findings, robots compliance, and any issues encountered\"\n  example: \"# Site Intelligence Pack: stripe.com\\n\\n## Summary\\nCrawled 147 pages, ranked 147, deep-extracted 10...\"\n```\n\n---\n\n## All Needed Context\n\n### Documentation & References\n```yaml\n# MUST READ — Include these in context when building\n\n- url: \"https://docs.firecrawl.dev/api-reference/crawl\"\n  why: \"Firecrawl crawl endpoint usage, parameters (limit, scrapeOptions), response structure\"\n\n- url: \"https://docs.firecrawl.dev/api-reference/scrape\"\n  why: \"Firecrawl scrape endpoint for single-page deep extraction, formats (markdown, html, structured)\"\n\n- doc: \"config/mcp_registry.md\"\n  why: \"Check Firecrawl MCP availability and capabilities\"\n\n- doc: \"library/patterns.md\"\n  why: \"Select the best workflow pattern for multi-phase website analysis pipeline\"\n\n- doc: \"library/tool_catalog.md\"\n  why: \"Identify reusable tool patterns for web scraping, data extraction, and validation\"\n\n- url: \"https://www.robotstxt.org/robotstxt.html\"\n  why: \"robots.txt specification for parsing and compliance checking\"\n\n- url: \"https://docs.python.org/3/library/urllib.parse.html\"\n  why: \"URL parsing and canonicalization (urlparse, urlunparse, urljoin)\"\n\n- url: \"https://docs.python.org/3/library/hashlib.html\"\n  why: \"Content hashing for de-duplication (hashlib.md5 or sha256)\"\n\n- url: \"https://github.com/anthropics/anthropic-sdk-python\"\n  why: \"Claude API for semantic scoring and synthesis tasks\"\n```\n\n### Workflow Pattern Selection\n```yaml\n# Reference library/patterns.md\npattern: \"Scrape > Process > Output + Fan-Out > Process > Merge (for batch mode)\"\nrationale: |\n  The system follows a multi-phase pipeline:\n  1. Scrape (crawl + inventory) — Uses Firecrawl MCP to crawl domain and build page inventory\n  2. Process (rank) — Applies heuristics and semantic scoring to rank pages by relevance\n  3. Process (deep extract) — Deep-scrapes top K pages and extracts structured fields\n  4. Process (synthesize + validate) — Merges extracts into intelligence pack with evidence validation\n  5. Output — Commits JSON + README to repo\n\n  For batch mode, we apply Fan-Out > Process > Merge pattern where each domain is an independent unit of work.\n  However, to respect rate limits, batch processing is SEQUENTIAL by default (not parallel).\n  Agent Teams is NOT recommended because tasks are NOT independent (sequential processing required for rate limits).\n\nmodifications: |\n  - Add robots.txt pre-check before crawling\n  - Add de-duplication step after inventory\n  - Add evidence validation step after synthesis\n  - Add fallback chain: Firecrawl → HTTP + BeautifulSoup → partial output with \"inaccessible\" section\n  - Add GitHub Issue creation on major failures (fewer than 5 pages extracted)\n```\n\n### MCP & Tool Requirements\n```yaml\ncapabilities:\n  - name: \"web crawling and scraping\"\n    primary_mcp: \"firecrawl\"\n    alternative_mcp: \"puppeteer\"\n    fallback: \"Direct HTTP with requests + beautifulsoup4 (no JS rendering)\"\n    secret_name: \"FIRECRAWL_API_KEY\"\n    notes: \"Firecrawl handles JS-rendered sites and returns clean markdown; fallback loses JS rendering but maintains basic scraping\"\n\n  - name: \"LLM for semantic scoring and synthesis\"\n    primary_mcp: \"anthropic\"\n    alternative_mcp: \"none\"\n    fallback: \"Heuristic-only ranking (no semantic component), synthesis via templates\"\n    secret_name: \"ANTHROPIC_API_KEY\"\n    notes: \"Used for lightweight semantic scoring on titles/headings and synthesis of findings; can run without LLM using heuristics only\"\n\n  - name: \"GitHub issue creation on failure\"\n    primary_mcp: \"github\"\n    alternative_mcp: \"none\"\n    fallback: \"gh CLI or direct GitHub REST API via requests\"\n    secret_name: \"GITHUB_TOKEN\"\n    notes: \"Used to open issues when fewer than 5 pages are extracted successfully\"\n```\n\n### Known Gotchas & Constraints\n```\n# CRITICAL: Firecrawl API has rate limits — check response headers for X-RateLimit-* values\n# CRITICAL: robots.txt MUST be fetched FIRST before any crawling — use requests.get(f\"https://{domain}/robots.txt\")\n# CRITICAL: URL canonicalization is critical for de-duplication:\n#   - Lowercase scheme and host (https://Example.com → https://example.com)\n#   - Remove trailing slashes EXCEPT for domain root (example.com/ → example.com, example.com/page/ → example.com/page)\n#   - Strip UTM params and tracking params (utm_*, fbclid, gclid, ref, etc.)\n#   - Normalize path segments (remove /../, /./, etc.)\n# CRITICAL: Content hashing for de-duplication — hash the visible text content (not HTML) to detect near-identical pages\n# CRITICAL: Header/footer boilerplate appears on every page — must strip before hashing to avoid false duplicates\n# CRITICAL: Secrets are NEVER hardcoded — always use GitHub Secrets or .env\n# CRITICAL: Every tool must have try/except, logging, type hints, and a main() function\n# CRITICAL: Evidence validation is MANDATORY — synthesized_findings must reference evidence_index entries\n# CRITICAL: Rate limiting is MANDATORY — add delays between requests, respect 429 responses, implement exponential backoff\n# CRITICAL: Page inventory must attempt discovery of: home, about, offers, pricing, faq, contact, policies, privacy, terms, blog\n# CRITICAL: If fewer than 5 pages are extracted successfully, open a GitHub Issue with failure summary AND still commit partial output\n# CRITICAL: Firecrawl crawl mode returns markdown — use this for inventory; Firecrawl scrape mode returns structured data — use for deep extract\n```\n\n---\n\n## System Design\n\n### Subagent Architecture\n[Define the specialist subagents this system needs. One subagent per major capability or workflow phase.]\n\n```yaml\nsubagents:\n  - name: \"crawler-specialist\"\n    description: \"Delegate when: Need to fetch robots.txt, crawl a domain, build page inventory, or handle crawl failures. This subagent handles all website fetching and inventory construction.\"\n    tools: \"Read, Bash, Write\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"Fetch and parse robots.txt from target domain\"\n      - \"Crawl domain via Firecrawl API (or fallback to HTTP + BeautifulSoup)\"\n      - \"Build page inventory with URLs, titles, discovered_from metadata\"\n      - \"Check HTTP status codes and note accessibility issues\"\n      - \"Handle crawl failures and implement fallback strategies\"\n      - \"Respect robots.txt disallow rules and note compliance in output\"\n      - \"Apply rate limiting (1-2 req/sec) and exponential backoff on errors\"\n    inputs: \"domain string, max_pages integer, rate_limit_rps float\"\n    outputs: \"inventory.json with array of {url, canonical_url, title, discovered_from, http_status, content_hash, notes}\"\n\n  - name: \"relevance-ranker-specialist\"\n    description: \"Delegate when: Need to rank pages by relevance, apply heuristics, or perform semantic scoring. This subagent prioritizes which pages are most valuable for deep extraction.\"\n    tools: \"Read, Bash, Write\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"Load inventory.json from crawler-specialist\"\n      - \"Apply path-based heuristics (keywords like /pricing, /faq, /about, /terms)\"\n      - \"Perform lightweight semantic scoring on titles, headings, first N chars (if ANTHROPIC_API_KEY available)\"\n      - \"Assign relevance scores and categories (offers/pricing, policies, about, faq, contact, blog, other)\"\n      - \"De-duplicate URLs (canonicalize, cluster near-identical pages, keep best representative)\"\n      - \"Output ranked list with scores, reasons, and categories\"\n    inputs: \"inventory.json from crawler-specialist\"\n    outputs: \"ranked_pages.json with array of {url, canonical_url, rank, reasons: [string], category: string}\"\n\n  - name: \"deep-extract-specialist\"\n    description: \"Delegate when: Need to deep-scrape top K pages and extract structured business data. This subagent performs detailed content extraction with evidence capture.\"\n    tools: \"Read, Bash, Write\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"Load ranked_pages.json and select top K pages (default 10)\"\n      - \"Deep-scrape each page via Firecrawl scrape endpoint (or fallback to HTTP + BeautifulSoup)\"\n      - \"Extract structured fields: offers, pricing, guarantees, process_steps, faq, testimonials, contact_methods, policies, constraints\"\n      - \"Capture quoted evidence for each extracted claim (url + excerpt + page_title + extracted_at)\"\n      - \"Handle login/paywall pages gracefully (mark as inaccessible, log reason, continue)\"\n      - \"Output deep_extract.json with pages array\"\n    inputs: \"ranked_pages.json from relevance-ranker-specialist, top_k_deep_extract integer\"\n    outputs: \"deep_extract.json with {pages: [{url, extracted_at, extracted_entities, offers, pricing, how_it_works, faq, testimonials, policies, constraints}]}\"\n\n  - name: \"synthesis-validator-specialist\"\n    description: \"Delegate when: Need to synthesize findings into intelligence pack, validate evidence references, or run schema validation. This subagent produces the final deliverable.\"\n    tools: \"Read, Bash, Write\"\n    model: \"sonnet\"\n    permissionMode: \"default\"\n    responsibilities:\n      - \"Load inventory.json, ranked_pages.json, deep_extract.json\"\n      - \"Synthesize findings into structured JSON: positioning, offers_and_pricing, customer_journey, trust_signals, compliance_and_policies, unknowns_and_gaps\"\n      - \"Build evidence_index mapping evidence_id to {url, excerpt, page_title, extracted_at_iso}\"\n      - \"Validate that every claim in synthesized_findings has a reference in evidence_index\"\n      - \"Run JSON schema validation on final site_intelligence_pack.json\"\n      - \"Generate README.md (run report) with summary, key findings, robots compliance, issues encountered\"\n      - \"Output final site_intelligence_pack.json and README.md\"\n      - \"If fewer than 5 pages extracted, open GitHub Issue with failure summary and still commit partial output\"\n    inputs: \"inventory.json, ranked_pages.json, deep_extract.json\"\n    outputs: \"site_intelligence_pack.json (complete pack), README.md (human-readable report), optional GitHub Issue on major failure\"\n```\n\n### Agent Teams Analysis\n```yaml\n# Apply the 3+ Independent Tasks Rule\nindependent_tasks:\n  - \"None — all tasks have sequential dependencies\"\n\nindependent_task_count: \"0\"\nrecommendation: \"Sequential execution\"\nrationale: |\n  The system has clear data dependencies between phases:\n  1. Crawler must complete before ranker (ranker needs inventory)\n  2. Ranker must complete before deep-extract (deep-extract needs ranked list)\n  3. Deep-extract must complete before synthesis (synthesis needs extracted data)\n\n  For batch mode (multiple domains), each domain is technically independent, but we MUST process sequentially\n  to respect rate limits (1-2 req/sec across all domains). Parallel processing would violate rate limits and\n  trigger API blocks.\n\n  Therefore, Agent Teams is NOT recommended. Sequential execution is correct.\n\nsequential_rationale: |\n  All tasks depend on previous output (inventory → ranked → deep_extract → synthesis).\n  Batch mode must be sequential to respect rate limits.\n  No parallelization benefit without violating rate limits.\n```\n\n### GitHub Actions Triggers\n```yaml\ntriggers:\n  - type: \"workflow_dispatch\"\n    config:\n      inputs:\n        domain:\n          description: \"Target domain to analyze (e.g., example.com)\"\n          required: false\n        batch_csv_path:\n          description: \"Path to CSV file with batch targets (default: inputs/targets.csv)\"\n          required: false\n          default: \"inputs/targets.csv\"\n        max_pages:\n          description: \"Maximum pages to crawl per site\"\n          required: false\n          default: \"200\"\n        top_k_deep_extract:\n          description: \"Number of top-ranked pages to deep extract\"\n          required: false\n          default: \"10\"\n    description: \"Manual trigger for single-domain analysis or batch mode (if domain is empty, batch mode is used)\"\n\n  - type: \"schedule\"\n    config: \"0 2 * * *  # Nightly at 2 AM UTC (optional — user can enable/disable)\"\n    description: \"Optional nightly batch run — processes inputs/targets.csv for ongoing monitoring\"\n\n  - type: \"issues\"\n    config: \"opened with label 'site-analysis-request'\"\n    description: \"Agent HQ integration — opening an issue with label 'site-analysis-request' and body containing 'domain: example.com' triggers analysis\"\n```\n\n---\n\n## Implementation Blueprint\n\n### Workflow Steps\n[Ordered list of workflow phases. Each step becomes a section in workflow.md.]\n\n```yaml\nsteps:\n  - name: \"Input Validation and Mode Detection\"\n    description: |\n      Determine execution mode (single-domain or batch). Validate inputs.\n      Single-domain mode: domain input is provided.\n      Batch mode: domain input is empty, batch_csv_path points to CSV file.\n    subagent: \"none (main agent)\"\n    tools: []\n    inputs: \"domain (optional string), batch_csv_path (optional string)\"\n    outputs: \"mode (single | batch), targets list (single domain or list from CSV)\"\n    failure_mode: \"Invalid domain format, CSV file missing or malformed\"\n    fallback: \"Halt with clear error message — invalid inputs cannot proceed\"\n\n  - name: \"Robots.txt Fetch and Compliance Check\"\n    description: |\n      For each target domain, fetch https://{domain}/robots.txt and parse.\n      Identify disallowed paths for User-agent: *.\n      Note compliance in run metadata.\n    subagent: \"crawler-specialist\"\n    tools: [\"fetch_robots.py\"]\n    inputs: \"domain string\"\n    outputs: \"robots_info dict with {fetched_url, allowed_summary, disallowed_summary, raw_excerpt, disallowed_paths: [string]}\"\n    failure_mode: \"robots.txt not found (404) or unreachable\"\n    fallback: \"Assume all paths allowed (note in output: 'robots.txt not found, proceeding with caution')\"\n\n  - name: \"Crawl and Inventory Discovery\"\n    description: |\n      Crawl the domain via Firecrawl API (crawl mode) or fallback to HTTP + BeautifulSoup.\n      Build page inventory with URLs, titles, discovered_from, HTTP status.\n      Apply robots.txt disallow rules — skip disallowed paths.\n      Enforce max_pages limit (default 200).\n      Apply rate limiting (1-2 req/sec).\n      Attempt discovery of key pages: home, about, offers, pricing, faq, contact, policies, privacy, terms, blog.\n    subagent: \"crawler-specialist\"\n    tools: [\"crawl_domain.py\"]\n    inputs: \"domain string, max_pages integer, rate_limit_rps float, robots_info dict (disallowed_paths)\"\n    outputs: \"inventory.json with array of {url, canonical_url, title, discovered_from, http_status, content_hash, notes}\"\n    failure_mode: \"Firecrawl API fails (rate limit, timeout, auth error)\"\n    fallback: \"Switch to direct HTTP + BeautifulSoup for basic crawling (note loss of JS rendering in output)\"\n\n  - name: \"URL Canonicalization and De-duplication\"\n    description: |\n      For each page in inventory, canonicalize URL (lowercase host, strip utm params, normalize trailing slashes).\n      Hash visible text content (strip HTML, remove header/footer boilerplate).\n      Cluster pages with identical or near-identical content_hash.\n      Keep best representative from each cluster (prefer shorter URLs, non-query-string URLs).\n      Update inventory with canonical_url and dedup_cluster_id.\n    subagent: \"relevance-ranker-specialist\"\n    tools: [\"deduplicate_urls.py\"]\n    inputs: \"inventory.json from crawler-specialist\"\n    outputs: \"inventory.json updated with canonical_url and dedup_cluster_id\"\n    failure_mode: \"Content hashing error or malformed URL\"\n    fallback: \"Skip de-duplication for problematic URLs, log warning, continue with duplicates\"\n\n  - name: \"Page Relevance Ranking\"\n    description: |\n      Load inventory.json (post-deduplication).\n      Apply path-based heuristics: assign points for keywords in URL path (pricing=10, faq=8, about=7, contact=6, etc.).\n      Apply lightweight semantic scoring: extract title, h1-h3 headings, first 500 chars from each page.\n      Send to Claude for relevance scoring (0-10) based on business intelligence value (if ANTHROPIC_API_KEY available).\n      Combine heuristic + semantic scores (weighted).\n      Assign relevance category (offers/pricing, policies, about, faq, contact, blog, other).\n      Sort by score descending.\n      Output ranked list.\n    subagent: \"relevance-ranker-specialist\"\n    tools: [\"rank_pages.py\"]\n    inputs: \"inventory.json from crawler-specialist\"\n    outputs: \"ranked_pages.json with array of {url, canonical_url, rank, reasons: [string], category: string}\"\n    failure_mode: \"Semantic scoring fails (Claude API error or no ANTHROPIC_API_KEY)\"\n    fallback: \"Use heuristic-only scoring (path keywords), skip semantic component, log warning\"\n\n  - name: \"Deep Extract Structured Data\"\n    description: |\n      Load ranked_pages.json and select top K pages (default 10).\n      For each page, deep-scrape via Firecrawl scrape endpoint (structured mode) or fallback to HTTP + BeautifulSoup.\n      Extract structured fields: offers, pricing, guarantees, process_steps, faq, testimonials, contact_methods, policies, constraints.\n      Capture quoted evidence for each extracted claim (url + excerpt + page_title + extracted_at_iso).\n      Handle login/paywall pages: mark as inaccessible with reason, skip extraction, continue with remaining pages.\n      Apply rate limiting (1-2 req/sec).\n      Output deep_extract.json with pages array.\n    subagent: \"deep-extract-specialist\"\n    tools: [\"deep_extract.py\"]\n    inputs: \"ranked_pages.json from relevance-ranker-specialist, top_k_deep_extract integer\"\n    outputs: \"deep_extract.json with {pages: [{url, extracted_at, extracted_entities, offers, pricing, how_it_works, faq, testimonials, policies, constraints}]}\"\n    failure_mode: \"Firecrawl API fails, page requires auth, page is 404 or 500\"\n    fallback: \"Skip failed pages, log errors, continue with remaining pages; if fewer than 5 pages succeed, flag for GitHub Issue\"\n\n  - name: \"Synthesize Intelligence Pack\"\n    description: |\n      Load inventory.json, ranked_pages.json, deep_extract.json.\n      Synthesize findings into structured JSON sections:\n        - positioning: What the company does, target market, value proposition\n        - offers_and_pricing: Product/service offerings, pricing models, plans\n        - customer_journey: How customers engage (signup, onboarding, usage, support)\n        - trust_signals: Testimonials, case studies, guarantees, certifications\n        - compliance_and_policies: Privacy policy, terms of service, data handling, refund policy\n        - unknowns_and_gaps: What couldn't be determined from accessible pages\n      Build evidence_index: map evidence_id to {url, excerpt, page_title, extracted_at_iso}.\n      Ensure every claim in synthesized_findings references evidence_index.\n      Populate run_metadata: crawl statistics (pages_crawled, pages_ranked, pages_extracted, errors).\n      Assemble final site_intelligence_pack.json.\n    subagent: \"synthesis-validator-specialist\"\n    tools: [\"synthesize_pack.py\"]\n    inputs: \"inventory.json, ranked_pages.json, deep_extract.json\"\n    outputs: \"site_intelligence_pack.json (complete pack with all sections)\"\n    failure_mode: \"Missing evidence references, schema validation failure\"\n    fallback: \"Flag claims without evidence as [needs verification], note in unknowns_and_gaps section, continue\"\n\n  - name: \"Evidence Validation\"\n    description: |\n      Load site_intelligence_pack.json.\n      Validate that every claim in synthesized_findings has a corresponding evidence_index entry.\n      Check that evidence_index entries have all required fields (url, excerpt, extracted_at_iso).\n      Run JSON schema validation on the full pack.\n      Log any validation errors.\n    subagent: \"synthesis-validator-specialist\"\n    tools: [\"validate_evidence.py\"]\n    inputs: \"site_intelligence_pack.json from synthesis step\"\n    outputs: \"validation_report dict with {passed: bool, errors: [string]}\"\n    failure_mode: \"Validation fails (missing evidence, malformed JSON)\"\n    fallback: \"Log validation errors in run_metadata, flag site_intelligence_pack as 'partial' or 'needs_review', still commit\"\n\n  - name: \"Generate Run Report (README.md)\"\n    description: |\n      Generate human-readable summary report:\n        - Summary: domain, pages crawled, pages ranked, pages extracted, execution time\n        - Key Findings: high-level insights from synthesized_findings\n        - Robots.txt Compliance: summary of allowed/disallowed paths, compliance status\n        - Issues Encountered: any errors, inaccessible pages, validation warnings\n        - Output Files: links to inventory.json, ranked_pages.json, deep_extract.json, site_intelligence_pack.json\n      Write to README.md.\n    subagent: \"synthesis-validator-specialist\"\n    tools: [\"generate_report.py\"]\n    inputs: \"site_intelligence_pack.json, validation_report\"\n    outputs: \"README.md (human-readable run report)\"\n    failure_mode: \"Template rendering error\"\n    fallback: \"Generate minimal README with raw JSON summary, log error\"\n\n  - name: \"Commit Outputs to Repository\"\n    description: |\n      Stage output files: inventory.json, ranked_pages.json, deep_extract.json, site_intelligence_pack.json, README.md.\n      Commit to outputs/{domain}/ directory.\n      Use descriptive commit message: \"Site intelligence pack for {domain} ({pages_crawled} pages crawled, {pages_extracted} extracted)\"\n    subagent: \"none (main agent)\"\n    tools: [\"git\"]\n    inputs: \"All output JSON and README.md files\"\n    outputs: \"Git commit with outputs in outputs/{domain}/\"\n    failure_mode: \"Git commit fails (merge conflict, permission error)\"\n    fallback: \"Retry commit with rebase, if still fails, log error and exit\"\n\n  - name: \"Open GitHub Issue on Major Failure (Conditional)\"\n    description: |\n      If fewer than 5 pages were successfully extracted (from run_metadata), open a GitHub Issue:\n        - Title: \"Site intelligence pack failure: {domain} (only {N} pages extracted)\"\n        - Body: summary of errors, robots.txt status, inaccessible pages, suggested actions\n        - Labels: \"site-analysis-failure\", \"needs-review\"\n      Still commit partial output.\n    subagent: \"synthesis-validator-specialist\"\n    tools: [\"create_github_issue.py\"]\n    inputs: \"run_metadata, validation_report, domain\"\n    outputs: \"GitHub Issue URL (if created)\"\n    failure_mode: \"GitHub API fails (auth error, rate limit)\"\n    fallback: \"Log failure to open issue, continue (partial output is already committed)\"\n```\n\n### Tool Specifications\n[For each tool the system needs. Reference library/tool_catalog.md for reusable patterns.]\n\n```yaml\ntools:\n  - name: \"fetch_robots.py\"\n    purpose: \"Fetch and parse robots.txt from a domain, return allowed/disallowed paths for User-agent: *\"\n    catalog_pattern: \"rest_client (HTTP GET with fallback)\"\n    inputs:\n      - \"domain: str — Target domain (e.g., 'example.com')\"\n    outputs: \"{fetched_url: str, allowed_summary: str, disallowed_summary: str, raw_excerpt: str, disallowed_paths: [str]}\"\n    dependencies: [\"requests\", \"robotparser (stdlib)\"]\n    mcp_used: \"none (direct HTTP)\"\n    error_handling: \"404 or timeout → return empty disallowed_paths list, note 'robots.txt not found' in summary\"\n\n  - name: \"crawl_domain.py\"\n    purpose: \"Crawl a domain via Firecrawl API (or fallback to HTTP + BeautifulSoup), return page inventory\"\n    catalog_pattern: \"firecrawl_scrape (crawl mode) with HTTP fallback\"\n    inputs:\n      - \"domain: str — Target domain\"\n      - \"max_pages: int — Maximum pages to crawl (default 200)\"\n      - \"rate_limit_rps: float — Rate limit in requests per second (default 1.5)\"\n      - \"disallowed_paths: [str] — List of disallowed URL paths from robots.txt\"\n    outputs: \"[{url, canonical_url, title, discovered_from, http_status, content_hash, notes}]\"\n    dependencies: [\"firecrawl-py\", \"requests\", \"beautifulsoup4\", \"hashlib\"]\n    mcp_used: \"firecrawl (primary)\"\n    error_handling: \"Firecrawl API error → fallback to requests + BeautifulSoup (no JS rendering); log fallback in notes; rate limit hit → exponential backoff\"\n\n  - name: \"deduplicate_urls.py\"\n    purpose: \"Canonicalize URLs and de-duplicate near-identical pages by content hash\"\n    catalog_pattern: \"dedup (from tool_catalog.md) with URL normalization\"\n    inputs:\n      - \"inventory: [{url, content_hash, ...}] — Page inventory from crawl\"\n    outputs: \"[{url, canonical_url, dedup_cluster_id, ...}] — Updated inventory with canonical URLs and cluster IDs\"\n    dependencies: [\"urllib.parse (stdlib)\"]\n    mcp_used: \"none\"\n    error_handling: \"Malformed URL → skip canonicalization for that URL, log warning, keep original URL\"\n\n  - name: \"rank_pages.py\"\n    purpose: \"Rank pages by relevance using path heuristics + semantic scoring (optional)\"\n    catalog_pattern: \"llm_prompt (for semantic scoring) + filter_sort\"\n    inputs:\n      - \"inventory: [{url, title, ...}] — Page inventory from deduplication\"\n    outputs: \"[{url, canonical_url, rank, reasons: [str], category: str}]\"\n    dependencies: [\"anthropic\", \"re (stdlib)\"]\n    mcp_used: \"anthropic (optional — for semantic scoring)\"\n    error_handling: \"Claude API error or no ANTHROPIC_API_KEY → use heuristic-only scoring, log warning\"\n\n  - name: \"deep_extract.py\"\n    purpose: \"Deep-scrape top K pages and extract structured business data with evidence capture\"\n    catalog_pattern: \"firecrawl_scrape (scrape mode with structured output) + structured_extract\"\n    inputs:\n      - \"ranked_pages: [{url, ...}] — Ranked pages from ranker\"\n      - \"top_k: int — Number of top pages to extract (default 10)\"\n      - \"rate_limit_rps: float — Rate limit in requests per second\"\n    outputs: \"{pages: [{url, extracted_at, extracted_entities, offers, pricing, how_it_works, faq, testimonials, policies, constraints}]}\"\n    dependencies: [\"firecrawl-py\", \"anthropic\", \"requests\", \"beautifulsoup4\"]\n    mcp_used: \"firecrawl (primary), anthropic (for extraction)\"\n    error_handling: \"Page requires auth/paywall → mark as inaccessible, log reason, skip extraction; Firecrawl API error → fallback to requests + BeautifulSoup; extraction fails → log error, continue with next page\"\n\n  - name: \"synthesize_pack.py\"\n    purpose: \"Synthesize intelligence pack from inventory, ranked pages, and deep extracts with evidence index\"\n    catalog_pattern: \"llm_prompt (for synthesis) + custom assembly logic\"\n    inputs:\n      - \"inventory: [{...}] — Full inventory\"\n      - \"ranked_pages: [{...}] — Ranked pages\"\n      - \"deep_extract: {pages: [...]} — Deep-extracted data\"\n    outputs: \"{site, inventory, ranked_pages, deep_extract_notes, synthesized_findings, evidence_index, run_metadata}\"\n    dependencies: [\"anthropic\"]\n    mcp_used: \"anthropic\"\n    error_handling: \"Missing evidence for claim → flag as [needs verification], note in unknowns_and_gaps\"\n\n  - name: \"validate_evidence.py\"\n    purpose: \"Validate that all claims in synthesized_findings have evidence_index entries\"\n    catalog_pattern: \"custom validation logic\"\n    inputs:\n      - \"site_intelligence_pack: {...} — Full pack from synthesis\"\n    outputs: \"{passed: bool, errors: [str]}\"\n    dependencies: [\"jsonschema\"]\n    mcp_used: \"none\"\n    error_handling: \"Validation error → log errors, return passed=false, continue (validation report included in run_metadata)\"\n\n  - name: \"generate_report.py\"\n    purpose: \"Generate human-readable README.md from intelligence pack\"\n    catalog_pattern: \"custom reporting logic with markdown formatting\"\n    inputs:\n      - \"site_intelligence_pack: {...} — Full pack\"\n      - \"validation_report: {passed, errors} — Validation results\"\n    outputs: \"README.md (markdown string)\"\n    dependencies: [\"jinja2 (optional for templating)\"]\n    mcp_used: \"none\"\n    error_handling: \"Template rendering error → generate minimal README with JSON summary, log error\"\n\n  - name: \"create_github_issue.py\"\n    purpose: \"Open a GitHub Issue on major failure (fewer than 5 pages extracted)\"\n    catalog_pattern: \"github_create_issue (from tool_catalog.md)\"\n    inputs:\n      - \"repo: str — GitHub repo (owner/repo)\"\n      - \"domain: str — Target domain\"\n      - \"run_metadata: {...} — Run statistics and errors\"\n    outputs: \"{issue_url: str}\"\n    dependencies: [\"requests\"]\n    mcp_used: \"github (or direct GitHub REST API)\"\n    error_handling: \"GitHub API error → log failure, continue (partial output already committed)\"\n```\n\n### Per-Tool Pseudocode\n```python\n# fetch_robots.py\ndef main(domain: str) -> dict:\n    # PATTERN: rest_client with robotparser\n    # CRITICAL: Fetch https://{domain}/robots.txt BEFORE any crawling\n    import urllib.robotparser, requests\n    \n    robots_url = f\"https://{domain}/robots.txt\"\n    try:\n        resp = requests.get(robots_url, timeout=10)\n        resp.raise_for_status()\n        raw_text = resp.text\n    except Exception as e:\n        # robots.txt not found — assume all paths allowed\n        return {\n            \"fetched_url\": robots_url,\n            \"allowed_summary\": \"robots.txt not found, assuming all paths allowed\",\n            \"disallowed_summary\": \"None\",\n            \"raw_excerpt\": \"\",\n            \"disallowed_paths\": [],\n        }\n    \n    # Parse robots.txt\n    rp = urllib.robotparser.RobotFileParser()\n    rp.parse(raw_text.splitlines())\n    \n    # Extract disallowed paths for User-agent: *\n    disallowed_paths = [entry.path for entry in rp.entries if entry.useragents == [\"*\"] and not entry.allowance]\n    \n    return {\n        \"fetched_url\": robots_url,\n        \"allowed_summary\": \"Most paths allowed\" if len(disallowed_paths) < 10 else \"Many paths disallowed\",\n        \"disallowed_summary\": f\"Disallowed: {', '.join(disallowed_paths[:5])}\" if disallowed_paths else \"None\",\n        \"raw_excerpt\": raw_text[:500],\n        \"disallowed_paths\": disallowed_paths,\n    }\n\n# crawl_domain.py\ndef main(domain: str, max_pages: int, rate_limit_rps: float, disallowed_paths: list[str]) -> list[dict]:\n    # PATTERN: firecrawl_scrape with fallback to HTTP + BeautifulSoup\n    # CRITICAL: Respect rate_limit_rps — add sleep between requests\n    # CRITICAL: Skip URLs matching disallowed_paths from robots.txt\n    import os, time, hashlib\n    from firecrawl import FirecrawlApp\n    from urllib.parse import urlparse\n    \n    app = FirecrawlApp(api_key=os.environ.get(\"FIRECRAWL_API_KEY\"))\n    base_url = f\"https://{domain}\"\n    \n    try:\n        # Firecrawl crawl mode\n        result = app.crawl_url(base_url, params={\n            \"limit\": max_pages,\n            \"scrapeOptions\": {\"formats\": [\"markdown\"]},\n        })\n        pages = result.get(\"data\", [])\n    except Exception as e:\n        # FALLBACK: Direct HTTP + BeautifulSoup (no JS rendering)\n        import requests\n        from bs4 import BeautifulSoup\n        \n        pages = []\n        visited = set()\n        queue = [base_url]\n        \n        while queue and len(pages) < max_pages:\n            url = queue.pop(0)\n            if url in visited:\n                continue\n            visited.add(url)\n            \n            # Check robots.txt disallow\n            path = urlparse(url).path\n            if any(path.startswith(disallow) for disallow in disallowed_paths):\n                continue  # Skip disallowed path\n            \n            try:\n                time.sleep(1.0 / rate_limit_rps)  # Rate limit\n                resp = requests.get(url, timeout=10)\n                resp.raise_for_status()\n                soup = BeautifulSoup(resp.text, \"html.parser\")\n                \n                # Extract title\n                title = soup.title.string if soup.title else \"No title\"\n                \n                # Extract visible text for content hash\n                visible_text = soup.get_text(separator=\" \", strip=True)\n                content_hash = hashlib.md5(visible_text.encode()).hexdigest()\n                \n                pages.append({\n                    \"url\": url,\n                    \"title\": title,\n                    \"http_status\": resp.status_code,\n                    \"content_hash\": content_hash,\n                    \"notes\": \"Crawled via HTTP fallback (no JS rendering)\",\n                })\n                \n                # Extract links for further crawling\n                for link in soup.find_all(\"a\", href=True):\n                    href = link[\"href\"]\n                    if href.startswith(\"/\"):\n                        href = f\"https://{domain}{href}\"\n                    if href.startswith(base_url):\n                        queue.append(href)\n            except Exception as crawl_err:\n                continue  # Skip failed pages\n        \n    # De-duplicate and return inventory\n    inventory = []\n    for page in pages:\n        url = page.get(\"url\")\n        canonical_url = _canonicalize_url(url)  # Helper function for URL normalization\n        inventory.append({\n            \"url\": url,\n            \"canonical_url\": canonical_url,\n            \"title\": page.get(\"title\", \"\"),\n            \"discovered_from\": \"crawl\",\n            \"http_status\": page.get(\"http_status\", 200),\n            \"content_hash\": page.get(\"content_hash\", \"\"),\n            \"notes\": page.get(\"notes\", \"\"),\n        })\n    \n    return inventory\n\n# deduplicate_urls.py\ndef main(inventory: list[dict]) -> list[dict]:\n    # PATTERN: dedup with URL canonicalization\n    # CRITICAL: Canonicalize URLs (lowercase host, strip utm params, normalize trailing slashes)\n    from urllib.parse import urlparse, urlunparse, parse_qs, urlencode\n    \n    def canonicalize(url: str) -> str:\n        parsed = urlparse(url)\n        # Lowercase scheme and host\n        scheme = parsed.scheme.lower()\n        netloc = parsed.netloc.lower()\n        # Remove trailing slash EXCEPT for root\n        path = parsed.path.rstrip(\"/\") if parsed.path != \"/\" else parsed.path\n        # Strip tracking params\n        query_params = parse_qs(parsed.query)\n        filtered_params = {k: v for k, v in query_params.items() if not k.startswith(\"utm_\") and k not in [\"fbclid\", \"gclid\", \"ref\"]}\n        query = urlencode(filtered_params, doseq=True)\n        \n        return urlunparse((scheme, netloc, path, \"\", query, \"\"))\n    \n    # Cluster by content_hash\n    clusters = {}\n    for item in inventory:\n        content_hash = item.get(\"content_hash\", \"\")\n        if not content_hash:\n            continue\n        if content_hash not in clusters:\n            clusters[content_hash] = []\n        clusters[content_hash].append(item)\n    \n    # Keep best representative from each cluster (prefer shorter URLs)\n    deduped = []\n    for cluster_id, items in clusters.items():\n        best = min(items, key=lambda x: len(x[\"url\"]))  # Shortest URL\n        best[\"dedup_cluster_id\"] = cluster_id\n        deduped.append(best)\n    \n    return deduped\n\n# rank_pages.py\ndef main(inventory: list[dict]) -> list[dict]:\n    # PATTERN: llm_prompt (semantic scoring) + filter_sort (heuristic scoring)\n    # CRITICAL: Combine heuristic (path keywords) + semantic (Claude-based) scores\n    import os, re\n    from anthropic import Anthropic\n    \n    # Path-based heuristics\n    heuristic_keywords = {\n        \"pricing\": 10, \"price\": 10, \"plans\": 10, \"buy\": 9,\n        \"faq\": 8, \"help\": 7, \"support\": 7,\n        \"about\": 7, \"company\": 6, \"team\": 6,\n        \"contact\": 6, \"careers\": 5,\n        \"blog\": 4, \"news\": 4,\n        \"terms\": 5, \"privacy\": 5, \"legal\": 5,\n    }\n    \n    ranked = []\n    for item in inventory:\n        url = item[\"url\"]\n        path = url.lower()\n        \n        # Heuristic score\n        heuristic_score = 0\n        matched_keywords = []\n        for keyword, points in heuristic_keywords.items():\n            if keyword in path:\n                heuristic_score += points\n                matched_keywords.append(keyword)\n        \n        # Semantic score (optional)\n        semantic_score = 0\n        if os.environ.get(\"ANTHROPIC_API_KEY\"):\n            try:\n                client = Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n                title = item.get(\"title\", \"\")\n                prompt = f\"Rate the business intelligence value of this webpage for competitive analysis (0-10):\\nTitle: {title}\\nURL: {url}\"\n                msg = client.messages.create(\n                    model=\"claude-sonnet-4-20250514\",\n                    max_tokens=50,\n                    messages=[{\"role\": \"user\", \"content\": prompt}]\n                )\n                semantic_score = float(msg.content[0].text.strip())\n            except Exception:\n                semantic_score = 0\n        \n        # Combined score (weighted: 60% heuristic, 40% semantic)\n        total_score = (heuristic_score * 0.6) + (semantic_score * 0.4)\n        \n        # Assign category\n        category = \"other\"\n        if any(kw in path for kw in [\"pricing\", \"price\", \"plans\", \"buy\"]):\n            category = \"offers/pricing\"\n        elif any(kw in path for kw in [\"terms\", \"privacy\", \"legal\", \"policy\"]):\n            category = \"policies\"\n        elif any(kw in path for kw in [\"about\", \"company\", \"team\"]):\n            category = \"about\"\n        elif any(kw in path for kw in [\"faq\", \"help\", \"support\"]):\n            category = \"faq\"\n        elif any(kw in path for kw in [\"contact\", \"careers\"]):\n            category = \"contact\"\n        elif any(kw in path for kw in [\"blog\", \"news\"]):\n            category = \"blog\"\n        \n        ranked.append({\n            \"url\": url,\n            \"canonical_url\": item[\"canonical_url\"],\n            \"rank\": total_score,\n            \"reasons\": matched_keywords + ([f\"semantic_score={semantic_score}\"] if semantic_score > 0 else []),\n            \"category\": category,\n        })\n    \n    # Sort by rank descending\n    ranked.sort(key=lambda x: x[\"rank\"], reverse=True)\n    \n    return ranked\n\n# deep_extract.py\ndef main(ranked_pages: list[dict], top_k: int, rate_limit_rps: float) -> dict:\n    # PATTERN: firecrawl_scrape (scrape mode with structured output) + structured_extract\n    # CRITICAL: Capture evidence (url + excerpt + page_title) for each extracted claim\n    import os, time\n    from firecrawl import FirecrawlApp\n    from anthropic import Anthropic\n    \n    app = FirecrawlApp(api_key=os.environ.get(\"FIRECRAWL_API_KEY\"))\n    client = Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n    \n    top_pages = ranked_pages[:top_k]\n    extracted_pages = []\n    \n    for page in top_pages:\n        url = page[\"url\"]\n        \n        try:\n            time.sleep(1.0 / rate_limit_rps)  # Rate limit\n            \n            # Fetch page via Firecrawl\n            result = app.scrape_url(url, params={\"formats\": [\"markdown\"]})\n            markdown = result.get(\"markdown\", \"\")\n            title = result.get(\"metadata\", {}).get(\"title\", \"No title\")\n            \n            # Extract structured data via Claude\n            prompt = f\"\"\"Extract structured business intelligence from this webpage:\nTitle: {title}\nURL: {url}\n\nExtract and return JSON with these fields:\n- offers: [list of products/services offered]\n- pricing: [pricing information with amounts and plans]\n- how_it_works: [process steps or workflow]\n- faq: [frequently asked questions with answers]\n- testimonials: [customer quotes or case studies]\n- policies: [refund/guarantee/privacy policy highlights]\n- constraints: [limitations, requirements, or restrictions]\n\nFor each extracted item, include the exact quoted excerpt as evidence.\n\nContent:\n{markdown[:4000]}\n\"\"\"\n            \n            msg = client.messages.create(\n                model=\"claude-sonnet-4-20250514\",\n                max_tokens=4096,\n                messages=[{\"role\": \"user\", \"content\": prompt}]\n            )\n            \n            import json\n            extracted_data = json.loads(msg.content[0].text)\n            \n            extracted_pages.append({\n                \"url\": url,\n                \"extracted_at\": time.time(),\n                \"page_title\": title,\n                **extracted_data,\n            })\n        \n        except Exception as e:\n            # Log error, skip this page, continue\n            print(f\"Error extracting {url}: {e}\")\n            continue\n    \n    return {\"pages\": extracted_pages}\n\n# synthesize_pack.py\ndef main(inventory: list[dict], ranked_pages: list[dict], deep_extract: dict) -> dict:\n    # PATTERN: llm_prompt for synthesis + custom assembly\n    # CRITICAL: Build evidence_index mapping evidence_id to {url, excerpt, page_title, extracted_at_iso}\n    import os, time\n    from anthropic import Anthropic\n    \n    client = Anthropic(api_key=os.environ[\"ANTHROPIC_API_KEY\"])\n    \n    # Synthesize findings via Claude\n    synthesis_prompt = f\"\"\"Synthesize business intelligence findings from the extracted data below into these sections:\n\n1. positioning: What the company does, target market, value proposition\n2. offers_and_pricing: Product/service offerings, pricing models, plans\n3. customer_journey: How customers engage (signup, onboarding, usage, support)\n4. trust_signals: Testimonials, case studies, guarantees, certifications\n5. compliance_and_policies: Privacy policy, terms of service, data handling, refund policy\n6. unknowns_and_gaps: What couldn't be determined from accessible pages\n\nExtracted data:\n{deep_extract}\n\nReturn JSON with the above sections. For each claim, reference the source URL.\n\"\"\"\n    \n    msg = client.messages.create(\n        model=\"claude-sonnet-4-20250514\",\n        max_tokens=8192,\n        messages=[{\"role\": \"user\", \"content\": synthesis_prompt}]\n    )\n    \n    import json\n    synthesized_findings = json.loads(msg.content[0].text)\n    \n    # Build evidence_index\n    evidence_index = {}\n    evidence_counter = 1\n    for page in deep_extract.get(\"pages\", []):\n        url = page[\"url\"]\n        title = page.get(\"page_title\", \"\")\n        extracted_at = page.get(\"extracted_at\", time.time())\n        \n        # For each extracted field, create evidence entries\n        for field in [\"offers\", \"pricing\", \"how_it_works\", \"faq\", \"testimonials\", \"policies\"]:\n            items = page.get(field, [])\n            for item in items:\n                evidence_id = f\"ev{evidence_counter}\"\n                evidence_index[evidence_id] = {\n                    \"url\": url,\n                    \"excerpt\": str(item)[:200],  # Truncate excerpt to 200 chars\n                    \"page_title\": title,\n                    \"extracted_at_iso\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime(extracted_at)),\n                }\n                evidence_counter += 1\n    \n    # Assemble final pack\n    site_intelligence_pack = {\n        \"site\": {\n            \"target_url\": f\"https://{inventory[0]['canonical_url'].split('/')[2]}\",\n            \"domain\": inventory[0][\"canonical_url\"].split(\"/\")[2],\n            \"crawled_at_iso\": time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime()),\n            \"robots\": {},  # Populated from fetch_robots.py output\n        },\n        \"inventory\": inventory,\n        \"ranked_pages\": ranked_pages,\n        \"deep_extract_notes\": deep_extract,\n        \"synthesized_findings\": synthesized_findings,\n        \"evidence_index\": evidence_index,\n        \"run_metadata\": {\n            \"pages_crawled\": len(inventory),\n            \"pages_ranked\": len(ranked_pages),\n            \"pages_extracted\": len(deep_extract.get(\"pages\", [])),\n            \"errors\": [],\n        },\n    }\n    \n    return site_intelligence_pack\n\n# validate_evidence.py\ndef main(site_intelligence_pack: dict) -> dict:\n    # PATTERN: custom validation logic\n    # CRITICAL: Ensure every claim in synthesized_findings has evidence_index entry\n    \n    synthesized = site_intelligence_pack.get(\"synthesized_findings\", {})\n    evidence_index = site_intelligence_pack.get(\"evidence_index\", {})\n    \n    errors = []\n    \n    # Check that synthesized_findings sections exist\n    required_sections = [\"positioning\", \"offers_and_pricing\", \"customer_journey\", \"trust_signals\", \"compliance_and_policies\", \"unknowns_and_gaps\"]\n    for section in required_sections:\n        if section not in synthesized:\n            errors.append(f\"Missing required section: {section}\")\n    \n    # Check that evidence_index entries have required fields\n    for ev_id, ev_entry in evidence_index.items():\n        if \"url\" not in ev_entry:\n            errors.append(f\"Evidence entry {ev_id} missing 'url' field\")\n        if \"excerpt\" not in ev_entry:\n            errors.append(f\"Evidence entry {ev_id} missing 'excerpt' field\")\n        if \"extracted_at_iso\" not in ev_entry:\n            errors.append(f\"Evidence entry {ev_id} missing 'extracted_at_iso' field\")\n    \n    # TODO: Cross-check that synthesized claims reference evidence_index (more complex validation)\n    \n    return {\n        \"passed\": len(errors) == 0,\n        \"errors\": errors,\n    }\n\n# generate_report.py\ndef main(site_intelligence_pack: dict, validation_report: dict) -> str:\n    # PATTERN: custom reporting with markdown formatting\n    \n    site = site_intelligence_pack.get(\"site\", {})\n    run_metadata = site_intelligence_pack.get(\"run_metadata\", {})\n    synthesized = site_intelligence_pack.get(\"synthesized_findings\", {})\n    \n    report = f\"\"\"# Site Intelligence Pack: {site.get(\"domain\", \"Unknown\")}\n\n## Summary\n- **Target URL**: {site.get(\"target_url\", \"N/A\")}\n- **Crawled At**: {site.get(\"crawled_at_iso\", \"N/A\")}\n- **Pages Crawled**: {run_metadata.get(\"pages_crawled\", 0)}\n- **Pages Ranked**: {run_metadata.get(\"pages_ranked\", 0)}\n- **Pages Extracted**: {run_metadata.get(\"pages_extracted\", 0)}\n\n## Key Findings\n\n### Positioning\n{synthesized.get(\"positioning\", \"No data\")}\n\n### Offers and Pricing\n{synthesized.get(\"offers_and_pricing\", \"No data\")}\n\n### Customer Journey\n{synthesized.get(\"customer_journey\", \"No data\")}\n\n### Trust Signals\n{synthesized.get(\"trust_signals\", \"No data\")}\n\n### Compliance and Policies\n{synthesized.get(\"compliance_and_policies\", \"No data\")}\n\n### Unknowns and Gaps\n{synthesized.get(\"unknowns_and_gaps\", \"No data\")}\n\n## Robots.txt Compliance\n{site.get(\"robots\", {}).get(\"allowed_summary\", \"N/A\")}\n{site.get(\"robots\", {}).get(\"disallowed_summary\", \"N/A\")}\n\n## Issues Encountered\n{\"; \".join(run_metadata.get(\"errors\", [])) if run_metadata.get(\"errors\") else \"None\"}\n\n## Validation Status\n{\"✅ Passed\" if validation_report.get(\"passed\") else \"❌ Failed\"}\n{\"; \".join(validation_report.get(\"errors\", [])) if not validation_report.get(\"passed\") else \"\"}\n\n## Output Files\n- `inventory.json` — Full page inventory\n- `ranked_pages.json` — Pages ranked by relevance\n- `deep_extract.json` — Deep-extracted structured data\n- `site_intelligence_pack.json` — Complete intelligence pack\n\n---\nGenerated by Site Intelligence Pack system\n\"\"\"\n    \n    return report\n\n# create_github_issue.py\ndef main(repo: str, domain: str, run_metadata: dict) -> dict:\n    # PATTERN: github_create_issue\n    import os, requests\n    \n    pages_extracted = run_metadata.get(\"pages_extracted\", 0)\n    \n    if pages_extracted >= 5:\n        return {\"issue_url\": \"\"}  # No issue needed\n    \n    errors = run_metadata.get(\"errors\", [])\n    \n    title = f\"Site intelligence pack failure: {domain} (only {pages_extracted} pages extracted)\"\n    body = f\"\"\"## Summary\nThe site intelligence pack for **{domain}** failed to extract sufficient data.\n\n**Pages extracted**: {pages_extracted} (threshold: 5)\n\n## Errors\n{chr(10).join(f\"- {err}\" for err in errors)}\n\n## Suggested Actions\n1. Check robots.txt compliance\n2. Review inaccessible pages (login/paywall)\n3. Check Firecrawl API rate limits\n4. Review partial output in `outputs/{domain}/`\n\n---\nAuto-generated by Site Intelligence Pack system\n\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"token {os.environ['GITHUB_TOKEN']}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    \n    payload = {\n        \"title\": title,\n        \"body\": body,\n        \"labels\": [\"site-analysis-failure\", \"needs-review\"],\n    }\n    \n    resp = requests.post(\n        f\"https://api.github.com/repos/{repo}/issues\",\n        headers=headers,\n        json=payload,\n        timeout=15,\n    )\n    resp.raise_for_status()\n    \n    return {\"issue_url\": resp.json().get(\"html_url\", \"\")}\n```\n\n### Integration Points\n```yaml\nSECRETS:\n  - name: \"FIRECRAWL_API_KEY\"\n    purpose: \"Firecrawl API authentication for web crawling and scraping\"\n    required: true\n\n  - name: \"ANTHROPIC_API_KEY\"\n    purpose: \"Claude API for semantic scoring and synthesis\"\n    required: true\n\n  - name: \"GITHUB_TOKEN\"\n    purpose: \"GitHub API for opening issues on failures\"\n    required: true\n\nENVIRONMENT:\n  - file: \".env.example\"\n    vars:\n      - \"FIRECRAWL_API_KEY=your_firecrawl_api_key_here  # Required: Firecrawl API key\"\n      - \"ANTHROPIC_API_KEY=your_anthropic_api_key_here  # Required: Claude API key\"\n      - \"GITHUB_TOKEN=your_github_token_here  # Required: GitHub PAT for issue creation\"\n      - \"MAX_PAGES=200  # Optional: Maximum pages to crawl per site\"\n      - \"TOP_K_DEEP_EXTRACT=10  # Optional: Number of top-ranked pages to deep extract\"\n      - \"RATE_LIMIT_RPS=1.5  # Optional: Rate limit in requests per second\"\n\nDEPENDENCIES:\n  - file: \"requirements.txt\"\n    packages:\n      - \"firecrawl-py==1.0.0  # Firecrawl API client\"\n      - \"anthropic==0.40.0  # Claude API client\"\n      - \"requests==2.32.0  # HTTP client for fallback scraping and GitHub API\"\n      - \"beautifulsoup4==4.12.0  # HTML parsing for fallback scraping\"\n      - \"jsonschema==4.23.0  # JSON schema validation\"\n      - \"jinja2==3.1.4  # Optional: Template rendering for reports\"\n\nGITHUB_ACTIONS:\n  - trigger: \"workflow_dispatch\"\n    config: |\n      inputs:\n        domain:\n          description: 'Target domain to analyze (e.g., example.com)'\n          required: false\n        batch_csv_path:\n          description: 'Path to CSV file with batch targets (default: inputs/targets.csv)'\n          required: false\n          default: 'inputs/targets.csv'\n        max_pages:\n          description: 'Maximum pages to crawl per site'\n          required: false\n          default: '200'\n        top_k_deep_extract:\n          description: 'Number of top-ranked pages to deep extract'\n          required: false\n          default: '10'\n  \n  - trigger: \"schedule\"\n    config: \"0 2 * * *  # Nightly at 2 AM UTC (optional)\"\n  \n  - trigger: \"issues\"\n    config: \"opened with label 'site-analysis-request'\"\n```\n\n---\n\n## Validation Loop\n\n### Level 1: Syntax & Structure\n```bash\n# Run FIRST — every tool must pass before proceeding to Level 2\n# AST parse — verify valid Python syntax\npython -c \"import ast; ast.parse(open('tools/fetch_robots.py').read())\"\npython -c \"import ast; ast.parse(open('tools/crawl_domain.py').read())\"\npython -c \"import ast; ast.parse(open('tools/deduplicate_urls.py').read())\"\npython -c \"import ast; ast.parse(open('tools/rank_pages.py').read())\"\npython -c \"import ast; ast.parse(open('tools/deep_extract.py').read())\"\npython -c \"import ast; ast.parse(open('tools/synthesize_pack.py').read())\"\npython -c \"import ast; ast.parse(open('tools/validate_evidence.py').read())\"\npython -c \"import ast; ast.parse(open('tools/generate_report.py').read())\"\npython -c \"import ast; ast.parse(open('tools/create_github_issue.py').read())\"\n\n# Import check — verify no missing dependencies\npython -c \"import importlib; importlib.import_module('tools.fetch_robots')\"\npython -c \"import importlib; importlib.import_module('tools.crawl_domain')\"\npython -c \"import importlib; importlib.import_module('tools.deduplicate_urls')\"\npython -c \"import importlib; importlib.import_module('tools.rank_pages')\"\npython -c \"import importlib; importlib.import_module('tools.deep_extract')\"\npython -c \"import importlib; importlib.import_module('tools.synthesize_pack')\"\npython -c \"import importlib; importlib.import_module('tools.validate_evidence')\"\npython -c \"import importlib; importlib.import_module('tools.generate_report')\"\npython -c \"import importlib; importlib.import_module('tools.create_github_issue')\"\n\n# Structure check — verify main() exists\npython -c \"from tools.fetch_robots import main; assert callable(main)\"\npython -c \"from tools.crawl_domain import main; assert callable(main)\"\npython -c \"from tools.deduplicate_urls import main; assert callable(main)\"\npython -c \"from tools.rank_pages import main; assert callable(main)\"\npython -c \"from tools.deep_extract import main; assert callable(main)\"\npython -c \"from tools.synthesize_pack import main; assert callable(main)\"\npython -c \"from tools.validate_evidence import main; assert callable(main)\"\npython -c \"from tools.generate_report import main; assert callable(main)\"\npython -c \"from tools.create_github_issue import main; assert callable(main)\"\n\n# Expected: All pass with no errors. If any fail, fix before proceeding.\n```\n\n### Level 2: Unit Tests\n```bash\n# Run SECOND — each tool must produce correct output for sample inputs\n# Test each tool independently with mock/sample data\n\n# Test fetch_robots\npython tools/fetch_robots.py --domain \"example.com\"\n# Expected output: JSON with fetched_url, allowed_summary, disallowed_summary, disallowed_paths\n\n# Test crawl_domain (limited to 5 pages for testing)\npython tools/crawl_domain.py --domain \"example.com\" --max_pages 5 --rate_limit_rps 1.0 --disallowed_paths \"[]\"\n# Expected output: JSON array with URLs, titles, http_status, content_hash\n\n# Test deduplicate_urls\necho '[{\"url\": \"https://example.com/page\", \"content_hash\": \"abc123\"}, {\"url\": \"https://example.com/page?utm_source=test\", \"content_hash\": \"abc123\"}]' > /tmp/inventory.json\npython tools/deduplicate_urls.py --inventory /tmp/inventory.json\n# Expected output: JSON array with 1 entry (deduped), canonical_url, dedup_cluster_id\n\n# Test rank_pages\necho '[{\"url\": \"https://example.com/pricing\", \"title\": \"Pricing Plans\"}, {\"url\": \"https://example.com/about\", \"title\": \"About Us\"}]' > /tmp/inventory.json\npython tools/rank_pages.py --inventory /tmp/inventory.json\n# Expected output: JSON array with ranked pages, reasons, categories\n\n# Test deep_extract\necho '[{\"url\": \"https://example.com/pricing\", \"canonical_url\": \"https://example.com/pricing\"}]' > /tmp/ranked.json\npython tools/deep_extract.py --ranked_pages /tmp/ranked.json --top_k 1 --rate_limit_rps 1.0\n# Expected output: JSON with pages array containing extracted fields\n\n# Test synthesize_pack\npython tools/synthesize_pack.py --inventory /tmp/inventory.json --ranked_pages /tmp/ranked.json --deep_extract /tmp/deep_extract.json\n# Expected output: Complete site_intelligence_pack.json\n\n# Test validate_evidence\npython tools/validate_evidence.py --site_intelligence_pack /tmp/site_intelligence_pack.json\n# Expected output: {passed: true/false, errors: [...]}\n\n# Test generate_report\npython tools/generate_report.py --site_intelligence_pack /tmp/site_intelligence_pack.json --validation_report /tmp/validation.json\n# Expected output: Markdown string (README.md content)\n\n# Test create_github_issue (dry-run mode with mock data)\npython tools/create_github_issue.py --repo \"owner/repo\" --domain \"example.com\" --run_metadata '{\"pages_extracted\": 2, \"errors\": [\"Firecrawl API error\"]}'\n# Expected output: {issue_url: \"https://github.com/owner/repo/issues/123\"} (if pages_extracted < 5)\n\n# If any tool fails: Read the error, fix the root cause, re-run.\n# NEVER mock to make tests pass — fix the actual code.\n```\n\n### Level 3: Integration Tests\n```bash\n# Run THIRD — verify tools work together as a pipeline\n# Simulate the full workflow with sample data\n\n# Step 1: Fetch robots.txt\npython tools/fetch_robots.py --domain \"example.com\" > /tmp/robots.json\n\n# Step 2: Crawl domain (limited to 10 pages for testing)\npython tools/crawl_domain.py --domain \"example.com\" --max_pages 10 --rate_limit_rps 1.0 --disallowed_paths \"$(jq -r '.disallowed_paths | @json' /tmp/robots.json)\" > /tmp/inventory.json\n\n# Step 3: Deduplicate URLs\npython tools/deduplicate_urls.py --inventory /tmp/inventory.json > /tmp/inventory_deduped.json\n\n# Step 4: Rank pages\npython tools/rank_pages.py --inventory /tmp/inventory_deduped.json > /tmp/ranked_pages.json\n\n# Step 5: Deep extract top 3 pages\npython tools/deep_extract.py --ranked_pages /tmp/ranked_pages.json --top_k 3 --rate_limit_rps 1.0 > /tmp/deep_extract.json\n\n# Step 6: Synthesize intelligence pack\npython tools/synthesize_pack.py --inventory /tmp/inventory_deduped.json --ranked_pages /tmp/ranked_pages.json --deep_extract /tmp/deep_extract.json > /tmp/site_intelligence_pack.json\n\n# Step 7: Validate evidence\npython tools/validate_evidence.py --site_intelligence_pack /tmp/site_intelligence_pack.json > /tmp/validation_report.json\n\n# Step 8: Generate README\npython tools/generate_report.py --site_intelligence_pack /tmp/site_intelligence_pack.json --validation_report /tmp/validation_report.json > /tmp/README.md\n\n# Verify final outputs\npython -c \"\nimport json\npack = json.load(open('/tmp/site_intelligence_pack.json'))\nassert 'site' in pack, 'Missing site section'\nassert 'inventory' in pack, 'Missing inventory'\nassert 'ranked_pages' in pack, 'Missing ranked_pages'\nassert 'deep_extract_notes' in pack, 'Missing deep_extract_notes'\nassert 'synthesized_findings' in pack, 'Missing synthesized_findings'\nassert 'evidence_index' in pack, 'Missing evidence_index'\nassert 'run_metadata' in pack, 'Missing run_metadata'\nprint('✅ Integration test passed')\n\"\n\n# Verify workflow.md references match actual tool files\n# Verify CLAUDE.md documents all tools and subagents\n# Verify .github/workflows/ YAML is valid\n```\n\n---\n\n## Final Validation Checklist\n- [ ] All tools pass Level 1 (syntax, imports, structure)\n- [ ] All tools pass Level 2 (unit tests with sample data)\n- [ ] Pipeline passes Level 3 (integration test end-to-end)\n- [ ] workflow.md has failure modes and fallbacks for every step\n- [ ] CLAUDE.md documents all tools, subagents, MCPs, and secrets\n- [ ] .github/workflows/ has timeout-minutes and failure notifications\n- [ ] .env.example lists all required environment variables\n- [ ] .gitignore excludes .env, __pycache__/, credentials\n- [ ] README.md covers all three execution paths (CLI, Actions, Agent HQ)\n- [ ] No hardcoded secrets anywhere in the codebase\n- [ ] Subagent files have valid YAML frontmatter and specific system prompts\n- [ ] requirements.txt lists all Python dependencies\n- [ ] robots.txt compliance is enforced (fetch first, skip disallowed paths)\n- [ ] Evidence validation is implemented (all claims reference evidence_index)\n- [ ] De-duplication is implemented (URL canonicalization + content hashing)\n- [ ] Rate limiting is implemented (1-2 req/sec with exponential backoff)\n- [ ] GitHub Issue creation on major failure (fewer than 5 pages extracted)\n- [ ] Fallback chain is implemented (Firecrawl → HTTP + BeautifulSoup → partial output)\n\n---\n\n## Anti-Patterns to Avoid\n- Do not hardcode API keys, tokens, or credentials — use GitHub Secrets or .env\n- Do not use `git add -A` or `git add .` — stage only specific files\n- Do not skip validation because \"it should work\" — run all three levels\n- Do not catch bare `except:` — always catch specific exception types\n- Do not build tools that require interactive input — all tools must run unattended\n- Do not create MCP-dependent tools without HTTP/API fallbacks\n- Do not design subagents that call other subagents — only the main agent delegates\n- Do not use Agent Teams when fewer than 3 independent tasks exist — the overhead is not justified\n- Do not commit .env files, credentials, or API keys to the repository\n- Do not ignore failing tests — fix the root cause, never mock to pass\n- Do not generate workflow steps without failure modes and fallback actions\n- Do not write tools without try/except, logging, type hints, and a main() function\n- Do not skip robots.txt compliance check — MUST fetch and parse robots.txt before any crawling\n- Do not proceed with crawling if robots.txt disallows it — respect the rules, note in output\n- Do not store evidence without url + excerpt + page_title + extracted_at — all evidence must be traceable\n- Do not synthesize findings without evidence validation — every claim must reference evidence_index\n- Do not skip de-duplication — URL canonicalization and content hashing are MANDATORY\n- Do not exceed rate limits — implement delays and exponential backoff\n\n---\n\n## Confidence Score: 9/10\n\n**Score rationale:**\n- [System Architecture]: High confidence — subagent architecture is clear, workflow phases are well-defined, tools are scoped correctly — Confidence: high\n- [Technical Feasibility]: High confidence — all required MCPs and APIs are available (Firecrawl, Anthropic, GitHub), fallback strategies are defined, rate limiting is implementable — Confidence: high\n- [Validation Strategy]: High confidence — three-level validation (syntax, unit, integration) is comprehensive, test cases are specific, integration test covers full pipeline — Confidence: high\n- [Evidence & Compliance Requirements]: High confidence — robots.txt compliance is enforceable, evidence validation is well-specified, de-duplication logic is clear — Confidence: high\n- [Failure Modes & Fallbacks]: Medium-high confidence — fallback chains are defined (Firecrawl → HTTP), GitHub Issue creation on failure is specified, partial output handling is clear; uncertainty around edge cases (e.g., extremely large sites, rate limit exhaustion) — Confidence: medium-high\n- [Batch Mode Scalability]: Medium confidence — sequential processing respects rate limits but may be slow for large batches (200 domains * 200 pages * 1.5 RPS = ~27,000 seconds = 7.5 hours); recommendation: batch processing is feasible but slow, may need chunking for very large batches — Confidence: medium\n\n**Ambiguity flags** (areas requiring clarification before building):\n- [ ] **Batch processing scale**: If inputs/targets.csv has 200+ domains, the nightly job may exceed reasonable runtime (7+ hours). Should we implement chunking (e.g., process 20 domains per run, rotate through the list)? Or is sequential processing acceptable for the expected batch sizes?\n- [ ] **Semantic scoring model**: For lightweight semantic scoring (titles/headings/first N chars), should we use Claude Sonnet 4 (more accurate but slower/costlier) or Claude Haiku (faster/cheaper but less nuanced)? Or make it configurable?\n\n**If any ambiguity flag is checked, DO NOT proceed to build. Ask the user to clarify first.**\n\n---\n\n## Factory Build Prompt\n\nWhen this PRP is ready, execute the build with:\n\n```\n/execute-prp PRPs/site-intelligence-pack.md\n```\n\nThis will trigger `factory/workflow.md` with the above requirements as structured input.\n"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":14,"output":20225,"cacheRead":9713,"cacheWrite":37310,"totalTokens":67262,"cost":{"input":0.000042000000000000004,"output":0.303375,"cacheRead":0.0029139,"cacheWrite":0.1399125,"total":0.4462434}},"stopReason":"toolUse","timestamp":1771078863253}}
{"type":"message","id":"a2a9f676","parentId":"2fea74e3","timestamp":"2026-02-14T14:26:42.080Z","message":{"role":"toolResult","toolCallId":"toolu_01Fm5ofmurdJ66YjS5eY4TpF","toolName":"write","content":[{"type":"text","text":"Successfully wrote 71278 bytes to PRPs/site-intelligence-pack.md"}],"isError":false,"timestamp":1771079202079}}
{"type":"message","id":"e894a1ae","parentId":"a2a9f676","timestamp":"2026-02-14T14:26:47.599Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Great! I've successfully generated a comprehensive PRP for the site-intelligence-pack system. Now I need to commit this file to the repository with the confidence score in the commit message as required.\n\nThe confidence score is 9/10, and I have two ambiguity flags that need user clarification before building:\n1. Batch processing scale concerns (200+ domains may take 7+ hours)\n2. Semantic scoring model selection (Sonnet 4 vs Haiku)\n\nNow let me commit this PRP with the confidence score in the commit message.","thinkingSignature":"EqkFCkYICxgCKkBeiO2K/2+rdUYk8cEWffcmGqk3vO4pw+pNRnOdUjFcm6vrJ4ToOpa1Ej30c0pvdWNhszRIiWmYvNiotBN7wXdWEgzCwnWIyAmk6SNaS2waDO7mfqiIL5xGmxH9HSIwOAWGsU6+DHSCgDeTdoHI5j2IqKSo4hFRlvA7M6fjc0OA+4nHVVY7PSs9LOG3+l1nKpAES3ORRi+z5FB60TkJoZs0SV5KW4qrvkNbuDbY2AS3pkGX0BqCrxE8PVY3djDbrCJ+dylx34cciU127o6hpI1YwyYRZVY/iYmEDJBKXd/Rjhusb/RfzgNm/JY0oZL++mCo0N78+348QuxQbctSRwz5nPGjHkQGHcx5F3Tys05u3Z903U/UrKxR6+XzGJeTjTUoDobS+dlvA0iMSqeRVhk4L0d0ywNfe6BCQkBU/hBvqgvbhYooZopolDGvCPs8r9Yic9sm8e6pnTBsas4zlcPkAslxVPrGysCQtZ8lM43BQC+RS8dVfCD+nXlXmgKlo3qKbW2hvN921pSNE1UnsPHWMfFpstIWOQW5yZ8E2Knc24eCMNj0TB26kX8UW/UnExxXlb7Tk0v5AsHkuvoFdh+bKJ8jEh9ziJYdLfn4VyDVpjKhu0QH5oltOOMwuAniXFMTKRFgDXunWtCM2clroeNlylivIl1K1WxV9By0+KiHssSZ0YSnEm8/BYKKGrm5VVRhl4BaYDi7k/LNnKVvW6dXXGPk034G0pSPbXOOqCtfdH+sVYt5Rk2V9KZuxLeAj7+13ei9Ri+V99kGQ8orMROMU19xeBlQEqVJ/RzkHDbpMyVisMY2h1u+LJvuzddS/gdY/gt4V1j57j40alYd7vPpOW/PDZZwCXDq0uZm15sy7zSx7mWUhYk11PQwbG2RCRuVGAE="},{"type":"text","text":"Perfect! I've generated a comprehensive PRP for the site-intelligence-pack system. Now I'll commit it to the repository with the confidence score in the commit message."},{"type":"toolCall","id":"toolu_01We9y7KrqddMP5fH22dbpSp","name":"bash","arguments":{"command":"cd /job && git add PRPs/site-intelligence-pack.md"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":13,"output":232,"cacheRead":0,"cacheWrite":67274,"totalTokens":67519,"cost":{"input":0.000039,"output":0.00348,"cacheRead":0,"cacheWrite":0.2522775,"total":0.2557965}},"stopReason":"toolUse","timestamp":1771079202080}}
{"type":"message","id":"f63a7e16","parentId":"e894a1ae","timestamp":"2026-02-14T14:26:47.681Z","message":{"role":"toolResult","toolCallId":"toolu_01We9y7KrqddMP5fH22dbpSp","toolName":"bash","content":[{"type":"text","text":"(no output)"}],"isError":false,"timestamp":1771079207681}}
{"type":"message","id":"69bb8b06","parentId":"f63a7e16","timestamp":"2026-02-14T14:26:56.915Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Good, the file has been staged. Now I'll commit it with the confidence score in the commit message.","thinkingSignature":"EosCCkYICxgCKkCmaGFUTq/M0UCdlu3lNPBgdOyZkEW1DKiDkqEZuXPVu6DwrAnZHv6jXi+4W/emBgYzK+VFc1QNjiox/f3qCCaJEgyfmX71OECcb4vOqakaDKZ8ojlyXCj0jTPKtSIwsq+QXoNztImwJgPi9694yeZy9g5NdSKz+TGlwer1DkHK+YHlOcQZ1vT67ysBtZ9JKnMT1EWyiuzZTJWm2IT7RdQDnXxsUmQfvjUmEQBTkDUv6RiJzCG3xo2LTnG01R1dppczfg7lOc42NC4WPhIvzRhXB6kW55wZ1VuHcQw2FpiCzyKdbldrbtLb4fFr9tPn7PT64qDPY3l0p982OOUUbhZkjX4IGAE="},{"type":"toolCall","id":"toolu_013NFyMAdvJ4Zor6m69GsCNB","name":"bash","arguments":{"command":"cd /job && git commit -m \"Generate PRP for site-intelligence-pack system\n\nComprehensive website analysis system with three specialist components:\n- crawler-specialist: Fetches robots.txt, crawls domain, builds inventory\n- relevance-ranker-specialist: Ranks pages using heuristics + semantic scoring\n- deep-extract-specialist: Deep-scrapes top K pages, extracts structured data\n- synthesis-validator-specialist: Builds intelligence pack, validates evidence\n\nKey features:\n- Respects robots.txt (fetches first, skips disallowed paths)\n- Evidence-backed findings (every claim has url + excerpt)\n- De-duplication (URL canonicalization + content hashing)\n- Rate limiting (1-2 req/sec with exponential backoff)\n- Fallback chain (Firecrawl → HTTP + BeautifulSoup)\n- GitHub Issue on major failure (< 5 pages extracted)\n- Batch mode support (CSV input for multiple domains)\n\nWorkflow pattern: Scrape > Process > Output (multi-phase)\nExecution modes: Single-domain (workflow_dispatch) + Batch (scheduled/CSV)\nOutput: JSON intelligence pack + README committed to outputs/{domain}/\n\nAmbiguity flags (need clarification before build):\n1. Batch processing scale: 200+ domains may take 7+ hours sequentially\n2. Semantic scoring model: Sonnet 4 (accurate) vs Haiku (fast/cheap)\n\nCONFIDENCE_SCORE: 9/10\""}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":12,"output":428,"cacheRead":67274,"cacheWrite":254,"totalTokens":67968,"cost":{"input":0.000036,"output":0.00642,"cacheRead":0.020182199999999997,"cacheWrite":0.0009525,"total":0.027590699999999996}},"stopReason":"toolUse","timestamp":1771079207682}}
{"type":"message","id":"217cf837","parentId":"69bb8b06","timestamp":"2026-02-14T14:26:56.930Z","message":{"role":"toolResult","toolCallId":"toolu_013NFyMAdvJ4Zor6m69GsCNB","toolName":"bash","content":[{"type":"text","text":"[job/4d9e5ef2-c3d9-47e3-a1d9-852dac7715eb 72f05ea] Generate PRP for site-intelligence-pack system\n 1 file changed, 1485 insertions(+)\n create mode 100644 PRPs/site-intelligence-pack.md\n"}],"isError":false,"timestamp":1771079216928}}
{"type":"message","id":"915a132d","parentId":"217cf837","timestamp":"2026-02-14T14:26:59.347Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Perfect! I've successfully committed the PRP with the confidence score in the commit message. Now let me create a summary of what was generated and any next steps.","thinkingSignature":"EswCCkYICxgCKkDR7rJ/tFzXfiRqpR4ZkbpkCM4fmv+/3Hnn+Q3BopThiR7FysvUNSBkCIuiwyw0peQLPlPQc6x214QqaRiyS470EgwgEeitR1Lysfy6664aDO0NDdrFAaNhXY6MayIwEhl9Ci5wJ8131ACnjzujQNFo1XzUi0X72J3bRHRmAHGJZnIUAEPETSoWY7cuS5UBKrMBc8oS9X84fGGA6QRteBFNhwC2LiAQkiqCOoW/lEZAsAJAGUBm/EX6VHwKCfZqaJ8ohbCrtYicy+oLtwI5UoM8EfElL78QdBhNuuZPJ8wFb5pqzY/GO4Vuo0WIhtdm3wNipVh8AcjJidYODdKt4N2OTaMCGqIFCQJT+BJnAs7Xh9eR8xcNz2zLHEC3iqqK02oahF7nuBd3zOMoxSW1wsiuy5BMUCx3gAvWBZGTB31cCH2IoSMYAQ=="},{"type":"toolCall","id":"toolu_01SKY2GuiUYJ65x3yUZq5cwh","name":"bash","arguments":{"command":"cd /job && git log -1 --stat"}}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":12,"output":102,"cacheRead":67528,"cacheWrite":528,"totalTokens":68170,"cost":{"input":0.000036,"output":0.0015300000000000001,"cacheRead":0.0202584,"cacheWrite":0.00198,"total":0.0238044}},"stopReason":"toolUse","timestamp":1771079216930}}
{"type":"message","id":"ee3078b9","parentId":"915a132d","timestamp":"2026-02-14T14:26:59.351Z","message":{"role":"toolResult","toolCallId":"toolu_01SKY2GuiUYJ65x3yUZq5cwh","toolName":"bash","content":[{"type":"text","text":"commit 72f05ea42759532f82ec718a8e29d5cfcb9eb7e2\nAuthor: Brismi428 <150686088+Brismi428@users.noreply.github.com>\nDate:   Sat Feb 14 14:26:56 2026 +0000\n\n    Generate PRP for site-intelligence-pack system\n    \n    Comprehensive website analysis system with three specialist components:\n    - crawler-specialist: Fetches robots.txt, crawls domain, builds inventory\n    - relevance-ranker-specialist: Ranks pages using heuristics + semantic scoring\n    - deep-extract-specialist: Deep-scrapes top K pages, extracts structured data\n    - synthesis-validator-specialist: Builds intelligence pack, validates evidence\n    \n    Key features:\n    - Respects robots.txt (fetches first, skips disallowed paths)\n    - Evidence-backed findings (every claim has url + excerpt)\n    - De-duplication (URL canonicalization + content hashing)\n    - Rate limiting (1-2 req/sec with exponential backoff)\n    - Fallback chain (Firecrawl → HTTP + BeautifulSoup)\n    - GitHub Issue on major failure (< 5 pages extracted)\n    - Batch mode support (CSV input for multiple domains)\n    \n    Workflow pattern: Scrape > Process > Output (multi-phase)\n    Execution modes: Single-domain (workflow_dispatch) + Batch (scheduled/CSV)\n    Output: JSON intelligence pack + README committed to outputs/{domain}/\n    \n    Ambiguity flags (need clarification before build):\n    1. Batch processing scale: 200+ domains may take 7+ hours sequentially\n    2. Semantic scoring model: Sonnet 4 (accurate) vs Haiku (fast/cheap)\n    \n    CONFIDENCE_SCORE: 9/10\n\n PRPs/site-intelligence-pack.md | 1485 ++++++++++++++++++++++++++++++++++++++++\n 1 file changed, 1485 insertions(+)\n"}],"isError":false,"timestamp":1771079219350}}
{"type":"message","id":"6113d93c","parentId":"ee3078b9","timestamp":"2026-02-14T14:27:17.566Z","message":{"role":"assistant","content":[{"type":"thinking","thinking":"Excellent! The commit was successful and includes the confidence score. Now let me write a job completion summary to explain what was accomplished.","thinkingSignature":"ErwCCkYICxgCKkAFEka1qzYN8Ihesq/HNMGxE+gN/VETBdo1AE4lra6r3r7JOjY7XX1D09pzqlmFsMDykoFiicRwfuQQCOkEFT96EgyhVkpSnOubKUCcTn4aDC+tmavRzH7zq8Dy2yIwOA2bDT+FKW/OuKFNLKodgE6LrqteFDkiYlJZ6yyG6qAyQnzJ90snD3Ppr5HQc+CIKqMBgUeYHFbAGSuu1pcpumwGoKtulrN7riwwdtUVo6Os4N5BrAo+COBZNB7qyccNzVSib0VKV2OgrJJR8XbOEkX9819O8lgGoEzHwLwQg/fEiiMvi2Ie711FypsftpPvW+E3vEkE8FxwZ5GhES7RuLdswJaBRU6JyAjtZ//WMOKSnH9Z1vJBpN9eNnV9nbjRK7pO8VF4XU/yInVw597MBo9PwtE8ZhgB"},{"type":"text","text":"## Job Complete: PRP Generated for Site Intelligence Pack System\n\nI've successfully generated a comprehensive Product Requirements Prompt (PRP) for the **site-intelligence-pack** system and committed it to `PRPs/site-intelligence-pack.md`.\n\n### What Was Generated\n\nA **71KB, 1,485-line PRP** that includes:\n\n#### System Overview\n- **Three specialist components** working in a multi-phase pipeline:\n  - `crawler-specialist` — Fetches robots.txt, crawls domains, builds page inventory\n  - `relevance-ranker-specialist` — Ranks pages using heuristics + semantic scoring\n  - `deep-extract-specialist` — Deep-scrapes top K pages for structured data extraction\n  - `synthesis-validator-specialist` — Synthesizes intelligence pack, validates evidence\n\n#### Core Features\n✅ **Robots.txt compliance** — Fetches and parses robots.txt before any crawling\n✅ **Evidence-backed findings** — Every claim maps to evidence_index with url + excerpt\n✅ **URL de-duplication** — Canonicalization (strip utm params, normalize slashes) + content hashing\n✅ **Rate limiting** — 1-2 req/sec with exponential backoff on errors\n✅ **Fallback chain** — Firecrawl → HTTP + BeautifulSoup → partial output\n✅ **Failure handling** — Opens GitHub Issue if fewer than 5 pages extracted\n✅ **Batch mode** — Processes CSV input for multiple domains sequentially\n\n#### Technical Specifications\n- **9 Python tools** with complete pseudocode\n- **4 subagent definitions** with responsibilities and tool access\n- **3-level validation** (syntax, unit, integration tests)\n- **Workflow pattern**: Scrape > Process > Output (multi-phase)\n- **Execution modes**: Single-domain (workflow_dispatch) + Batch (scheduled/CSV)\n- **Output format**: JSON intelligence pack + human-readable README\n\n### Confidence Score: 9/10\n\n**High confidence** across most areas:\n- ✅ System architecture is clear and well-scoped\n- ✅ All required MCPs and APIs are available\n- ✅ Validation strategy is comprehensive\n- ✅ Robots.txt compliance and evidence validation are enforceable\n- ⚠️ **Minor concerns**: Batch processing scalability for 200+ domains (7+ hours sequential)\n\n### Ambiguity Flags (Requires Clarification Before Build)\n\n🚨 **Two ambiguities need resolution before executing the build:**\n\n1. **Batch processing scale**: If `inputs/targets.csv` has 200+ domains, the nightly job may take 7+ hours (200 domains × 200 pages × 1.5 RPS). Should we:\n   - Accept sequential processing for expected batch sizes?\n   - Implement chunking (process 20 domains per run, rotate through the list)?\n   - Add a configurable batch size limit?\n\n2. **Semantic scoring model**: For lightweight semantic scoring (titles/headings/first N chars), which model should we use?\n   - **Claude Sonnet 4**: More accurate, better reasoning, but slower and ~10x more expensive\n   - **Claude Haiku**: Faster, cheaper, but less nuanced scoring\n   - **Configurable**: Let users choose via environment variable\n\n### Next Steps\n\n**Do NOT proceed to build** until the ambiguity flags are resolved. To continue:\n\n1. **Review the PRP**: `PRPs/site-intelligence-pack.md`\n2. **Clarify ambiguities**: Answer the two questions above\n3. **Execute the build**: Once clarified, run `/execute-prp PRPs/site-intelligence-pack.md`\n\nThe PRP is now ready for review. The factory will use this blueprint to generate the complete system once ambiguities are resolved.\n\n---\n\n**Commit**: `72f05ea` — \"Generate PRP for site-intelligence-pack system\"  \n**Confidence Score**: 9/10 (included in commit message for automated pipeline decisions)"}],"api":"anthropic-messages","provider":"anthropic","model":"claude-sonnet-4-5-20250929","usage":{"input":12,"output":985,"cacheRead":68056,"cacheWrite":618,"totalTokens":69671,"cost":{"input":0.000036,"output":0.014775,"cacheRead":0.0204168,"cacheWrite":0.0023175,"total":0.0375453}},"stopReason":"stop","timestamp":1771079219351}}
